(function(global,factory){typeof exports==='object'&&typeof module!=='undefined'?factory(exports):typeof define==='function'&&define.amd?define(['exports'],factory):(factory((global.xeogl={})))}(this,(function(exports){'use strict';class Map{constructor(items,baseId){this.items=items||[];this._lastUniqueId=(baseId||0)+1}
addItem(){let item;if(arguments.length===2){const id=arguments[0];item=arguments[1];if(this.items[id]){throw "ID clash: '"+id+"'"}
this.items[id]=item;return id}else{item=arguments[0]||{};while(!0){const findId=this._lastUniqueId++;if(!this.items[findId]){this.items[findId]=item;return findId}}}}
removeItem(id){const item=this.items[id];delete this.items[id];return item}}
const stats={build:{version:"0.8"},client:{browser:(navigator&&navigator.userAgent)?navigator.userAgent:"n/a"},components:{scenes:0,models:0,meshes:0,objects:0},memory:{meshes:0,positions:0,colors:0,normals:0,uvs:0,indices:0,textures:0,transforms:0,materials:0,programs:0},frame:{frameCount:0,fps:0,useProgram:0,bindTexture:0,bindArray:0,drawElements:0,drawArrays:0,tasksRun:0,tasksScheduled:0}};var utils={isArray:function(testMesh){return testMesh&&!(testMesh.propertyIsEnumerable('length'))&&typeof testMesh==='object'&&typeof testMesh.length==='number'},isString:function(value){return(typeof value==='string'||value instanceof String)},isNumeric:function(value){return!isNaN(parseFloat(value))&&isFinite(value)},isID:function(value){return utils.isString(value)||utils.isNumeric(value)},isSameComponent:function(c1,c2){if(!c1||!c2){return!1}
const id1=(utils.isNumeric(c1)||utils.isString(c1))?`${c1}`:c1.id;const id2=(utils.isNumeric(c2)||utils.isString(c2))?`${c2}`:c2.id;return id1===id2},isFunction:function(value){return(typeof value==="function")},isObject:function(value){const objectConstructor={}.constructor;return(!!value&&value.constructor===objectConstructor)},copy:function(o){return utils.apply(o,{})},apply:function(o,o2){for(const name in o){if(o.hasOwnProperty(name)){o2[name]=o[name]}}
return o2},apply2:function(o,o2){for(const name in o){if(o.hasOwnProperty(name)){if(o[name]!==undefined&&o[name]!==null){o2[name]=o[name]}}}
return o2},applyIf:function(o,o2){for(const name in o){if(o.hasOwnProperty(name)){if(o2[name]===undefined||o2[name]===null){o2[name]=o[name]}}}
return o2},isEmptyObject:function(obj){for(const name in obj){if(obj.hasOwnProperty(name)){return!1}}
return!0},inQuotes:function(id){return utils.isNumeric(id)?(`${id}`):(`'${id}'`)},concat:function(a,b){const c=new a.constructor(a.length+b.length);c.set(a);c.set(b,a.length);return c},};const tempMat1=new Float32Array(16);const tempMat2=new Float32Array(16);const tempVec4=new Float32Array(4);let caching=!1;const vec3Cache=[];let vec3CacheLen=0;const math={MAX_DOUBLE:Number.MAX_VALUE,MIN_DOUBLE:Number.MIN_VALUE,DEGTORAD:0.0174532925,RADTODEG:57.295779513,openCache(){caching=!0;vec3CacheLen=0},cacheVec3(value){return value||(caching?(vec3Cache[vec3CacheLen++]||(vec3Cache[vec3CacheLen-1]=new Float32Array(3))):new Float32Array(3))},cacheVec4(value){return value||(caching?(vec3Cache[vec4CacheLen++]||(vec3Cache[vec4CacheLen-1]=new Float32Array(4))):new Float32Array(4))},closeCache(){caching=!1},vec2(values){return new Float32Array(values||2)},vec3(values){return new Float32Array(values||3)},vec4(values){return new Float32Array(values||4)},mat3(values){return new Float32Array(values||9)},mat3ToMat4(mat3,mat4=new Float32Array(16)){mat4[0]=mat3[0];mat4[1]=mat3[1];mat4[2]=mat3[2];mat4[3]=0;mat4[4]=mat3[3];mat4[5]=mat3[4];mat4[6]=mat3[5];mat4[7]=0;mat4[8]=mat3[6];mat4[9]=mat3[7];mat4[10]=mat3[8];mat4[11]=0;mat4[12]=0;mat4[13]=0;mat4[14]=0;mat4[15]=1;return mat4},mat4(values){return new Float32Array(values||16)},mat4ToMat3(mat4,mat3){},createUUID:((()=>{const lut=[];for(let i=0;i<256;i++){lut[i]=(i<16?'0':'')+(i).toString(16)}
return()=>{const d0=Math.random()*0xffffffff|0;const d1=Math.random()*0xffffffff|0;const d2=Math.random()*0xffffffff|0;const d3=Math.random()*0xffffffff|0;return `${lut[d0 & 0xff] + lut[d0 >> 8 & 0xff] + lut[d0 >> 16 & 0xff] + lut[d0 >> 24 & 0xff]}-${lut[d1 & 0xff]}${lut[d1 >> 8 & 0xff]}-${lut[d1 >> 16 & 0x0f | 0x40]}${lut[d1 >> 24 & 0xff]}-${lut[d2 & 0x3f | 0x80]}${lut[d2 >> 8 & 0xff]}-${lut[d2 >> 16 & 0xff]}${lut[d2 >> 24 & 0xff]}${lut[d3 & 0xff]}${lut[d3 >> 8 & 0xff]}${lut[d3 >> 16 & 0xff]}${lut[d3 >> 24 & 0xff]}`}}))(),clamp(value,min,max){return Math.max(min,Math.min(max,value))},fmod(a,b){if(a<b){console.error("xeogl.math.fmod : Attempting to find modulus within negative range - would be infinite loop - ignoring");return a}
while(b<=a){a-=b}
return a},negateVec4(v,dest){if(!dest){dest=v}
dest[0]=-v[0];dest[1]=-v[1];dest[2]=-v[2];dest[3]=-v[3];return dest},addVec4(u,v,dest){if(!dest){dest=u}
dest[0]=u[0]+v[0];dest[1]=u[1]+v[1];dest[2]=u[2]+v[2];dest[3]=u[3]+v[3];return dest},addVec4Scalar(v,s,dest){if(!dest){dest=v}
dest[0]=v[0]+s;dest[1]=v[1]+s;dest[2]=v[2]+s;dest[3]=v[3]+s;return dest},addVec3(u,v,dest){if(!dest){dest=u}
dest[0]=u[0]+v[0];dest[1]=u[1]+v[1];dest[2]=u[2]+v[2];return dest},addVec3Scalar(v,s,dest){if(!dest){dest=v}
dest[0]=v[0]+s;dest[1]=v[1]+s;dest[2]=v[2]+s;return dest},subVec4(u,v,dest){if(!dest){dest=u}
dest[0]=u[0]-v[0];dest[1]=u[1]-v[1];dest[2]=u[2]-v[2];dest[3]=u[3]-v[3];return dest},subVec3(u,v,dest){if(!dest){dest=u}
dest[0]=u[0]-v[0];dest[1]=u[1]-v[1];dest[2]=u[2]-v[2];return dest},subVec2(u,v,dest){if(!dest){dest=u}
dest[0]=u[0]-v[0];dest[1]=u[1]-v[1];return dest},subVec4Scalar(v,s,dest){if(!dest){dest=v}
dest[0]=v[0]-s;dest[1]=v[1]-s;dest[2]=v[2]-s;dest[3]=v[3]-s;return dest},subScalarVec4(v,s,dest){if(!dest){dest=v}
dest[0]=s-v[0];dest[1]=s-v[1];dest[2]=s-v[2];dest[3]=s-v[3];return dest},mulVec4(u,v,dest){if(!dest){dest=u}
dest[0]=u[0]*v[0];dest[1]=u[1]*v[1];dest[2]=u[2]*v[2];dest[3]=u[3]*v[3];return dest},mulVec4Scalar(v,s,dest){if(!dest){dest=v}
dest[0]=v[0]*s;dest[1]=v[1]*s;dest[2]=v[2]*s;dest[3]=v[3]*s;return dest},mulVec3Scalar(v,s,dest){if(!dest){dest=v}
dest[0]=v[0]*s;dest[1]=v[1]*s;dest[2]=v[2]*s;return dest},mulVec2Scalar(v,s,dest){if(!dest){dest=v}
dest[0]=v[0]*s;dest[1]=v[1]*s;return dest},divVec3(u,v,dest){if(!dest){dest=u}
dest[0]=u[0]/v[0];dest[1]=u[1]/v[1];dest[2]=u[2]/v[2];return dest},divVec4(u,v,dest){if(!dest){dest=u}
dest[0]=u[0]/v[0];dest[1]=u[1]/v[1];dest[2]=u[2]/v[2];dest[3]=u[3]/v[3];return dest},divScalarVec3(s,v,dest){if(!dest){dest=v}
dest[0]=s/v[0];dest[1]=s/v[1];dest[2]=s/v[2];return dest},divVec3Scalar(v,s,dest){if(!dest){dest=v}
dest[0]=v[0]/s;dest[1]=v[1]/s;dest[2]=v[2]/s;return dest},divVec4Scalar(v,s,dest){if(!dest){dest=v}
dest[0]=v[0]/s;dest[1]=v[1]/s;dest[2]=v[2]/s;dest[3]=v[3]/s;return dest},divScalarVec4(s,v,dest){if(!dest){dest=v}
dest[0]=s/v[0];dest[1]=s/v[1];dest[2]=s/v[2];dest[3]=s/v[3];return dest},dotVec4(u,v){return(u[0]*v[0]+u[1]*v[1]+u[2]*v[2]+u[3]*v[3])},cross3Vec4(u,v){const u0=u[0];const u1=u[1];const u2=u[2];const v0=v[0];const v1=v[1];const v2=v[2];return[u1*v2-u2*v1,u2*v0-u0*v2,u0*v1-u1*v0,0.0]},cross3Vec3(u,v,dest){if(!dest){dest=u}
const x=u[0];const y=u[1];const z=u[2];const x2=v[0];const y2=v[1];const z2=v[2];dest[0]=y*z2-z*y2;dest[1]=z*x2-x*z2;dest[2]=x*y2-y*x2;return dest},sqLenVec4(v){return math.dotVec4(v,v)},lenVec4(v){return Math.sqrt(math.sqLenVec4(v))},dotVec3(u,v){return(u[0]*v[0]+u[1]*v[1]+u[2]*v[2])},dotVec2(u,v){return(u[0]*v[0]+u[1]*v[1])},sqLenVec3(v){return math.dotVec3(v,v)},sqLenVec2(v){return math.dotVec2(v,v)},lenVec3(v){return Math.sqrt(math.sqLenVec3(v))},distVec3:((()=>{const vec=new Float32Array(3);return(v,w)=>math.lenVec3(math.subVec3(v,w,vec))}))(),lenVec2(v){return Math.sqrt(math.sqLenVec2(v))},distVec2:((()=>{const vec=new Float32Array(2);return(v,w)=>math.lenVec2(math.subVec2(v,w,vec))}))(),rcpVec3(v,dest){return math.divScalarVec3(1.0,v,dest)},normalizeVec4(v,dest){const f=1.0/math.lenVec4(v);return math.mulVec4Scalar(v,f,dest)},normalizeVec3(v,dest){const f=1.0/math.lenVec3(v);return math.mulVec3Scalar(v,f,dest)},normalizeVec2(v,dest){const f=1.0/math.lenVec2(v);return math.mulVec2Scalar(v,f,dest)},angleVec3(v,w){let theta=math.dotVec3(v,w)/(Math.sqrt(math.sqLenVec3(v)*math.sqLenVec3(w)));theta=theta<-1?-1:(theta>1?1:theta);return Math.acos(theta)},vec3FromMat4Scale:((()=>{const tempVec3=new Float32Array(3);return(m,dest)=>{tempVec3[0]=m[0];tempVec3[1]=m[1];tempVec3[2]=m[2];dest[0]=math.lenVec3(tempVec3);tempVec3[0]=m[4];tempVec3[1]=m[5];tempVec3[2]=m[6];dest[1]=math.lenVec3(tempVec3);tempVec3[0]=m[8];tempVec3[1]=m[9];tempVec3[2]=m[10];dest[2]=math.lenVec3(tempVec3);return dest}}))(),vecToArray:((()=>{function trunc(v){return Math.round(v*100000)/100000}
return v=>{v=Array.prototype.slice.call(v);for(let i=0,len=v.length;i<len;i++){v[i]=trunc(v[i])}
return v}}))(),dupMat4(m){return m.slice(0,16)},mat4To3(m){return[m[0],m[1],m[2],m[4],m[5],m[6],m[8],m[9],m[10]]},m4s(s){return[s,s,s,s,s,s,s,s,s,s,s,s,s,s,s,s]},setMat4ToZeroes(){return math.m4s(0.0)},setMat4ToOnes(){return math.m4s(1.0)},diagonalMat4v(v){return new Float32Array([v[0],0.0,0.0,0.0,0.0,v[1],0.0,0.0,0.0,0.0,v[2],0.0,0.0,0.0,0.0,v[3]])},diagonalMat4c(x,y,z,w){return math.diagonalMat4v([x,y,z,w])},diagonalMat4s(s){return math.diagonalMat4c(s,s,s,s)},identityMat4(mat=new Float32Array(16)){mat[0]=1.0;mat[1]=0.0;mat[2]=0.0;mat[3]=0.0;mat[4]=0.0;mat[5]=1.0;mat[6]=0.0;mat[7]=0.0;mat[8]=0.0;mat[9]=0.0;mat[10]=1.0;mat[11]=0.0;mat[12]=0.0;mat[13]=0.0;mat[14]=0.0;mat[15]=1.0;return mat},identityMat3(mat=new Float32Array(9)){mat[0]=1.0;mat[1]=0.0;mat[2]=0.0;mat[3]=0.0;mat[4]=1.0;mat[5]=0.0;mat[6]=0.0;mat[7]=0.0;mat[8]=1.0;return mat},isIdentityMat4(m){if(m[0]!==1.0||m[1]!==0.0||m[2]!==0.0||m[3]!==0.0||m[4]!==0.0||m[5]!==1.0||m[6]!==0.0||m[7]!==0.0||m[8]!==0.0||m[9]!==0.0||m[10]!==1.0||m[11]!==0.0||m[12]!==0.0||m[13]!==0.0||m[14]!==0.0||m[15]!==1.0){return!1}
return!0},negateMat4(m,dest){if(!dest){dest=m}
dest[0]=-m[0];dest[1]=-m[1];dest[2]=-m[2];dest[3]=-m[3];dest[4]=-m[4];dest[5]=-m[5];dest[6]=-m[6];dest[7]=-m[7];dest[8]=-m[8];dest[9]=-m[9];dest[10]=-m[10];dest[11]=-m[11];dest[12]=-m[12];dest[13]=-m[13];dest[14]=-m[14];dest[15]=-m[15];return dest},addMat4(a,b,dest){if(!dest){dest=a}
dest[0]=a[0]+b[0];dest[1]=a[1]+b[1];dest[2]=a[2]+b[2];dest[3]=a[3]+b[3];dest[4]=a[4]+b[4];dest[5]=a[5]+b[5];dest[6]=a[6]+b[6];dest[7]=a[7]+b[7];dest[8]=a[8]+b[8];dest[9]=a[9]+b[9];dest[10]=a[10]+b[10];dest[11]=a[11]+b[11];dest[12]=a[12]+b[12];dest[13]=a[13]+b[13];dest[14]=a[14]+b[14];dest[15]=a[15]+b[15];return dest},addMat4Scalar(m,s,dest){if(!dest){dest=m}
dest[0]=m[0]+s;dest[1]=m[1]+s;dest[2]=m[2]+s;dest[3]=m[3]+s;dest[4]=m[4]+s;dest[5]=m[5]+s;dest[6]=m[6]+s;dest[7]=m[7]+s;dest[8]=m[8]+s;dest[9]=m[9]+s;dest[10]=m[10]+s;dest[11]=m[11]+s;dest[12]=m[12]+s;dest[13]=m[13]+s;dest[14]=m[14]+s;dest[15]=m[15]+s;return dest},addScalarMat4(s,m,dest){return math.addMat4Scalar(m,s,dest)},subMat4(a,b,dest){if(!dest){dest=a}
dest[0]=a[0]-b[0];dest[1]=a[1]-b[1];dest[2]=a[2]-b[2];dest[3]=a[3]-b[3];dest[4]=a[4]-b[4];dest[5]=a[5]-b[5];dest[6]=a[6]-b[6];dest[7]=a[7]-b[7];dest[8]=a[8]-b[8];dest[9]=a[9]-b[9];dest[10]=a[10]-b[10];dest[11]=a[11]-b[11];dest[12]=a[12]-b[12];dest[13]=a[13]-b[13];dest[14]=a[14]-b[14];dest[15]=a[15]-b[15];return dest},subMat4Scalar(m,s,dest){if(!dest){dest=m}
dest[0]=m[0]-s;dest[1]=m[1]-s;dest[2]=m[2]-s;dest[3]=m[3]-s;dest[4]=m[4]-s;dest[5]=m[5]-s;dest[6]=m[6]-s;dest[7]=m[7]-s;dest[8]=m[8]-s;dest[9]=m[9]-s;dest[10]=m[10]-s;dest[11]=m[11]-s;dest[12]=m[12]-s;dest[13]=m[13]-s;dest[14]=m[14]-s;dest[15]=m[15]-s;return dest},subScalarMat4(s,m,dest){if(!dest){dest=m}
dest[0]=s-m[0];dest[1]=s-m[1];dest[2]=s-m[2];dest[3]=s-m[3];dest[4]=s-m[4];dest[5]=s-m[5];dest[6]=s-m[6];dest[7]=s-m[7];dest[8]=s-m[8];dest[9]=s-m[9];dest[10]=s-m[10];dest[11]=s-m[11];dest[12]=s-m[12];dest[13]=s-m[13];dest[14]=s-m[14];dest[15]=s-m[15];return dest},mulMat4(a,b,dest){if(!dest){dest=a}
const a00=a[0];const a01=a[1];const a02=a[2];const a03=a[3];const a10=a[4];const a11=a[5];const a12=a[6];const a13=a[7];const a20=a[8];const a21=a[9];const a22=a[10];const a23=a[11];const a30=a[12];const a31=a[13];const a32=a[14];const a33=a[15];const b00=b[0];const b01=b[1];const b02=b[2];const b03=b[3];const b10=b[4];const b11=b[5];const b12=b[6];const b13=b[7];const b20=b[8];const b21=b[9];const b22=b[10];const b23=b[11];const b30=b[12];const b31=b[13];const b32=b[14];const b33=b[15];dest[0]=b00*a00+b01*a10+b02*a20+b03*a30;dest[1]=b00*a01+b01*a11+b02*a21+b03*a31;dest[2]=b00*a02+b01*a12+b02*a22+b03*a32;dest[3]=b00*a03+b01*a13+b02*a23+b03*a33;dest[4]=b10*a00+b11*a10+b12*a20+b13*a30;dest[5]=b10*a01+b11*a11+b12*a21+b13*a31;dest[6]=b10*a02+b11*a12+b12*a22+b13*a32;dest[7]=b10*a03+b11*a13+b12*a23+b13*a33;dest[8]=b20*a00+b21*a10+b22*a20+b23*a30;dest[9]=b20*a01+b21*a11+b22*a21+b23*a31;dest[10]=b20*a02+b21*a12+b22*a22+b23*a32;dest[11]=b20*a03+b21*a13+b22*a23+b23*a33;dest[12]=b30*a00+b31*a10+b32*a20+b33*a30;dest[13]=b30*a01+b31*a11+b32*a21+b33*a31;dest[14]=b30*a02+b31*a12+b32*a22+b33*a32;dest[15]=b30*a03+b31*a13+b32*a23+b33*a33;return dest},mulMat3(a,b,dest){if(!dest){dest=new Float32Array(9)}
const a11=a[0];const a12=a[3];const a13=a[6];const a21=a[1];const a22=a[4];const a23=a[7];const a31=a[2];const a32=a[5];const a33=a[8];const b11=b[0];const b12=b[3];const b13=b[6];const b21=b[1];const b22=b[4];const b23=b[7];const b31=b[2];const b32=b[5];const b33=b[8];dest[0]=a11*b11+a12*b21+a13*b31;dest[3]=a11*b12+a12*b22+a13*b32;dest[6]=a11*b13+a12*b23+a13*b33;dest[1]=a21*b11+a22*b21+a23*b31;dest[4]=a21*b12+a22*b22+a23*b32;dest[7]=a21*b13+a22*b23+a23*b33;dest[2]=a31*b11+a32*b21+a33*b31;dest[5]=a31*b12+a32*b22+a33*b32;dest[8]=a31*b13+a32*b23+a33*b33;return dest},mulMat4Scalar(m,s,dest){if(!dest){dest=m}
dest[0]=m[0]*s;dest[1]=m[1]*s;dest[2]=m[2]*s;dest[3]=m[3]*s;dest[4]=m[4]*s;dest[5]=m[5]*s;dest[6]=m[6]*s;dest[7]=m[7]*s;dest[8]=m[8]*s;dest[9]=m[9]*s;dest[10]=m[10]*s;dest[11]=m[11]*s;dest[12]=m[12]*s;dest[13]=m[13]*s;dest[14]=m[14]*s;dest[15]=m[15]*s;return dest},mulMat4v4(m,v,dest=math.vec4()){const v0=v[0];const v1=v[1];const v2=v[2];const v3=v[3];dest[0]=m[0]*v0+m[4]*v1+m[8]*v2+m[12]*v3;dest[1]=m[1]*v0+m[5]*v1+m[9]*v2+m[13]*v3;dest[2]=m[2]*v0+m[6]*v1+m[10]*v2+m[14]*v3;dest[3]=m[3]*v0+m[7]*v1+m[11]*v2+m[15]*v3;return dest},transposeMat4(mat,dest){const m4=mat[4];const m14=mat[14];const m8=mat[8];const m13=mat[13];const m12=mat[12];const m9=mat[9];if(!dest||mat===dest){const a01=mat[1];const a02=mat[2];const a03=mat[3];const a12=mat[6];const a13=mat[7];const a23=mat[11];mat[1]=m4;mat[2]=m8;mat[3]=m12;mat[4]=a01;mat[6]=m9;mat[7]=m13;mat[8]=a02;mat[9]=a12;mat[11]=m14;mat[12]=a03;mat[13]=a13;mat[14]=a23;return mat}
dest[0]=mat[0];dest[1]=m4;dest[2]=m8;dest[3]=m12;dest[4]=mat[1];dest[5]=mat[5];dest[6]=m9;dest[7]=m13;dest[8]=mat[2];dest[9]=mat[6];dest[10]=mat[10];dest[11]=m14;dest[12]=mat[3];dest[13]=mat[7];dest[14]=mat[11];dest[15]=mat[15];return dest},transposeMat3(mat,dest){if(dest===mat){const a01=mat[1];const a02=mat[2];const a12=mat[5];dest[1]=mat[3];dest[2]=mat[6];dest[3]=a01;dest[5]=mat[7];dest[6]=a02;dest[7]=a12}else{dest[0]=mat[0];dest[1]=mat[3];dest[2]=mat[6];dest[3]=mat[1];dest[4]=mat[4];dest[5]=mat[7];dest[6]=mat[2];dest[7]=mat[5];dest[8]=mat[8]}
return dest},determinantMat4(mat){const a00=mat[0];const a01=mat[1];const a02=mat[2];const a03=mat[3];const a10=mat[4];const a11=mat[5];const a12=mat[6];const a13=mat[7];const a20=mat[8];const a21=mat[9];const a22=mat[10];const a23=mat[11];const a30=mat[12];const a31=mat[13];const a32=mat[14];const a33=mat[15];return a30*a21*a12*a03-a20*a31*a12*a03-a30*a11*a22*a03+a10*a31*a22*a03+a20*a11*a32*a03-a10*a21*a32*a03-a30*a21*a02*a13+a20*a31*a02*a13+a30*a01*a22*a13-a00*a31*a22*a13-a20*a01*a32*a13+a00*a21*a32*a13+a30*a11*a02*a23-a10*a31*a02*a23-a30*a01*a12*a23+a00*a31*a12*a23+a10*a01*a32*a23-a00*a11*a32*a23-a20*a11*a02*a33+a10*a21*a02*a33+a20*a01*a12*a33-a00*a21*a12*a33-a10*a01*a22*a33+a00*a11*a22*a33},inverseMat4(mat,dest){if(!dest){dest=mat}
const a00=mat[0];const a01=mat[1];const a02=mat[2];const a03=mat[3];const a10=mat[4];const a11=mat[5];const a12=mat[6];const a13=mat[7];const a20=mat[8];const a21=mat[9];const a22=mat[10];const a23=mat[11];const a30=mat[12];const a31=mat[13];const a32=mat[14];const a33=mat[15];const b00=a00*a11-a01*a10;const b01=a00*a12-a02*a10;const b02=a00*a13-a03*a10;const b03=a01*a12-a02*a11;const b04=a01*a13-a03*a11;const b05=a02*a13-a03*a12;const b06=a20*a31-a21*a30;const b07=a20*a32-a22*a30;const b08=a20*a33-a23*a30;const b09=a21*a32-a22*a31;const b10=a21*a33-a23*a31;const b11=a22*a33-a23*a32;const invDet=1/(b00*b11-b01*b10+b02*b09+b03*b08-b04*b07+b05*b06);dest[0]=(a11*b11-a12*b10+a13*b09)*invDet;dest[1]=(-a01*b11+a02*b10-a03*b09)*invDet;dest[2]=(a31*b05-a32*b04+a33*b03)*invDet;dest[3]=(-a21*b05+a22*b04-a23*b03)*invDet;dest[4]=(-a10*b11+a12*b08-a13*b07)*invDet;dest[5]=(a00*b11-a02*b08+a03*b07)*invDet;dest[6]=(-a30*b05+a32*b02-a33*b01)*invDet;dest[7]=(a20*b05-a22*b02+a23*b01)*invDet;dest[8]=(a10*b10-a11*b08+a13*b06)*invDet;dest[9]=(-a00*b10+a01*b08-a03*b06)*invDet;dest[10]=(a30*b04-a31*b02+a33*b00)*invDet;dest[11]=(-a20*b04+a21*b02-a23*b00)*invDet;dest[12]=(-a10*b09+a11*b07-a12*b06)*invDet;dest[13]=(a00*b09-a01*b07+a02*b06)*invDet;dest[14]=(-a30*b03+a31*b01-a32*b00)*invDet;dest[15]=(a20*b03-a21*b01+a22*b00)*invDet;return dest},traceMat4(m){return(m[0]+m[5]+m[10]+m[15])},translationMat4v(v,dest){const m=dest||math.identityMat4();m[12]=v[0];m[13]=v[1];m[14]=v[2];return m},translationMat3v(v,dest){const m=dest||math.identityMat3();m[6]=v[0];m[7]=v[1];return m},translationMat4c:((()=>{const xyz=new Float32Array(3);return(x,y,z,dest)=>{xyz[0]=x;xyz[1]=y;xyz[2]=z;return math.translationMat4v(xyz,dest)}}))(),translationMat4s(s,dest){return math.translationMat4c(s,s,s,dest)},translateMat4v(xyz,m){return math.translateMat4c(xyz[0],xyz[1],xyz[2],m)},OLDtranslateMat4c(x,y,z,m){const m12=m[12];m[0]+=m12*x;m[4]+=m12*y;m[8]+=m12*z;const m13=m[13];m[1]+=m13*x;m[5]+=m13*y;m[9]+=m13*z;const m14=m[14];m[2]+=m14*x;m[6]+=m14*y;m[10]+=m14*z;const m15=m[15];m[3]+=m15*x;m[7]+=m15*y;m[11]+=m15*z;return m},translateMat4c(x,y,z,m){const m3=m[3];m[0]+=m3*x;m[1]+=m3*y;m[2]+=m3*z;const m7=m[7];m[4]+=m7*x;m[5]+=m7*y;m[6]+=m7*z;const m11=m[11];m[8]+=m11*x;m[9]+=m11*y;m[10]+=m11*z;const m15=m[15];m[12]+=m15*x;m[13]+=m15*y;m[14]+=m15*z;return m},rotationMat4v(anglerad,axis,m){const ax=math.normalizeVec4([axis[0],axis[1],axis[2],0.0],[]);const s=Math.sin(anglerad);const c=Math.cos(anglerad);const q=1.0-c;const x=ax[0];const y=ax[1];const z=ax[2];let xy;let yz;let zx;let xs;let ys;let zs;xy=x*y;yz=y*z;zx=z*x;xs=x*s;ys=y*s;zs=z*s;m=m||math.mat4();m[0]=(q*x*x)+c;m[1]=(q*xy)+zs;m[2]=(q*zx)-ys;m[3]=0.0;m[4]=(q*xy)-zs;m[5]=(q*y*y)+c;m[6]=(q*yz)+xs;m[7]=0.0;m[8]=(q*zx)+ys;m[9]=(q*yz)-xs;m[10]=(q*z*z)+c;m[11]=0.0;m[12]=0.0;m[13]=0.0;m[14]=0.0;m[15]=1.0;return m},rotationMat4c(anglerad,x,y,z,mat){return math.rotationMat4v(anglerad,[x,y,z],mat)},scalingMat4v(v,m=math.identityMat4()){m[0]=v[0];m[5]=v[1];m[10]=v[2];return m},scalingMat3v(v,m=math.identityMat3()){m[0]=v[0];m[4]=v[1];return m},scalingMat4c:((()=>{const xyz=new Float32Array(3);return(x,y,z,dest)=>{xyz[0]=x;xyz[1]=y;xyz[2]=z;return math.scalingMat4v(xyz,dest)}}))(),scaleMat4c(x,y,z,m){m[0]*=x;m[4]*=y;m[8]*=z;m[1]*=x;m[5]*=y;m[9]*=z;m[2]*=x;m[6]*=y;m[10]*=z;m[3]*=x;m[7]*=y;m[11]*=z;return m},scaleMat4v(xyz,m){const x=xyz[0];const y=xyz[1];const z=xyz[2];m[0]*=x;m[4]*=y;m[8]*=z;m[1]*=x;m[5]*=y;m[9]*=z;m[2]*=x;m[6]*=y;m[10]*=z;m[3]*=x;m[7]*=y;m[11]*=z;return m},scalingMat4s(s){return math.scalingMat4c(s,s,s)},rotationTranslationMat4(q,v,dest=math.mat4()){const x=q[0];const y=q[1];const z=q[2];const w=q[3];const x2=x+x;const y2=y+y;const z2=z+z;const xx=x*x2;const xy=x*y2;const xz=x*z2;const yy=y*y2;const yz=y*z2;const zz=z*z2;const wx=w*x2;const wy=w*y2;const wz=w*z2;dest[0]=1-(yy+zz);dest[1]=xy+wz;dest[2]=xz-wy;dest[3]=0;dest[4]=xy-wz;dest[5]=1-(xx+zz);dest[6]=yz+wx;dest[7]=0;dest[8]=xz+wy;dest[9]=yz-wx;dest[10]=1-(xx+yy);dest[11]=0;dest[12]=v[0];dest[13]=v[1];dest[14]=v[2];dest[15]=1;return dest},mat4ToEuler(mat,order,dest=math.vec4()){const clamp=math.clamp;const m11=mat[0];const m12=mat[4];const m13=mat[8];const m21=mat[1];const m22=mat[5];const m23=mat[9];const m31=mat[2];const m32=mat[6];const m33=mat[10];if(order==='XYZ'){dest[1]=Math.asin(clamp(m13,-1,1));if(Math.abs(m13)<0.99999){dest[0]=Math.atan2(-m23,m33);dest[2]=Math.atan2(-m12,m11)}else{dest[0]=Math.atan2(m32,m22);dest[2]=0}}else if(order==='YXZ'){dest[0]=Math.asin(-clamp(m23,-1,1));if(Math.abs(m23)<0.99999){dest[1]=Math.atan2(m13,m33);dest[2]=Math.atan2(m21,m22)}else{dest[1]=Math.atan2(-m31,m11);dest[2]=0}}else if(order==='ZXY'){dest[0]=Math.asin(clamp(m32,-1,1));if(Math.abs(m32)<0.99999){dest[1]=Math.atan2(-m31,m33);dest[2]=Math.atan2(-m12,m22)}else{dest[1]=0;dest[2]=Math.atan2(m21,m11)}}else if(order==='ZYX'){dest[1]=Math.asin(-clamp(m31,-1,1));if(Math.abs(m31)<0.99999){dest[0]=Math.atan2(m32,m33);dest[2]=Math.atan2(m21,m11)}else{dest[0]=0;dest[2]=Math.atan2(-m12,m22)}}else if(order==='YZX'){dest[2]=Math.asin(clamp(m21,-1,1));if(Math.abs(m21)<0.99999){dest[0]=Math.atan2(-m23,m22);dest[1]=Math.atan2(-m31,m11)}else{dest[0]=0;dest[1]=Math.atan2(m13,m33)}}else if(order==='XZY'){dest[2]=Math.asin(-clamp(m12,-1,1));if(Math.abs(m12)<0.99999){dest[0]=Math.atan2(m32,m22);dest[1]=Math.atan2(m13,m11)}else{dest[0]=Math.atan2(-m23,m33);dest[1]=0}}
return dest},composeMat4(position,quaternion,scale,mat=math.mat4()){math.quaternionToRotationMat4(quaternion,mat);math.scaleMat4v(scale,mat);math.translateMat4v(position,mat);return mat},decomposeMat4:(()=>{const vec=new Float32Array(3);const matrix=new Float32Array(16);return function decompose(mat,position,quaternion,scale){vec[0]=mat[0];vec[1]=mat[1];vec[2]=mat[2];let sx=math.lenVec3(vec);vec[0]=mat[4];vec[1]=mat[5];vec[2]=mat[6];const sy=math.lenVec3(vec);vec[8]=mat[8];vec[9]=mat[9];vec[10]=mat[10];const sz=math.lenVec3(vec);const det=math.determinantMat4(mat);if(det<0){sx=-sx}
position[0]=mat[12];position[1]=mat[13];position[2]=mat[14];matrix.set(mat);const invSX=1/sx;const invSY=1/sy;const invSZ=1/sz;matrix[0]*=invSX;matrix[1]*=invSX;matrix[2]*=invSX;matrix[4]*=invSY;matrix[5]*=invSY;matrix[6]*=invSY;matrix[8]*=invSZ;matrix[9]*=invSZ;matrix[10]*=invSZ;math.mat4ToQuaternion(matrix,quaternion);scale[0]=sx;scale[1]=sy;scale[2]=sz;return this}})(),lookAtMat4v(pos,target,up,dest){if(!dest){dest=math.mat4()}
const posx=pos[0];const posy=pos[1];const posz=pos[2];const upx=up[0];const upy=up[1];const upz=up[2];const targetx=target[0];const targety=target[1];const targetz=target[2];if(posx===targetx&&posy===targety&&posz===targetz){return math.identityMat4()}
let z0;let z1;let z2;let x0;let x1;let x2;let y0;let y1;let y2;let len;z0=posx-targetx;z1=posy-targety;z2=posz-targetz;len=1/Math.sqrt(z0*z0+z1*z1+z2*z2);z0*=len;z1*=len;z2*=len;x0=upy*z2-upz*z1;x1=upz*z0-upx*z2;x2=upx*z1-upy*z0;len=Math.sqrt(x0*x0+x1*x1+x2*x2);if(!len){x0=0;x1=0;x2=0}else{len=1/len;x0*=len;x1*=len;x2*=len}
y0=z1*x2-z2*x1;y1=z2*x0-z0*x2;y2=z0*x1-z1*x0;len=Math.sqrt(y0*y0+y1*y1+y2*y2);if(!len){y0=0;y1=0;y2=0}else{len=1/len;y0*=len;y1*=len;y2*=len}
dest[0]=x0;dest[1]=y0;dest[2]=z0;dest[3]=0;dest[4]=x1;dest[5]=y1;dest[6]=z1;dest[7]=0;dest[8]=x2;dest[9]=y2;dest[10]=z2;dest[11]=0;dest[12]=-(x0*posx+x1*posy+x2*posz);dest[13]=-(y0*posx+y1*posy+y2*posz);dest[14]=-(z0*posx+z1*posy+z2*posz);dest[15]=1;return dest},lookAtMat4c(posx,posy,posz,targetx,targety,targetz,upx,upy,upz){return math.lookAtMat4v([posx,posy,posz],[targetx,targety,targetz],[upx,upy,upz],[])},orthoMat4c(left,right,bottom,top,near,far,dest){if(!dest){dest=math.mat4()}
const rl=(right-left);const tb=(top-bottom);const fn=(far-near);dest[0]=2.0/rl;dest[1]=0.0;dest[2]=0.0;dest[3]=0.0;dest[4]=0.0;dest[5]=2.0/tb;dest[6]=0.0;dest[7]=0.0;dest[8]=0.0;dest[9]=0.0;dest[10]=-2.0/fn;dest[11]=0.0;dest[12]=-(left+right)/rl;dest[13]=-(top+bottom)/tb;dest[14]=-(far+near)/fn;dest[15]=1.0;return dest},frustumMat4v(fmin,fmax,m){if(!m){m=math.mat4()}
const fmin4=[fmin[0],fmin[1],fmin[2],0.0];const fmax4=[fmax[0],fmax[1],fmax[2],0.0];math.addVec4(fmax4,fmin4,tempMat1);math.subVec4(fmax4,fmin4,tempMat2);const t=2.0*fmin4[2];const tempMat20=tempMat2[0];const tempMat21=tempMat2[1];const tempMat22=tempMat2[2];m[0]=t/tempMat20;m[1]=0.0;m[2]=0.0;m[3]=0.0;m[4]=0.0;m[5]=t/tempMat21;m[6]=0.0;m[7]=0.0;m[8]=tempMat1[0]/tempMat20;m[9]=tempMat1[1]/tempMat21;m[10]=-tempMat1[2]/tempMat22;m[11]=-1.0;m[12]=0.0;m[13]=0.0;m[14]=-t*fmax4[2]/tempMat22;m[15]=0.0;return m},frustumMat4(left,right,bottom,top,near,far,dest){if(!dest){dest=math.mat4()}
const rl=(right-left);const tb=(top-bottom);const fn=(far-near);dest[0]=(near*2)/rl;dest[1]=0;dest[2]=0;dest[3]=0;dest[4]=0;dest[5]=(near*2)/tb;dest[6]=0;dest[7]=0;dest[8]=(right+left)/rl;dest[9]=(top+bottom)/tb;dest[10]=-(far+near)/fn;dest[11]=-1;dest[12]=0;dest[13]=0;dest[14]=-(far*near*2)/fn;dest[15]=0;return dest},perspectiveMat4(fovyrad,aspectratio,znear,zfar,m){const pmin=[];const pmax=[];pmin[2]=znear;pmax[2]=zfar;pmax[1]=pmin[2]*Math.tan(fovyrad/2.0);pmin[1]=-pmax[1];pmax[0]=pmax[1]*aspectratio;pmin[0]=-pmax[0];return math.frustumMat4v(pmin,pmax,m)},transformPoint3(m,p,dest=math.vec3()){dest[0]=(m[0]*p[0])+(m[4]*p[1])+(m[8]*p[2])+m[12];dest[1]=(m[1]*p[0])+(m[5]*p[1])+(m[9]*p[2])+m[13];dest[2]=(m[2]*p[0])+(m[6]*p[1])+(m[10]*p[2])+m[14];return dest},transformPoint4(m,v,dest=math.vec4()){dest[0]=m[0]*v[0]+m[4]*v[1]+m[8]*v[2]+m[12]*v[3];dest[1]=m[1]*v[0]+m[5]*v[1]+m[9]*v[2]+m[13]*v[3];dest[2]=m[2]*v[0]+m[6]*v[1]+m[10]*v[2]+m[14]*v[3];dest[3]=m[3]*v[0]+m[7]*v[1]+m[11]*v[2]+m[15]*v[3];return dest},transformPoints3(m,points,points2){const result=points2||[];const len=points.length;let p0;let p1;let p2;let pi;const m0=m[0];const m1=m[1];const m2=m[2];const m3=m[3];const m4=m[4];const m5=m[5];const m6=m[6];const m7=m[7];const m8=m[8];const m9=m[9];const m10=m[10];const m11=m[11];const m12=m[12];const m13=m[13];const m14=m[14];const m15=m[15];let r;for(let i=0;i<len;++i){pi=points[i];p0=pi[0];p1=pi[1];p2=pi[2];r=result[i]||(result[i]=[0,0,0]);r[0]=(m0*p0)+(m4*p1)+(m8*p2)+m12;r[1]=(m1*p0)+(m5*p1)+(m9*p2)+m13;r[2]=(m2*p0)+(m6*p1)+(m10*p2)+m14;r[3]=(m3*p0)+(m7*p1)+(m11*p2)+m15}
result.length=len;return result},transformPositions3(m,p,p2=p){let i;const len=p.length;let x;let y;let z;const m0=m[0];const m1=m[1];const m2=m[2];const m3=m[3];const m4=m[4];const m5=m[5];const m6=m[6];const m7=m[7];const m8=m[8];const m9=m[9];const m10=m[10];const m11=m[11];const m12=m[12];const m13=m[13];const m14=m[14];const m15=m[15];for(i=0;i<len;i+=3){x=p[i+0];y=p[i+1];z=p[i+2];p2[i+0]=(m0*x)+(m4*y)+(m8*z)+m12;p2[i+1]=(m1*x)+(m5*y)+(m9*z)+m13;p2[i+2]=(m2*x)+(m6*y)+(m10*z)+m14;p2[i+3]=(m3*x)+(m7*y)+(m11*z)+m15}
return p2},transformPositions4(m,p,p2=p){let i;const len=p.length;let x;let y;let z;const m0=m[0];const m1=m[1];const m2=m[2];const m3=m[3];const m4=m[4];const m5=m[5];const m6=m[6];const m7=m[7];const m8=m[8];const m9=m[9];const m10=m[10];const m11=m[11];const m12=m[12];const m13=m[13];const m14=m[14];const m15=m[15];for(i=0;i<len;i+=4){x=p[i+0];y=p[i+1];z=p[i+2];p2[i+0]=(m0*x)+(m4*y)+(m8*z)+m12;p2[i+1]=(m1*x)+(m5*y)+(m9*z)+m13;p2[i+2]=(m2*x)+(m6*y)+(m10*z)+m14;p2[i+3]=(m3*x)+(m7*y)+(m11*z)+m15}
return p2},transformVec3(m,v,dest){const v0=v[0];const v1=v[1];const v2=v[2];dest=dest||this.vec3();dest[0]=(m[0]*v0)+(m[4]*v1)+(m[8]*v2);dest[1]=(m[1]*v0)+(m[5]*v1)+(m[9]*v2);dest[2]=(m[2]*v0)+(m[6]*v1)+(m[10]*v2);return dest},transformVec4(m,v,dest){const v0=v[0];const v1=v[1];const v2=v[2];const v3=v[3];dest=dest||math.vec4();dest[0]=m[0]*v0+m[4]*v1+m[8]*v2+m[12]*v3;dest[1]=m[1]*v0+m[5]*v1+m[9]*v2+m[13]*v3;dest[2]=m[2]*v0+m[6]*v1+m[10]*v2+m[14]*v3;dest[3]=m[3]*v0+m[7]*v1+m[11]*v2+m[15]*v3;return dest},rotateVec3X(a,b,c,dest){const p=[];const r=[];p[0]=a[0]-b[0];p[1]=a[1]-b[1];p[2]=a[2]-b[2];r[0]=p[0];r[1]=p[1]*Math.cos(c)-p[2]*Math.sin(c);r[2]=p[1]*Math.sin(c)+p[2]*Math.cos(c);dest[0]=r[0]+b[0];dest[1]=r[1]+b[1];dest[2]=r[2]+b[2];return dest},rotateVec3Y(a,b,c,dest){const p=[];const r=[];p[0]=a[0]-b[0];p[1]=a[1]-b[1];p[2]=a[2]-b[2];r[0]=p[2]*Math.sin(c)+p[0]*Math.cos(c);r[1]=p[1];r[2]=p[2]*Math.cos(c)-p[0]*Math.sin(c);dest[0]=r[0]+b[0];dest[1]=r[1]+b[1];dest[2]=r[2]+b[2];return dest},rotateVec3Z(a,b,c,dest){const p=[];const r=[];p[0]=a[0]-b[0];p[1]=a[1]-b[1];p[2]=a[2]-b[2];r[0]=p[0]*Math.cos(c)-p[1]*Math.sin(c);r[1]=p[0]*Math.sin(c)+p[1]*Math.cos(c);r[2]=p[2];dest[0]=r[0]+b[0];dest[1]=r[1]+b[1];dest[2]=r[2]+b[2];return dest},projectVec4(p,q){const f=1.0/p[3];q=q||math.vec2();q[0]=v[0]*f;q[1]=v[1]*f;return q},unprojectVec3:((()=>{const mat=new Float32Array(16);const mat2=new Float32Array(16);const mat3=new Float32Array(16);return function(p,viewMat,projMat,q){return this.transformVec3(this.mulMat4(this.inverseMat4(viewMat,mat),this.inverseMat4(projMat,mat2),mat3),p,q)}}))(),lerpVec3(t,t1,t2,p1,p2,dest){const result=dest||math.vec3();const f=(t-t1)/(t2-t1);result[0]=p1[0]+(f*(p2[0]-p1[0]));result[1]=p1[1]+(f*(p2[1]-p1[1]));result[2]=p1[2]+(f*(p2[2]-p1[2]));return result},flatten(a){const result=[];let i;let leni;let j;let lenj;let item;for(i=0,leni=a.length;i<leni;i++){item=a[i];for(j=0,lenj=item.length;j<lenj;j++){result.push(item[j])}}
return result},identityQuaternion(dest=math.vec4()){dest[0]=0.0;dest[1]=0.0;dest[2]=0.0;dest[3]=1.0;return dest},eulerToQuaternion(euler,order,dest=math.vec4()){const a=(euler[0]*math.DEGTORAD)/2;const b=(euler[1]*math.DEGTORAD)/2;const c=(euler[2]*math.DEGTORAD)/2;const c1=Math.cos(a);const c2=Math.cos(b);const c3=Math.cos(c);const s1=Math.sin(a);const s2=Math.sin(b);const s3=Math.sin(c);if(order==='XYZ'){dest[0]=s1*c2*c3+c1*s2*s3;dest[1]=c1*s2*c3-s1*c2*s3;dest[2]=c1*c2*s3+s1*s2*c3;dest[3]=c1*c2*c3-s1*s2*s3}else if(order==='YXZ'){dest[0]=s1*c2*c3+c1*s2*s3;dest[1]=c1*s2*c3-s1*c2*s3;dest[2]=c1*c2*s3-s1*s2*c3;dest[3]=c1*c2*c3+s1*s2*s3}else if(order==='ZXY'){dest[0]=s1*c2*c3-c1*s2*s3;dest[1]=c1*s2*c3+s1*c2*s3;dest[2]=c1*c2*s3+s1*s2*c3;dest[3]=c1*c2*c3-s1*s2*s3}else if(order==='ZYX'){dest[0]=s1*c2*c3-c1*s2*s3;dest[1]=c1*s2*c3+s1*c2*s3;dest[2]=c1*c2*s3-s1*s2*c3;dest[3]=c1*c2*c3+s1*s2*s3}else if(order==='YZX'){dest[0]=s1*c2*c3+c1*s2*s3;dest[1]=c1*s2*c3+s1*c2*s3;dest[2]=c1*c2*s3-s1*s2*c3;dest[3]=c1*c2*c3-s1*s2*s3}else if(order==='XZY'){dest[0]=s1*c2*c3-c1*s2*s3;dest[1]=c1*s2*c3-s1*c2*s3;dest[2]=c1*c2*s3+s1*s2*c3;dest[3]=c1*c2*c3+s1*s2*s3}
return dest},mat4ToQuaternion(m,dest=math.vec4()){const m11=m[0];const m12=m[4];const m13=m[8];const m21=m[1];const m22=m[5];const m23=m[9];const m31=m[2];const m32=m[6];const m33=m[10];let s;const trace=m11+m22+m33;if(trace>0){s=0.5/Math.sqrt(trace+1.0);dest[3]=0.25/s;dest[0]=(m32-m23)*s;dest[1]=(m13-m31)*s;dest[2]=(m21-m12)*s}else if(m11>m22&&m11>m33){s=2.0*Math.sqrt(1.0+m11-m22-m33);dest[3]=(m32-m23)/s;dest[0]=0.25*s;dest[1]=(m12+m21)/s;dest[2]=(m13+m31)/s}else if(m22>m33){s=2.0*Math.sqrt(1.0+m22-m11-m33);dest[3]=(m13-m31)/s;dest[0]=(m12+m21)/s;dest[1]=0.25*s;dest[2]=(m23+m32)/s}else{s=2.0*Math.sqrt(1.0+m33-m11-m22);dest[3]=(m21-m12)/s;dest[0]=(m13+m31)/s;dest[1]=(m23+m32)/s;dest[2]=0.25*s}
return dest},vec3PairToQuaternion(u,v,dest=math.vec4()){const norm_u_norm_v=Math.sqrt(math.dotVec3(u,u)*math.dotVec3(v,v));let real_part=norm_u_norm_v+math.dotVec3(u,v);if(real_part<0.00000001*norm_u_norm_v){real_part=0.0;if(Math.abs(u[0])>Math.abs(u[2])){dest[0]=-u[1];dest[1]=u[0];dest[2]=0}else{dest[0]=0;dest[1]=-u[2];dest[2]=u[1]}}else{math.cross3Vec3(u,v,dest)}
dest[3]=real_part;return math.normalizeQuaternion(dest)},angleAxisToQuaternion(angleAxis,dest=math.vec4()){const halfAngle=angleAxis[3]/2.0;const fsin=Math.sin(halfAngle);dest[0]=fsin*angleAxis[0];dest[1]=fsin*angleAxis[1];dest[2]=fsin*angleAxis[2];dest[3]=Math.cos(halfAngle);return dest},quaternionToEuler:((()=>{const mat=new Float32Array(16);return(q,order,dest)=>{dest=dest||math.vec3();math.quaternionToRotationMat4(q,mat);math.mat4ToEuler(mat,order,dest);return dest}}))(),mulQuaternions(p,q,dest=math.vec4()){const p0=p[0];const p1=p[1];const p2=p[2];const p3=p[3];const q0=q[0];const q1=q[1];const q2=q[2];const q3=q[3];dest[0]=p3*q0+p0*q3+p1*q2-p2*q1;dest[1]=p3*q1+p1*q3+p2*q0-p0*q2;dest[2]=p3*q2+p2*q3+p0*q1-p1*q0;dest[3]=p3*q3-p0*q0-p1*q1-p2*q2;return dest},vec3ApplyQuaternion(q,vec,dest=math.vec3()){const x=vec[0];const y=vec[1];const z=vec[2];const qx=q[0];const qy=q[1];const qz=q[2];const qw=q[3];const ix=qw*x+qy*z-qz*y;const iy=qw*y+qz*x-qx*z;const iz=qw*z+qx*y-qy*x;const iw=-qx*x-qy*y-qz*z;dest[0]=ix*qw+iw*-qx+iy*-qz-iz*-qy;dest[1]=iy*qw+iw*-qy+iz*-qx-ix*-qz;dest[2]=iz*qw+iw*-qz+ix*-qy-iy*-qx;return dest},quaternionToMat4(q,dest){dest=math.identityMat4(dest);const q0=q[0];const q1=q[1];const q2=q[2];const q3=q[3];const tx=2.0*q0;const ty=2.0*q1;const tz=2.0*q2;const twx=tx*q3;const twy=ty*q3;const twz=tz*q3;const txx=tx*q0;const txy=ty*q0;const txz=tz*q0;const tyy=ty*q1;const tyz=tz*q1;const tzz=tz*q2;dest[0]=1.0-(tyy+tzz);dest[1]=txy+twz;dest[2]=txz-twy;dest[4]=txy-twz;dest[5]=1.0-(txx+tzz);dest[6]=tyz+twx;dest[8]=txz+twy;dest[9]=tyz-twx;dest[10]=1.0-(txx+tyy);return dest},quaternionToRotationMat4(q,m){const x=q[0];const y=q[1];const z=q[2];const w=q[3];const x2=x+x;const y2=y+y;const z2=z+z;const xx=x*x2;const xy=x*y2;const xz=x*z2;const yy=y*y2;const yz=y*z2;const zz=z*z2;const wx=w*x2;const wy=w*y2;const wz=w*z2;m[0]=1-(yy+zz);m[4]=xy-wz;m[8]=xz+wy;m[1]=xy+wz;m[5]=1-(xx+zz);m[9]=yz-wx;m[2]=xz-wy;m[6]=yz+wx;m[10]=1-(xx+yy);m[3]=0;m[7]=0;m[11]=0;m[12]=0;m[13]=0;m[14]=0;m[15]=1;return m},normalizeQuaternion(q,dest=q){const len=math.lenVec4([q[0],q[1],q[2],q[3]]);dest[0]=q[0]/len;dest[1]=q[1]/len;dest[2]=q[2]/len;dest[3]=q[3]/len;return dest},conjugateQuaternion(q,dest=q){dest[0]=-q[0];dest[1]=-q[1];dest[2]=-q[2];dest[3]=q[3];return dest},inverseQuaternion(q,dest){return math.normalizeQuaternion(math.conjugateQuaternion(q,dest))},quaternionToAngleAxis(q,angleAxis=math.vec4()){q=math.normalizeQuaternion(q,tempVec4);const q3=q[3];const angle=2*Math.acos(q3);const s=Math.sqrt(1-q3*q3);if(s<0.001){angleAxis[0]=q[0];angleAxis[1]=q[1];angleAxis[2]=q[2]}else{angleAxis[0]=q[0]/s;angleAxis[1]=q[1]/s;angleAxis[2]=q[2]/s}
angleAxis[3]=angle;return angleAxis},decompressPosition(position,decodeMatrix,dest){dest[0]=position[0]*decodeMatrix[0]+decodeMatrix[12];dest[1]=position[1]*decodeMatrix[5]+decodeMatrix[13];dest[2]=position[2]*decodeMatrix[10]+decodeMatrix[14]},decompressPositions(positions,decodeMatrix,dest=new Float32Array(positions.length)){for(let i=0,len=positions.length;i<len;i+=3){dest[i+0]=positions[i+0]*decodeMatrix[0]+decodeMatrix[12];dest[i+1]=positions[i+1]*decodeMatrix[5]+decodeMatrix[13];dest[i+2]=positions[i+2]*decodeMatrix[10]+decodeMatrix[14]}
return dest},decompressUV(uv,decodeMatrix,dest){dest[0]=uv[0]*decodeMatrix[0]+decodeMatrix[6];dest[1]=uv[1]*decodeMatrix[4]+decodeMatrix[7]},decompressUVs(uvs,decodeMatrix,dest=new Float32Array(uvs.length)){for(let i=0,len=uvs.length;i<len;i+=3){dest[i+0]=uvs[i+0]*decodeMatrix[0]+decodeMatrix[6];dest[i+1]=uvs[i+1]*decodeMatrix[4]+decodeMatrix[7]}
return dest},octDecodeVec2(oct,result){let x=oct[0];let y=oct[1];x=(2*x+1)/255;y=(2*y+1)/255;const z=1-Math.abs(x)-Math.abs(y);if(z<0){x=(1-Math.abs(y))*(x>=0?1:-1);y=(1-Math.abs(x))*(y>=0?1:-1)}
const length=Math.sqrt(x*x+y*y+z*z);result[0]=x/length;result[1]=y/length;result[2]=z/length;return result},octDecodeVec2s(octs,result){for(let i=0,j=0,len=octs.length;i<len;i+=2){let x=octs[i+0];let y=octs[i+1];x=(2*x+1)/255;y=(2*y+1)/255;const z=1-Math.abs(x)-Math.abs(y);if(z<0){x=(1-Math.abs(y))*(x>=0?1:-1);y=(1-Math.abs(x))*(y>=0?1:-1)}
const length=Math.sqrt(x*x+y*y+z*z);result[j+0]=x/length;result[j+1]=y/length;result[j+2]=z/length;j+=3}
return result},AABB3(values){return new Float32Array(values||6)},AABB2(values){return new Float32Array(values||4)},OBB3(values){return new Float32Array(values||32)},OBB2(values){return new Float32Array(values||16)},transformOBB3(m,p,p2=p){let i;const len=p.length;let x;let y;let z;const m0=m[0];const m1=m[1];const m2=m[2];const m3=m[3];const m4=m[4];const m5=m[5];const m6=m[6];const m7=m[7];const m8=m[8];const m9=m[9];const m10=m[10];const m11=m[11];const m12=m[12];const m13=m[13];const m14=m[14];const m15=m[15];for(i=0;i<len;i+=4){x=p[i+0];y=p[i+1];z=p[i+2];p2[i+0]=(m0*x)+(m4*y)+(m8*z)+m12;p2[i+1]=(m1*x)+(m5*y)+(m9*z)+m13;p2[i+2]=(m2*x)+(m6*y)+(m10*z)+m14;p2[i+3]=(m3*x)+(m7*y)+(m11*z)+m15}
return p2},getAABB3Diag:((()=>{const min=new Float32Array(3);const max=new Float32Array(3);const tempVec3=new Float32Array(3);return aabb=>{min[0]=aabb[0];min[1]=aabb[1];min[2]=aabb[2];max[0]=aabb[3];max[1]=aabb[4];max[2]=aabb[5];math.subVec3(max,min,tempVec3);return Math.abs(math.lenVec3(tempVec3))}}))(),getAABB3DiagPoint:((()=>{const min=new Float32Array(3);const max=new Float32Array(3);const tempVec3=new Float32Array(3);return(aabb,p)=>{min[0]=aabb[0];min[1]=aabb[1];min[2]=aabb[2];max[0]=aabb[3];max[1]=aabb[4];max[2]=aabb[5];const diagVec=math.subVec3(max,min,tempVec3);const xneg=p[0]-aabb[0];const xpos=aabb[3]-p[0];const yneg=p[1]-aabb[1];const ypos=aabb[4]-p[1];const zneg=p[2]-aabb[2];const zpos=aabb[5]-p[2];diagVec[0]+=(xneg>xpos)?xneg:xpos;diagVec[1]+=(yneg>ypos)?yneg:ypos;diagVec[2]+=(zneg>zpos)?zneg:zpos;return Math.abs(math.lenVec3(diagVec))}}))(),getAABB3Center(aabb,dest){const r=dest||math.vec3();r[0]=(aabb[0]+aabb[3])/2;r[1]=(aabb[1]+aabb[4])/2;r[2]=(aabb[2]+aabb[5])/2;return r},getAABB2Center(aabb,dest){const r=dest||math.vec2();r[0]=(aabb[2]+aabb[0])/2;r[1]=(aabb[3]+aabb[1])/2;return r},collapseAABB3(aabb=math.AABB3()){aabb[0]=math.MAX_DOUBLE;aabb[1]=math.MAX_DOUBLE;aabb[2]=math.MAX_DOUBLE;aabb[3]=-math.MAX_DOUBLE;aabb[4]=-math.MAX_DOUBLE;aabb[5]=-math.MAX_DOUBLE;return aabb},AABB3ToOBB3(aabb,obb=math.OBB3()){obb[0]=aabb[0];obb[1]=aabb[1];obb[2]=aabb[2];obb[3]=1;obb[4]=aabb[3];obb[5]=aabb[1];obb[6]=aabb[2];obb[7]=1;obb[8]=aabb[3];obb[9]=aabb[4];obb[10]=aabb[2];obb[11]=1;obb[12]=aabb[0];obb[13]=aabb[4];obb[14]=aabb[2];obb[15]=1;obb[16]=aabb[0];obb[17]=aabb[1];obb[18]=aabb[5];obb[19]=1;obb[20]=aabb[3];obb[21]=aabb[1];obb[22]=aabb[5];obb[23]=1;obb[24]=aabb[3];obb[25]=aabb[4];obb[26]=aabb[5];obb[27]=1;obb[28]=aabb[0];obb[29]=aabb[4];obb[30]=aabb[5];obb[31]=1;return obb},positions3ToAABB3:((()=>{const p=new Float32Array(3);return(positions,aabb,positionsDecodeMatrix)=>{aabb=aabb||math.AABB3();let xmin=math.MAX_DOUBLE;let ymin=math.MAX_DOUBLE;let zmin=math.MAX_DOUBLE;let xmax=-math.MAX_DOUBLE;let ymax=-math.MAX_DOUBLE;let zmax=-math.MAX_DOUBLE;let x;let y;let z;for(let i=0,len=positions.length;i<len;i+=3){if(positionsDecodeMatrix){p[0]=positions[i+0];p[1]=positions[i+1];p[2]=positions[i+2];math.decompressPosition(p,positionsDecodeMatrix,p);x=p[0];y=p[1];z=p[2]}else{x=positions[i+0];y=positions[i+1];z=positions[i+2]}
if(x<xmin){xmin=x}
if(y<ymin){ymin=y}
if(z<zmin){zmin=z}
if(x>xmax){xmax=x}
if(y>ymax){ymax=y}
if(z>zmax){zmax=z}}
aabb[0]=xmin;aabb[1]=ymin;aabb[2]=zmin;aabb[3]=xmax;aabb[4]=ymax;aabb[5]=zmax;return aabb}}))(),OBB3ToAABB3(obb,aabb=math.AABB3()){let xmin=math.MAX_DOUBLE;let ymin=math.MAX_DOUBLE;let zmin=math.MAX_DOUBLE;let xmax=-math.MAX_DOUBLE;let ymax=-math.MAX_DOUBLE;let zmax=-math.MAX_DOUBLE;let x;let y;let z;for(let i=0,len=obb.length;i<len;i+=4){x=obb[i+0];y=obb[i+1];z=obb[i+2];if(x<xmin){xmin=x}
if(y<ymin){ymin=y}
if(z<zmin){zmin=z}
if(x>xmax){xmax=x}
if(y>ymax){ymax=y}
if(z>zmax){zmax=z}}
aabb[0]=xmin;aabb[1]=ymin;aabb[2]=zmin;aabb[3]=xmax;aabb[4]=ymax;aabb[5]=zmax;return aabb},points3ToAABB3(points,aabb=math.AABB3()){let xmin=math.MAX_DOUBLE;let ymin=math.MAX_DOUBLE;let zmin=math.MAX_DOUBLE;let xmax=-math.MAX_DOUBLE;let ymax=-math.MAX_DOUBLE;let zmax=-math.MAX_DOUBLE;let x;let y;let z;for(let i=0,len=points.length;i<len;i++){x=points[i][0];y=points[i][1];z=points[i][2];if(x<xmin){xmin=x}
if(y<ymin){ymin=y}
if(z<zmin){zmin=z}
if(x>xmax){xmax=x}
if(y>ymax){ymax=y}
if(z>zmax){zmax=z}}
aabb[0]=xmin;aabb[1]=ymin;aabb[2]=zmin;aabb[3]=xmax;aabb[4]=ymax;aabb[5]=zmax;return aabb},points3ToSphere3:((()=>{const tempVec3=new Float32Array(3);return(points,sphere)=>{sphere=sphere||math.vec4();let x=0;let y=0;let z=0;let i;const numPoints=points.length;for(i=0;i<numPoints;i++){x+=points[i][0];y+=points[i][1];z+=points[i][2]}
sphere[0]=x/numPoints;sphere[1]=y/numPoints;sphere[2]=z/numPoints;let radius=0;let dist;for(i=0;i<numPoints;i++){dist=Math.abs(math.lenVec3(math.subVec3(points[i],sphere,tempVec3)));if(dist>radius){radius=dist}}
sphere[3]=radius;return sphere}}))(),OBB3ToSphere3:((()=>{const point=new Float32Array(3);const tempVec3=new Float32Array(3);return(points,sphere)=>{sphere=sphere||math.vec4();let x=0;let y=0;let z=0;let i;const lenPoints=points.length;const numPoints=lenPoints/4;for(i=0;i<lenPoints;i+=4){x+=points[i+0];y+=points[i+1];z+=points[i+2]}
sphere[0]=x/numPoints;sphere[1]=y/numPoints;sphere[2]=z/numPoints;let radius=0;let dist;for(i=0;i<lenPoints;i+=4){point[0]=points[i+0];point[1]=points[i+1];point[2]=points[i+2];dist=Math.abs(math.lenVec3(math.subVec3(point,sphere,tempVec3)));if(dist>radius){radius=dist}}
sphere[3]=radius;return sphere}}))(),getSphere3Center(sphere,dest=math.vec3()){dest[0]=sphere[0];dest[1]=sphere[1];dest[2]=sphere[2];return dest},expandAABB3(aabb1,aabb2){if(aabb1[0]>aabb2[0]){aabb1[0]=aabb2[0]}
if(aabb1[1]>aabb2[1]){aabb1[1]=aabb2[1]}
if(aabb1[2]>aabb2[2]){aabb1[2]=aabb2[2]}
if(aabb1[3]<aabb2[3]){aabb1[3]=aabb2[3]}
if(aabb1[4]<aabb2[4]){aabb1[4]=aabb2[4]}
if(aabb1[5]<aabb2[5]){aabb1[5]=aabb2[5]}
return aabb1},expandAABB3Point3(aabb,p){if(aabb[0]<p[0]){aabb[0]=p[0]}
if(aabb[1]<p[1]){aabb[1]=p[1]}
if(aabb[2]<p[2]){aabb[2]=p[2]}
if(aabb[3]>p[0]){aabb[3]=p[0]}
if(aabb[4]>p[1]){aabb[4]=p[1]}
if(aabb[5]>p[2]){aabb[5]=p[2]}
return aabb},collapseAABB2(aabb=math.AABB2()){aabb[0]=math.MAX_DOUBLE;aabb[1]=math.MAX_DOUBLE;aabb[2]=-math.MAX_DOUBLE;aabb[3]=-math.MAX_DOUBLE;return aabb},OBB3ToAABB2(points,aabb=math.AABB2()){let xmin=math.MAX_DOUBLE;let ymin=math.MAX_DOUBLE;let xmax=-math.MAX_DOUBLE;let ymax=-math.MAX_DOUBLE;let x;let y;let w;let f;for(let i=0,len=points.length;i<len;i+=4){x=points[i+0];y=points[i+1];w=points[i+3]||1.0;f=1.0/w;x*=f;y*=f;if(x<xmin){xmin=x}
if(y<ymin){ymin=y}
if(x>xmax){xmax=x}
if(y>ymax){ymax=y}}
aabb[0]=xmin;aabb[1]=ymin;aabb[2]=xmax;aabb[3]=ymax;return aabb},expandAABB2(aabb1,aabb2){if(aabb1[0]>aabb2[0]){aabb1[0]=aabb2[0]}
if(aabb1[1]>aabb2[1]){aabb1[1]=aabb2[1]}
if(aabb1[2]<aabb2[2]){aabb1[2]=aabb2[2]}
if(aabb1[3]<aabb2[3]){aabb1[3]=aabb2[3]}
return aabb1},expandAABB2Point2(aabb,p){if(aabb[0]>p[0]){aabb[0]=p[0]}
if(aabb[1]>p[1]){aabb[1]=p[1]}
if(aabb[2]<p[0]){aabb[2]=p[0]}
if(aabb[3]<p[1]){aabb[3]=p[1]}
return aabb},AABB2ToCanvas(aabb,canvasWidth,canvasHeight,aabb2=aabb){const xmin=(aabb[0]+1.0)*0.5;const ymin=(aabb[1]+1.0)*0.5;const xmax=(aabb[2]+1.0)*0.5;const ymax=(aabb[3]+1.0)*0.5;aabb2[0]=Math.floor(xmin*canvasWidth);aabb2[1]=canvasHeight-Math.floor(ymax*canvasHeight);aabb2[2]=Math.floor(xmax*canvasWidth);aabb2[3]=canvasHeight-Math.floor(ymin*canvasHeight);return aabb2},tangentQuadraticBezier(t,p0,p1,p2){return 2*(1-t)*(p1-p0)+2*t*(p2-p1)},tangentQuadraticBezier3(t,p0,p1,p2,p3){return-3*p0*(1-t)*(1-t)+3*p1*(1-t)*(1-t)-6*t*p1*(1-t)+6*t*p2*(1-t)-3*t*t*p2+3*t*t*p3},tangentSpline(t){const h00=6*t*t-6*t;const h10=3*t*t-4*t+1;const h01=-6*t*t+6*t;const h11=3*t*t-2*t;return h00+h10+h01+h11},catmullRomInterpolate(p0,p1,p2,p3,t){const v0=(p2-p0)*0.5;const v1=(p3-p1)*0.5;const t2=t*t;const t3=t*t2;return(2*p1-2*p2+v0+v1)*t3+(-3*p1+3*p2-2*v0-v1)*t2+v0*t+p1},b2p0(t,p){const k=1-t;return k*k*p},b2p1(t,p){return 2*(1-t)*t*p},b2p2(t,p){return t*t*p},b2(t,p0,p1,p2){return this.b2p0(t,p0)+this.b2p1(t,p1)+this.b2p2(t,p2)},b3p0(t,p){const k=1-t;return k*k*k*p},b3p1(t,p){const k=1-t;return 3*k*k*t*p},b3p2(t,p){const k=1-t;return 3*k*t*t*p},b3p3(t,p){return t*t*t*p},b3(t,p0,p1,p2,p3){return this.b3p0(t,p0)+this.b3p1(t,p1)+this.b3p2(t,p2)+this.b3p3(t,p3)},triangleNormal(a,b,c,normal=math.vec3()){const p1x=b[0]-a[0];const p1y=b[1]-a[1];const p1z=b[2]-a[2];const p2x=c[0]-a[0];const p2y=c[1]-a[1];const p2z=c[2]-a[2];const p3x=p1y*p2z-p1z*p2y;const p3y=p1z*p2x-p1x*p2z;const p3z=p1x*p2y-p1y*p2x;const mag=Math.sqrt(p3x*p3x+p3y*p3y+p3z*p3z);if(mag===0){normal[0]=0;normal[1]=0;normal[2]=0}else{normal[0]=p3x/mag;normal[1]=p3y/mag;normal[2]=p3z/mag}
return normal},rayTriangleIntersect:((()=>{const tempVec3=new Float32Array(3);const tempVec3b=new Float32Array(3);const tempVec3c=new Float32Array(3);const tempVec3d=new Float32Array(3);const tempVec3e=new Float32Array(3);return(origin,dir,a,b,c,isect)=>{isect=isect||math.vec3();const EPSILON=0.000001;const edge1=math.subVec3(b,a,tempVec3);const edge2=math.subVec3(c,a,tempVec3b);const pvec=math.cross3Vec3(dir,edge2,tempVec3c);const det=math.dotVec3(edge1,pvec);if(det<EPSILON){return null}
const tvec=math.subVec3(origin,a,tempVec3d);const u=math.dotVec3(tvec,pvec);if(u<0||u>det){return null}
const qvec=math.cross3Vec3(tvec,edge1,tempVec3e);const v=math.dotVec3(dir,qvec);if(v<0||u+v>det){return null}
const t=math.dotVec3(edge2,qvec)/det;isect[0]=origin[0]+t*dir[0];isect[1]=origin[1]+t*dir[1];isect[2]=origin[2]+t*dir[2];return isect}}))(),rayPlaneIntersect:((()=>{const tempVec3=new Float32Array(3);const tempVec3b=new Float32Array(3);const tempVec3c=new Float32Array(3);const tempVec3d=new Float32Array(3);return(origin,dir,a,b,c,isect)=>{isect=isect||math.vec3();dir=math.normalizeVec3(dir,tempVec3);const edge1=math.subVec3(b,a,tempVec3b);const edge2=math.subVec3(c,a,tempVec3c);const n=math.cross3Vec3(edge1,edge2,tempVec3d);math.normalizeVec3(n,n);const d=-math.dotVec3(a,n);const t=-(math.dotVec3(origin,n)+d)/math.dotVec3(dir,n);isect[0]=origin[0]+t*dir[0];isect[1]=origin[1]+t*dir[1];isect[2]=origin[2]+t*dir[2];return isect}}))(),cartesianToBarycentric:((()=>{const tempVec3=new Float32Array(3);const tempVec3b=new Float32Array(3);const tempVec3c=new Float32Array(3);return(cartesian,a,b,c,dest)=>{const v0=math.subVec3(c,a,tempVec3);const v1=math.subVec3(b,a,tempVec3b);const v2=math.subVec3(cartesian,a,tempVec3c);const dot00=math.dotVec3(v0,v0);const dot01=math.dotVec3(v0,v1);const dot02=math.dotVec3(v0,v2);const dot11=math.dotVec3(v1,v1);const dot12=math.dotVec3(v1,v2);const denom=(dot00*dot11-dot01*dot01);if(denom===0){return null}
const invDenom=1/denom;const u=(dot11*dot02-dot01*dot12)*invDenom;const v=(dot00*dot12-dot01*dot02)*invDenom;dest[0]=1-u-v;dest[1]=v;dest[2]=u;return dest}}))(),barycentricInsideTriangle(bary){const v=bary[1];const u=bary[2];return(u>=0)&&(v>=0)&&(u+v<1)},barycentricToCartesian(bary,a,b,c,cartesian=math.vec3()){const u=bary[0];const v=bary[1];const w=bary[2];cartesian[0]=a[0]*u+b[0]*v+c[0]*w;cartesian[1]=a[1]*u+b[1]*v+c[1]*w;cartesian[2]=a[2]*u+b[2]*v+c[2]*w;return cartesian},mergeVertices(positions,normals,uv,indices){const positionsMap={};const indicesLookup=[];const uniquePositions=[];const uniqueNormals=normals?[]:null;const uniqueUV=uv?[]:null;const indices2=[];let vx;let vy;let vz;let key;const precisionPoints=4;const precision=10**precisionPoints;let i;let len;let uvi=0;for(i=0,len=positions.length;i<len;i+=3){vx=positions[i];vy=positions[i+1];vz=positions[i+2];key=`${Math.round(vx * precision)}_${Math.round(vy * precision)}_${Math.round(vz * precision)}`;if(positionsMap[key]===undefined){positionsMap[key]=uniquePositions.length/3;uniquePositions.push(vx);uniquePositions.push(vy);uniquePositions.push(vz);if(normals){uniqueNormals.push(normals[i]);uniqueNormals.push(normals[i+1]);uniqueNormals.push(normals[i+2])}
if(uv){uniqueUV.push(uv[uvi]);uniqueUV.push(uv[uvi+1])}}
indicesLookup[i/3]=positionsMap[key];uvi+=2}
for(i=0,len=indices.length;i<len;i++){indices2[i]=indicesLookup[indices[i]]}
const result={positions:uniquePositions,indices:indices2};if(uniqueNormals){result.normals=uniqueNormals}
if(uniqueUV){result.uv=uniqueUV}
return result},buildNormals:((()=>{const a=new Float32Array(3);const b=new Float32Array(3);const c=new Float32Array(3);const ab=new Float32Array(3);const ac=new Float32Array(3);const crossVec=new Float32Array(3);return(positions,indices,normals)=>{let i;let len;const nvecs=new Array(positions.length/3);let j0;let j1;let j2;for(i=0,len=indices.length;i<len;i+=3){j0=indices[i];j1=indices[i+1];j2=indices[i+2];a[0]=positions[j0*3];a[1]=positions[j0*3+1];a[2]=positions[j0*3+2];b[0]=positions[j1*3];b[1]=positions[j1*3+1];b[2]=positions[j1*3+2];c[0]=positions[j2*3];c[1]=positions[j2*3+1];c[2]=positions[j2*3+2];math.subVec3(b,a,ab);math.subVec3(c,a,ac);const normVec=new Float32Array(3);math.normalizeVec3(math.cross3Vec3(ab,ac,crossVec),normVec);if(!nvecs[j0]){nvecs[j0]=[]}
if(!nvecs[j1]){nvecs[j1]=[]}
if(!nvecs[j2]){nvecs[j2]=[]}
nvecs[j0].push(normVec);nvecs[j1].push(normVec);nvecs[j2].push(normVec)}
normals=(normals&&normals.length===positions.length)?normals:new Float32Array(positions.length);let count;let x;let y;let z;for(i=0,len=nvecs.length;i<len;i++){count=nvecs[i].length;x=0;y=0;z=0;for(let j=0;j<count;j++){x+=nvecs[i][j][0];y+=nvecs[i][j][1];z+=nvecs[i][j][2]}
normals[i*3]=(x/count);normals[i*3+1]=(y/count);normals[i*3+2]=(z/count)}
return normals}}))(),buildTangents:((()=>{const tempVec3=new Float32Array(3);const tempVec3b=new Float32Array(3);const tempVec3c=new Float32Array(3);const tempVec3d=new Float32Array(3);const tempVec3e=new Float32Array(3);const tempVec3f=new Float32Array(3);const tempVec3g=new Float32Array(3);return(positions,indices,uv)=>{const tangents=new Float32Array(positions.length);for(let location=0;location<indices.length;location+=3){let index=indices[location];const v0=positions.subarray(index*3,index*3+3);const uv0=uv.subarray(index*2,index*2+2);index=indices[location+1];const v1=positions.subarray(index*3,index*3+3);const uv1=uv.subarray(index*2,index*2+2);index=indices[location+2];const v2=positions.subarray(index*3,index*3+3);const uv2=uv.subarray(index*2,index*2+2);const deltaPos1=math.subVec3(v1,v0,tempVec3);const deltaPos2=math.subVec3(v2,v0,tempVec3b);const deltaUV1=math.subVec2(uv1,uv0,tempVec3c);const deltaUV2=math.subVec2(uv2,uv0,tempVec3d);const r=1/((deltaUV1[0]*deltaUV2[1])-(deltaUV1[1]*deltaUV2[0]));const tangent=math.mulVec3Scalar(math.subVec3(math.mulVec3Scalar(deltaPos1,deltaUV2[1],tempVec3e),math.mulVec3Scalar(deltaPos2,deltaUV1[1],tempVec3f),tempVec3g),r,tempVec3f);let addTo;for(let v=0;v<3;v++){addTo=indices[location+v]*3;tangents[addTo]+=tangent[0];tangents[addTo+1]+=tangent[1];tangents[addTo+2]+=tangent[2]}}
return tangents}}))(),buildPickTriangles(positions,indices,quantized){const numIndices=indices.length;const pickPositions=quantized?new Uint16Array(numIndices*9):new Float32Array(numIndices*9);const pickColors=new Uint8Array(numIndices*12);let primIndex=0;let vi;let pvi=0;let pci=0;let i;let r;let g;let b;let a;for(let location=0;location<numIndices;location+=3){a=(primIndex>>24&0xFF);b=(primIndex>>16&0xFF);g=(primIndex>>8&0xFF);r=(primIndex&0xFF);i=indices[location];vi=i*3;pickPositions[pvi++]=positions[vi];pickPositions[pvi++]=positions[vi+1];pickPositions[pvi++]=positions[vi+2];pickColors[pci++]=r;pickColors[pci++]=g;pickColors[pci++]=b;pickColors[pci++]=a;i=indices[location+1];vi=i*3;pickPositions[pvi++]=positions[vi];pickPositions[pvi++]=positions[vi+1];pickPositions[pvi++]=positions[vi+2];pickColors[pci++]=r;pickColors[pci++]=g;pickColors[pci++]=b;pickColors[pci++]=a;i=indices[location+2];vi=i*3;pickPositions[pvi++]=positions[vi];pickPositions[pvi++]=positions[vi+1];pickPositions[pvi++]=positions[vi+2];pickColors[pci++]=r;pickColors[pci++]=g;pickColors[pci++]=b;pickColors[pci++]=a;primIndex++}
return{positions:pickPositions,colors:pickColors}},faceToVertexNormals(positions,normals,options={}){const smoothNormalsAngleThreshold=options.smoothNormalsAngleThreshold||20;const vertexMap={};const vertexNormals=[];const vertexNormalAccum={};let acc;let vx;let vy;let vz;let key;const precisionPoints=4;const precision=10**precisionPoints;let posi;let i;let j;let len;let a;let b;for(i=0,len=positions.length;i<len;i+=3){posi=i/3;vx=positions[i];vy=positions[i+1];vz=positions[i+2];key=`${Math.round(vx * precision)}_${Math.round(vy * precision)}_${Math.round(vz * precision)}`;if(vertexMap[key]===undefined){vertexMap[key]=[posi]}else{vertexMap[key].push(posi)}
const normal=math.normalizeVec3([normals[i],normals[i+1],normals[i+2]]);vertexNormals[posi]=normal;acc=math.vec4([normal[0],normal[1],normal[2],1]);vertexNormalAccum[posi]=acc}
for(key in vertexMap){if(vertexMap.hasOwnProperty(key)){const vertices=vertexMap[key];const numVerts=vertices.length;for(i=0;i<numVerts;i++){const ii=vertices[i];acc=vertexNormalAccum[ii];for(j=0;j<numVerts;j++){if(i===j){continue}
const jj=vertices[j];a=vertexNormals[ii];b=vertexNormals[jj];const angle=Math.abs(math.angleVec3(a,b)/math.DEGTORAD);if(angle<smoothNormalsAngleThreshold){acc[0]+=b[0];acc[1]+=b[1];acc[2]+=b[2];acc[3]+=1.0}}}}}
for(i=0,len=normals.length;i<len;i+=3){acc=vertexNormalAccum[i/3];normals[i+0]=acc[0]/acc[3];normals[i+1]=acc[1]/acc[3];normals[i+2]=acc[2]/acc[3]}},canvasPosToWorldRay:((()=>{const tempMat4b=new Float32Array(16);const tempMat4c=new Float32Array(16);const tempVec4a=new Float32Array(4);const tempVec4b=new Float32Array(4);const tempVec4c=new Float32Array(4);const tempVec4d=new Float32Array(4);return(camera,canvasPos,worldRayOrigin,worldRayDir)=>{const canvas=camera.scene.canvas.canvas;const viewMat=camera.viewMatrix;const projMat=camera.projection==="ortho"?camera.ortho.matrix:camera.perspective.matrix;const pvMat=math.mulMat4(projMat,viewMat,tempMat4b);const pvMatInverse=math.inverseMat4(pvMat,tempMat4c);const canvasWidth=canvas.width;const canvasHeight=canvas.height;const clipX=(canvasPos[0]-canvasWidth/2)/(canvasWidth/2);const clipY=-(canvasPos[1]-canvasHeight/2)/(canvasHeight/2);tempVec4a[0]=clipX;tempVec4a[1]=clipY;tempVec4a[2]=-1;tempVec4a[3]=1;math.transformVec4(pvMatInverse,tempVec4a,tempVec4b);math.mulVec4Scalar(tempVec4b,1/tempVec4b[3]);tempVec4c[0]=clipX;tempVec4c[1]=clipY;tempVec4c[2]=1;tempVec4c[3]=1;math.transformVec4(pvMatInverse,tempVec4c,tempVec4d);math.mulVec4Scalar(tempVec4d,1/tempVec4d[3]);worldRayOrigin[0]=tempVec4d[0];worldRayOrigin[1]=tempVec4d[1];worldRayOrigin[2]=tempVec4d[2];math.subVec3(tempVec4d,tempVec4b,worldRayDir);math.normalizeVec3(worldRayDir)}}))(),canvasPosToLocalRay:((()=>{const worldRayOrigin=new Float32Array(3);const worldRayDir=new Float32Array(3);return(camera,mesh,canvasPos,localRayOrigin,localRayDir)=>{math.canvasPosToWorldRay(camera,canvasPos,worldRayOrigin,worldRayDir);math.worldRayToLocalRay(mesh,worldRayOrigin,worldRayDir,localRayOrigin,localRayDir)}}))(),worldRayToLocalRay:((()=>{const tempMat4=new Float32Array(16);const tempVec4a=new Float32Array(4);const tempVec4b=new Float32Array(4);return(mesh,worldRayOrigin,worldRayDir,localRayOrigin,localRayDir)=>{const modelMat=mesh.worldMatrix||mesh.matrix;const modelMatInverse=math.inverseMat4(modelMat,tempMat4);tempVec4a[0]=worldRayOrigin[0];tempVec4a[1]=worldRayOrigin[1];tempVec4a[2]=worldRayOrigin[2];tempVec4a[3]=1;math.transformVec4(modelMatInverse,tempVec4a,tempVec4b);localRayOrigin[0]=tempVec4b[0];localRayOrigin[1]=tempVec4b[1];localRayOrigin[2]=tempVec4b[2];math.transformVec3(modelMatInverse,worldRayDir,localRayDir)}}))(),buildKDTree:((()=>{const KD_TREE_MAX_DEPTH=10;const KD_TREE_MIN_TRIANGLES=20;const dimLength=new Float32Array();function buildNode(triangles,indices,positions,depth){const aabb=new Float32Array(6);const node={triangles:null,left:null,right:null,leaf:!1,splitDim:0,aabb};aabb[0]=aabb[1]=aabb[2]=Number.POSITIVE_INFINITY;aabb[3]=aabb[4]=aabb[5]=Number.NEGATIVE_INFINITY;let t;let len;for(t=0,len=triangles.length;t<len;++t){var ii=triangles[t]*3;for(let j=0;j<3;++j){const pi=indices[ii+j]*3;if(positions[pi]<aabb[0]){aabb[0]=positions[pi]}
if(positions[pi]>aabb[3]){aabb[3]=positions[pi]}
if(positions[pi+1]<aabb[1]){aabb[1]=positions[pi+1]}
if(positions[pi+1]>aabb[4]){aabb[4]=positions[pi+1]}
if(positions[pi+2]<aabb[2]){aabb[2]=positions[pi+2]}
if(positions[pi+2]>aabb[5]){aabb[5]=positions[pi+2]}}}
if(triangles.length<KD_TREE_MIN_TRIANGLES||depth>KD_TREE_MAX_DEPTH){node.triangles=triangles;node.leaf=!0;return node}
dimLength[0]=aabb[3]-aabb[0];dimLength[1]=aabb[4]-aabb[1];dimLength[2]=aabb[5]-aabb[2];let dim=0;if(dimLength[1]>dimLength[dim]){dim=1}
if(dimLength[2]>dimLength[dim]){dim=2}
node.splitDim=dim;const mid=(aabb[dim]+aabb[dim+3])/2;const left=new Array(triangles.length);let numLeft=0;const right=new Array(triangles.length);let numRight=0;for(t=0,len=triangles.length;t<len;++t){var ii=triangles[t]*3;const i0=indices[ii];const i1=indices[ii+1];const i2=indices[ii+2];const pi0=i0*3;const pi1=i1*3;const pi2=i2*3;if(positions[pi0+dim]<=mid||positions[pi1+dim]<=mid||positions[pi2+dim]<=mid){left[numLeft++]=triangles[t]}else{right[numRight++]=triangles[t]}}
left.length=numLeft;right.length=numRight;node.left=buildNode(left,indices,positions,depth+1);node.right=buildNode(right,indices,positions,depth+1);return node}
return(indices,positions)=>{const numTris=indices.length/3;const triangles=new Array(numTris);for(let i=0;i<numTris;++i){triangles[i]=i}
return buildNode(triangles,indices,positions,0)}}))()};class Queue{constructor(){this._head=[];this._headLength=0;this._tail=[];this._index=0;this._length=0}
get length(){return this._length}
shift(){if(this._index>=this._headLength){const t=this._head;t.length=0;this._head=this._tail;this._tail=t;this._index=0;this._headLength=this._head.length;if(!this._headLength){return}}
const value=this._head[this._index];if(this._index<0){delete this._head[this._index++]}
else{this._head[this._index++]=undefined}
this._length--;return value}
push(item){this._length++;this._tail.push(item);return this};unshift(item){this._head[--this._index]=item;this._length++;return this}}
const taskQueue=new Queue();const tasks={scheduleTask(callback,scope){taskQueue.push(callback);taskQueue.push(scope)},runTasks(until){let time=(new Date()).getTime();let callback;let scope;let tasksRun=0;while(taskQueue.length>0&&time<until){callback=taskQueue.shift();scope=taskQueue.shift();if(scope){callback.call(scope)}else{callback()}
time=(new Date()).getTime();tasksRun++}
return tasksRun},getNumTasks(){return taskQueue.length}};const componentClasses={};const type="xeogl.Component";class Component{get type(){return type}
constructor(){var cfg={};var arg1=arguments[0];var arg2=arguments[1];var owner=null;this.scene=null;if(this.type==="xeogl.Scene"){this.scene=this;if(arg1){cfg=arg1}}else{if(arg1){if(arg1.type==="xeogl.Scene"){this.scene=arg1;owner=this.scene;if(arg2){cfg=arg2}}else if(arg1 instanceof Component){this.scene=arg1.scene;owner=arg1;if(arg2){cfg=arg2}}else{this.scene=core.getDefaultScene();owner=this.scene;cfg=arg1}}else{this.scene=core.getDefaultScene();owner=this.scene}
this._renderer=this.scene._renderer}
this._dontClear=!!cfg.dontClear;this._model=null;this._renderer=this.scene._renderer;this.meta=cfg.meta||{};this.id=cfg.id;this.destroyed=!1;this._attached={};this._attachments=null;this._subIdMap=null;this._subIdEvents=null;this._eventSubs=null;this._events=null;this._eventCallDepth=0;this._adoptees=null;if(this!==this.scene){this.scene._addComponent(this)}
this._updateScheduled=!1;this.init(cfg);if(owner){owner._adopt(this)}}
init(){}
_addedToModel(model){this._model=model}
_removedFromModel(model){this._model=null}
get model(){return this._model}
isType(type){if(!utils.isString(type)){type=type.type;if(!type){return!1}}
return core.isComponentType(this.type,type)}
fire(event,value,forget){if(!this._events){this._events={}}
if(!this._eventSubs){this._eventSubs={}}
if(forget!==!0){this._events[event]=value||!0}
const subs=this._eventSubs[event];let sub;if(subs){for(const subId in subs){if(subs.hasOwnProperty(subId)){sub=subs[subId];this._eventCallDepth++;if(this._eventCallDepth<300){sub.callback.call(sub.scope,value)}else{this.error("fire: potential stack overflow from recursive event '"+event+"' - dropping this event")}
this._eventCallDepth--}}}}
on(event,callback,scope){if(!this._events){this._events={}}
if(!this._subIdMap){this._subIdMap=new Map()}
if(!this._subIdEvents){this._subIdEvents={}}
if(!this._eventSubs){this._eventSubs={}}
let subs=this._eventSubs[event];if(!subs){subs={};this._eventSubs[event]=subs}
const subId=this._subIdMap.addItem();subs[subId]={callback:callback,scope:scope||this};this._subIdEvents[subId]=event;const value=this._events[event];if(value!==undefined){callback.call(scope||this,value)}
return subId}
off(subId){if(subId===undefined||subId===null){return}
if(!this._subIdEvents){return}
const event=this._subIdEvents[subId];if(event){delete this._subIdEvents[subId];const subs=this._eventSubs[event];if(subs){delete subs[subId]}
this._subIdMap.removeItem(subId)}}
once(event,callback,scope){const self=this;const subId=this.on(event,function(value){self.off(subId);callback(value)},scope)}
hasSubs(event){return(this._eventSubs&&!!this._eventSubs[event])}
log(message){message="[LOG]"+this._message(message);window.console.log(message);this.scene.fire("log",message)}
_message(message){return" ["+this.type+" "+utils.inQuotes(this.id)+"]: "+message}
warn(message){message="[WARN]"+this._message(message);window.console.warn(message);this.scene.fire("warn",message)}
error(message){message="[ERROR]"+this._message(message);window.console.error(message);this.scene.fire("error",message)}
_attach(params){const name=params.name;if(!name){this.error("Component 'name' expected");return}
let component=params.component;const sceneDefault=params.sceneDefault;const sceneSingleton=params.sceneSingleton;const type=params.type;const on=params.on;const recompiles=params.recompiles!==!1;let managingLifecycle=!1;if(component){if(utils.isNumeric(component)||utils.isString(component)){const id=component;component=this.scene.components[id];if(!component){this.error("Component not found: "+utils.inQuotes(id));return}}else if(utils.isObject(component)){const componentCfg=component;const componentType=componentCfg.type||type||"xeogl.Component";const componentClass=componentClasses[componentType];if(!componentClass){this.error("Component type not found: "+componentType);return}
if(type){if(!core.isComponentType(componentType,type)){this.error("Expected a "+type+" type or subtype, not a "+componentType);return}}
component=new componentClass(this.scene,componentCfg);managingLifecycle=!0}}
if(!component){if(sceneSingleton===!0){const instances=this.scene.types[type];for(const id2 in instances){if(instances.hasOwnProperty){component=instances[id2];break}}
if(!component){this.error("Scene has no default component for '"+name+"'");return null}}else if(sceneDefault===!0){component=this.scene[name];if(!component){this.error("Scene has no default component for '"+name+"'");return null}}}
if(component){if(component.scene.id!==this.scene.id){this.error("Not in same scene: "+component.type+" "+utils.inQuotes(component.id));return}
if(type){if(!component.isType(type)){this.error("Expected a "+type+" type or subtype: "+component.type+" "+utils.inQuotes(component.id));return}}}
if(!this._attachments){this._attachments={}}
const oldComponent=this._attached[name];let subs;let i;let len;if(oldComponent){if(component&&oldComponent.id===component.id){return}
const oldAttachment=this._attachments[oldComponent.id];subs=oldAttachment.subs;for(i=0,len=subs.length;i<len;i++){oldComponent.off(subs[i])}
delete this._attached[name];delete this._attachments[oldComponent.id];const onDetached=oldAttachment.params.onDetached;if(onDetached){if(utils.isFunction(onDetached)){onDetached(oldComponent)}else{onDetached.scope?onDetached.callback.call(onDetached.scope,oldComponent):onDetached.callback(oldComponent)}}
if(oldAttachment.managingLifecycle){oldComponent.destroy()}}
if(component){const attachment={params:params,component:component,subs:[],managingLifecycle:managingLifecycle};attachment.subs.push(component.on("destroyed",function(){attachment.params.component=null;this._attach(attachment.params)},this));if(recompiles){attachment.subs.push(component.on("dirty",function(){this.fire("dirty",this)},this))}
this._attached[name]=component;this._attachments[component.id]=attachment;const onAttached=params.onAttached;if(onAttached){if(utils.isFunction(onAttached)){onAttached(component)}else{onAttached.scope?onAttached.callback.call(onAttached.scope,component):onAttached.callback(component)}}
if(on){let event;let subIdr;let callback;let scope;for(event in on){if(on.hasOwnProperty(event)){subIdr=on[event];if(utils.isFunction(subIdr)){callback=subIdr;scope=null}else{callback=subIdr.callback;scope=subIdr.scope}
if(!callback){continue}
attachment.subs.push(component.on(event,callback,scope))}}}}
if(recompiles){this.fire("dirty",this)}
this.fire(name,component);return component}
_checkComponent(expectedType,component){if(utils.isObject(component)){if(component.type){if(!core.isComponentType(component.type,expectedType)){this.error("Expected a "+expectedType+" type or subtype: "+component.type+" "+utils.inQuotes(component.id));return}}else{component.type=expectedType}
component=new componentClasses[component.type](this.scene,component)}else{if(utils.isID(component)){const id=component;component=this.scene.components[id];if(!component){this.error("Component not found: "+utils.inQuotes(component.id));return}}}
if(component.scene.id!==this.scene.id){this.error("Not in same scene: "+component.type+" "+utils.inQuotes(component.id));return}
if(!component.isType(expectedType)){this.error("Expected a "+expectedType+" type or subtype: "+component.type+" "+utils.inQuotes(component.id));return}
return component}
create(cfg){let type;let claz;if(utils.isObject(cfg)){type=cfg.type||"xeogl.Component";claz=componentClasses[type]}else if(utils.isString(cfg)){type=cfg;claz=componentClasses[type]}else{claz=cfg;type=cfg.prototype.type}
if(!claz){this.error("Component type not found: "+type);return}
if(!core.isComponentType(type,"xeogl.Component")){this.error("Expected a xeogl.Component type or subtype");return}
if(cfg&&cfg.id&&this.components[cfg.id]){this.error("Component "+utils.inQuotes(cfg.id)+" already exists in Scene - ignoring ID, will randomly-generate instead");cfg.id=undefined}
const component=new claz(this,cfg);if(component){this._adopt(component)}
return component}
_adopt(component){if(!this._adoptees){this._adoptees={}}
if(!this._adoptees[component.id]){this._adoptees[component.id]=component}
component.on("destroyed",function(){delete this._adoptees[component.id]},this)}
_needUpdate(priority){if(!this._updateScheduled){this._updateScheduled=!0;if(priority===0){this._doUpdate()}else{tasks.scheduleTask(this._doUpdate,this)}}}
_doUpdate(){if(this._updateScheduled){this._updateScheduled=!1;if(this._update){this._update()}}}
_update(){}
destroy(){if(this.destroyed){return}
let id;let attachment;let component;let subs;let i;let len;if(this._attachments){for(id in this._attachments){if(this._attachments.hasOwnProperty(id)){attachment=this._attachments[id];component=attachment.component;subs=attachment.subs;for(i=0,len=subs.length;i<len;i++){component.off(subs[i])}
if(attachment.managingLifecycle){component.destroy()}}}}
if(this._adoptees){const ids=Object.keys(this._adoptees);for(i=0,len=ids.length;i<len;i++){component=this._adoptees[ids[i]];component.destroy()}}
this.scene._removeComponent(this);this._attached={};this._attachments=null;this._subIdMap=null;this._subIdEvents=null;this._eventSubs=null;this._events=null;this._eventCallDepth=0;this._adoptees=null;this._updateScheduled=!1;this.fire("destroyed",this.destroyed=!0)}}
componentClasses[type]=Component;const Canvas2Image=(function(){const oCanvas=document.createElement("canvas"),sc=String.fromCharCode,strDownloadMime="image/octet-stream",bReplaceDownloadMime=!1;if(!oCanvas.getContext){return{saveAsBMP:function(){},saveAsPNG:function(){},saveAsJPEG:function(){}}}
const bHasImageData=!!(oCanvas.getContext("2d").getImageData),bHasDataURL=!!(oCanvas.toDataURL),bHasBase64=!!(window.btoa);const readCanvasData=function(oCanvas){const iWidth=parseInt(oCanvas.width),iHeight=parseInt(oCanvas.height);return oCanvas.getContext("2d").getImageData(0,0,iWidth,iHeight)};const encodeData=function(data){let i,aData,strData="";if(typeof data=="string"){strData=data}else{aData=data;for(i=0;i<aData.length;i++){strData+=sc(aData[i])}}
return btoa(strData)};const createBMP=function(oData){let strHeader='';const iWidth=oData.width;const iHeight=oData.height;strHeader+='BM';let iFileSize=iWidth*iHeight*4+54;strHeader+=sc(iFileSize%256);iFileSize=Math.floor(iFileSize/256);strHeader+=sc(iFileSize%256);iFileSize=Math.floor(iFileSize/256);strHeader+=sc(iFileSize%256);iFileSize=Math.floor(iFileSize/256);strHeader+=sc(iFileSize%256);strHeader+=sc(0,0,0,0,54,0,0,0);strHeader+=sc(40,0,0,0);let iImageWidth=iWidth;strHeader+=sc(iImageWidth%256);iImageWidth=Math.floor(iImageWidth/256);strHeader+=sc(iImageWidth%256);iImageWidth=Math.floor(iImageWidth/256);strHeader+=sc(iImageWidth%256);iImageWidth=Math.floor(iImageWidth/256);strHeader+=sc(iImageWidth%256);let iImageHeight=iHeight;strHeader+=sc(iImageHeight%256);iImageHeight=Math.floor(iImageHeight/256);strHeader+=sc(iImageHeight%256);iImageHeight=Math.floor(iImageHeight/256);strHeader+=sc(iImageHeight%256);iImageHeight=Math.floor(iImageHeight/256);strHeader+=sc(iImageHeight%256);strHeader+=sc(1,0,32,0);strHeader+=sc(0,0,0,0);let iDataSize=iWidth*iHeight*4;strHeader+=sc(iDataSize%256);iDataSize=Math.floor(iDataSize/256);strHeader+=sc(iDataSize%256);iDataSize=Math.floor(iDataSize/256);strHeader+=sc(iDataSize%256);iDataSize=Math.floor(iDataSize/256);strHeader+=sc(iDataSize%256);strHeader+=sc(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const aImgData=oData.data;let strPixelData="";let x;let y=iHeight;let iOffsetX;let iOffsetY;let strPixelRow;do{iOffsetY=iWidth*(y-1)*4;strPixelRow="";for(x=0;x<iWidth;x++){iOffsetX=4*x;strPixelRow+=sc(aImgData[iOffsetY+iOffsetX+2],aImgData[iOffsetY+iOffsetX+1],aImgData[iOffsetY+iOffsetX],aImgData[iOffsetY+iOffsetX+3])}
strPixelData+=strPixelRow}while(--y);return encodeData(strHeader+strPixelData)};const saveFile=function(strData){if(!window.open(strData)){document.location.href=strData}};const makeDataURI=function(strData,strMime){return"data:"+strMime+";base64,"+strData};const makeImageObject=function(strSource){const oImgElement=document.createElement("img");oImgElement.src=strSource;return oImgElement};const scaleCanvas=function(oCanvas,iWidth,iHeight){if(iWidth&&iHeight){const oSaveCanvas=document.createElement("canvas");oSaveCanvas.width=iWidth;oSaveCanvas.height=iHeight;oSaveCanvas.style.width=iWidth+"px";oSaveCanvas.style.height=iHeight+"px";const oSaveCtx=oSaveCanvas.getContext("2d");oSaveCtx.drawImage(oCanvas,0,0,oCanvas.width,oCanvas.height,0,0,iWidth,iWidth);return oSaveCanvas}
return oCanvas};return{saveAsPNG:function(oCanvas,bReturnImg,iWidth,iHeight){if(!bHasDataURL)return!1;const oScaledCanvas=scaleCanvas(oCanvas,iWidth,iHeight),strMime="image/png",strData=oScaledCanvas.toDataURL(strMime);if(bReturnImg){return makeImageObject(strData)}else{saveFile(bReplaceDownloadMime?strData.replace(strMime,strDownloadMime):strData)}
return!0},saveAsJPEG:function(oCanvas,bReturnImg,iWidth,iHeight){if(!bHasDataURL)return!1;const oScaledCanvas=scaleCanvas(oCanvas,iWidth,iHeight),strMime="image/jpeg",strData=oScaledCanvas.toDataURL(strMime);if(strData.indexOf(strMime)!=5)return!1;if(bReturnImg){return makeImageObject(strData)}else{saveFile(bReplaceDownloadMime?strData.replace(strMime,strDownloadMime):strData)}
return!0},saveAsBMP:function(oCanvas,bReturnImg,iWidth,iHeight){if(!(bHasDataURL&&bHasImageData&&bHasBase64))return!1;const oScaledCanvas=scaleCanvas(oCanvas,iWidth,iHeight),strMime="image/bmp",oData=readCanvasData(oScaledCanvas),strImgData=createBMP(oData);if(bReturnImg){return makeImageObject(makeDataURI(strImgData,strMime))}else{saveFile(makeDataURI(strImgData,strMime))}
return!0}}})();const type$1="xeogl.Spinner";let spinnerCSSInjected=!1;const spinnerCSS=".sk-fading-circle {\
        background: transparent;\
        margin: 20px auto;\
        width: 50px;\
        height:50px;\
        position: relative;\
        }\
        .sk-fading-circle .sk-circle {\
        width: 120%;\
        height: 120%;\
        position: absolute;\
        left: 0;\
        top: 0;\
        }\
        .sk-fading-circle .sk-circle:before {\
        content: '';\
        display: block;\
        margin: 0 auto;\
        width: 15%;\
        height: 15%;\
        background-color: #ff8800;\
        border-radius: 100%;\
        -webkit-animation: sk-circleFadeDelay 1.2s infinite ease-in-out both;\
        animation: sk-circleFadeDelay 1.2s infinite ease-in-out both;\
        }\
        .sk-fading-circle .sk-circle2 {\
        -webkit-transform: rotate(30deg);\
        -ms-transform: rotate(30deg);\
        transform: rotate(30deg);\
    }\
    .sk-fading-circle .sk-circle3 {\
        -webkit-transform: rotate(60deg);\
        -ms-transform: rotate(60deg);\
        transform: rotate(60deg);\
    }\
    .sk-fading-circle .sk-circle4 {\
        -webkit-transform: rotate(90deg);\
        -ms-transform: rotate(90deg);\
        transform: rotate(90deg);\
    }\
    .sk-fading-circle .sk-circle5 {\
        -webkit-transform: rotate(120deg);\
        -ms-transform: rotate(120deg);\
        transform: rotate(120deg);\
    }\
    .sk-fading-circle .sk-circle6 {\
        -webkit-transform: rotate(150deg);\
        -ms-transform: rotate(150deg);\
        transform: rotate(150deg);\
    }\
    .sk-fading-circle .sk-circle7 {\
        -webkit-transform: rotate(180deg);\
        -ms-transform: rotate(180deg);\
        transform: rotate(180deg);\
    }\
    .sk-fading-circle .sk-circle8 {\
        -webkit-transform: rotate(210deg);\
        -ms-transform: rotate(210deg);\
        transform: rotate(210deg);\
    }\
    .sk-fading-circle .sk-circle9 {\
        -webkit-transform: rotate(240deg);\
        -ms-transform: rotate(240deg);\
        transform: rotate(240deg);\
    }\
    .sk-fading-circle .sk-circle10 {\
        -webkit-transform: rotate(270deg);\
        -ms-transform: rotate(270deg);\
        transform: rotate(270deg);\
    }\
    .sk-fading-circle .sk-circle11 {\
        -webkit-transform: rotate(300deg);\
        -ms-transform: rotate(300deg);\
        transform: rotate(300deg);\
    }\
    .sk-fading-circle .sk-circle12 {\
        -webkit-transform: rotate(330deg);\
        -ms-transform: rotate(330deg);\
        transform: rotate(330deg);\
    }\
    .sk-fading-circle .sk-circle2:before {\
        -webkit-animation-delay: -1.1s;\
        animation-delay: -1.1s;\
    }\
    .sk-fading-circle .sk-circle3:before {\
        -webkit-animation-delay: -1s;\
        animation-delay: -1s;\
    }\
    .sk-fading-circle .sk-circle4:before {\
        -webkit-animation-delay: -0.9s;\
        animation-delay: -0.9s;\
    }\
    .sk-fading-circle .sk-circle5:before {\
        -webkit-animation-delay: -0.8s;\
        animation-delay: -0.8s;\
    }\
    .sk-fading-circle .sk-circle6:before {\
        -webkit-animation-delay: -0.7s;\
        animation-delay: -0.7s;\
    }\
    .sk-fading-circle .sk-circle7:before {\
        -webkit-animation-delay: -0.6s;\
        animation-delay: -0.6s;\
    }\
    .sk-fading-circle .sk-circle8:before {\
        -webkit-animation-delay: -0.5s;\
        animation-delay: -0.5s;\
    }\
    .sk-fading-circle .sk-circle9:before {\
        -webkit-animation-delay: -0.4s;\
        animation-delay: -0.4s;\
    }\
    .sk-fading-circle .sk-circle10:before {\
        -webkit-animation-delay: -0.3s;\
        animation-delay: -0.3s;\
    }\
    .sk-fading-circle .sk-circle11:before {\
        -webkit-animation-delay: -0.2s;\
        animation-delay: -0.2s;\
    }\
    .sk-fading-circle .sk-circle12:before {\
        -webkit-animation-delay: -0.1s;\
        animation-delay: -0.1s;\
    }\
    @-webkit-keyframes sk-circleFadeDelay {\
        0%, 39%, 100% { opacity: 0; }\
        40% { opacity: 1; }\
    }\
    @keyframes sk-circleFadeDelay {\
        0%, 39%, 100% { opacity: 0; }\
        40% { opacity: 1; }\
    }";class Spinner extends Component{get type(){return type$1}
init(cfg){super.init(cfg);this._canvas=cfg.canvas;this._injectSpinnerCSS();const div=document.createElement('div');const style=div.style;style["z-index"]="9000";style.position="absolute";div.innerHTML='<div class="sk-fading-circle">\
                <div class="sk-circle1 sk-circle"></div>\
                <div class="sk-circle2 sk-circle"></div>\
                <div class="sk-circle3 sk-circle"></div>\
                <div class="sk-circle4 sk-circle"></div>\
                <div class="sk-circle5 sk-circle"></div>\
                <div class="sk-circle6 sk-circle"></div>\
                <div class="sk-circle7 sk-circle"></div>\
                <div class="sk-circle8 sk-circle"></div>\
                <div class="sk-circle9 sk-circle"></div>\
                <div class="sk-circle10 sk-circle"></div>\
                <div class="sk-circle11 sk-circle"></div>\
                <div class="sk-circle12 sk-circle"></div>\
                </div>';this._canvas.parentElement.appendChild(div);this._element=div;this._adjustPosition();this.processes=0}
set processes(value){value=value||0;if(this._processes===value){return}
if(value<0){return}
const prevValue=this._processes;this._processes=value;this._element.style.visibility=(this._processes>0)?"visible":"hidden";this.fire("processes",this._processes);if(this._processes===0&&this._processes!==prevValue){this.fire("zeroProcesses",this._processes)}}
get processes(){return this._processes}
_adjustPosition(){if(!this._canvas||!this._element){return}
const canvas=this._canvas;const spinner=this._element;const spinnerStyle=spinner.style;spinnerStyle.left=(canvas.offsetLeft+(canvas.clientWidth*0.5)-(spinner.clientWidth*0.5))+"px";spinnerStyle.top=(canvas.offsetTop+(canvas.clientHeight*0.5)-(spinner.clientHeight*0.5))+"px"}
_injectSpinnerCSS(){if(spinnerCSSInjected){return}
const node=document.createElement('style');node.innerHTML=spinnerCSS;document.body.appendChild(node);spinnerCSSInjected=!0}}
const WEBGL_INFO={WEBGL:!1,SUPPORTED_EXTENSIONS:{}};const canvas=document.createElement("canvas");if(canvas){const gl=canvas.getContext("webgl",{antialias:!0})||canvas.getContext("experimental-webgl",{antialias:!0});WEBGL_INFO.WEBGL=!!gl;if(WEBGL_INFO.WEBGL){WEBGL_INFO.ANTIALIAS=gl.getContextAttributes().antialias;if(gl.getShaderPrecisionFormat){if(gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER,gl.HIGH_FLOAT).precision>0){WEBGL_INFO.FS_MAX_FLOAT_PRECISION="highp"}else if(gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER,gl.MEDIUM_FLOAT).precision>0){WEBGL_INFO.FS_MAX_FLOAT_PRECISION="mediump"}else{WEBGL_INFO.FS_MAX_FLOAT_PRECISION="lowp"}}else{WEBGL_INFO.FS_MAX_FLOAT_PRECISION="mediump"}
WEBGL_INFO.DEPTH_BUFFER_BITS=gl.getParameter(gl.DEPTH_BITS);WEBGL_INFO.MAX_TEXTURE_SIZE=gl.getParameter(gl.MAX_TEXTURE_SIZE);WEBGL_INFO.MAX_CUBE_MAP_SIZE=gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);WEBGL_INFO.MAX_RENDERBUFFER_SIZE=gl.getParameter(gl.MAX_RENDERBUFFER_SIZE);WEBGL_INFO.MAX_TEXTURE_UNITS=gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS);WEBGL_INFO.MAX_TEXTURE_IMAGE_UNITS=gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);WEBGL_INFO.MAX_VERTEX_ATTRIBS=gl.getParameter(gl.MAX_VERTEX_ATTRIBS);WEBGL_INFO.MAX_VERTEX_UNIFORM_VECTORS=gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);WEBGL_INFO.MAX_FRAGMENT_UNIFORM_VECTORS=gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS);WEBGL_INFO.MAX_VARYING_VECTORS=gl.getParameter(gl.MAX_VARYING_VECTORS);gl.getSupportedExtensions().forEach(function(ext){WEBGL_INFO.SUPPORTED_EXTENSIONS[ext]=!0})}}
const type$2="xeogl.Canvas";const WEBGL_CONTEXT_NAMES=["webgl","experimental-webgl","webkit-3d","moz-webgl","moz-glweb20"];class Canvas extends Component{get type(){return type$2}
init(cfg){super.init(cfg);this.canvas=null;this.gl=null;this.webgl2=!1;this.transparent=!!cfg.transparent;this.contextAttr=cfg.contextAttr||{};this.contextAttr.alpha=this.transparent;if(this.contextAttr.preserveDrawingBuffer===undefined||this.contextAttr.preserveDrawingBuffer===null){this.contextAttr.preserveDrawingBuffer=!0}
this.contextAttr.stencil=!1;this.contextAttr.antialias=!0;this.contextAttr.premultipliedAlpha=this.contextAttr.premultipliedAlpha!==!1;this.contextAttr.antialias=this.contextAttr.antialias!==!1;if(!cfg.canvas){this._createCanvas()}else{if(utils.isString(cfg.canvas)){this.canvas=document.getElementById(cfg.canvas);if(!this.canvas){this.error("Canvas element not found: "+utils.inQuotes(cfg.canvas)+" - creating default canvas instead.");this._createCanvas()}}else{this.canvas=cfg.canvas}}
if(!this.canvas){this.error("Faied to create canvas");return}
this.canvas.width=this.canvas.clientWidth;this.canvas.height=this.canvas.clientHeight;this.boundary=[this.canvas.offsetLeft,this.canvas.offsetTop,this.canvas.clientWidth,this.canvas.clientHeight];this._createBackground();if(cfg.simulateWebGLContextLost){if(window.WebGLDebugUtils){this.canvas=WebGLDebugUtils.makeLostContextSimulatingCanvas(this.canvas)}else{this.error("To simulate context loss, please include WebGLDebugUtils")}}
this._initWebGL(cfg);const self=this;this.canvas.addEventListener("webglcontextlost",this._webglcontextlostListener=function(event){console.time("webglcontextrestored");self.scene._webglContextLost();self.fire("webglcontextlost");event.preventDefault()},!1);this.canvas.addEventListener("webglcontextrestored",this._webglcontextrestoredListener=function(event){self._initWebGL();if(self.gl){self.scene._webglContextRestored(self.gl);self.fire("webglcontextrestored",self.gl);event.preventDefault()}
console.timeEnd("webglcontextrestored")},!1);let lastWindowWidth=null;let lastWindowHeight=null;let lastCanvasWidth=null;let lastCanvasHeight=null;let lastCanvasOffsetLeft=null;let lastCanvasOffsetTop=null;let lastParent=null;this._tick=this.scene.on("tick",function(){const canvas=self.canvas;const newWindowSize=(window.innerWidth!==lastWindowWidth||window.innerHeight!==lastWindowHeight);const newCanvasSize=(canvas.clientWidth!==lastCanvasWidth||canvas.clientHeight!==lastCanvasHeight);const newCanvasPos=(canvas.offsetLeft!==lastCanvasOffsetLeft||canvas.offsetTop!==lastCanvasOffsetTop);const parent=canvas.parentElement;const newParent=(parent!==lastParent);if(newWindowSize||newCanvasSize||newCanvasPos||newParent){self._spinner._adjustPosition();if(newCanvasSize||newCanvasPos){const newWidth=canvas.clientWidth;const newHeight=canvas.clientHeight;if(newCanvasSize){let countPixels=0;let scene;for(const sceneId in core.scenes){if(core.scenes.hasOwnProperty(sceneId)){scene=core.scenes[sceneId];countPixels+=scene.canvas.canvas.clientWidth*scene.canvas.canvas.clientHeight}}
stats.memory.pixels=countPixels;canvas.width=canvas.clientWidth;canvas.height=canvas.clientHeight}
const boundary=self.boundary;boundary[0]=canvas.offsetLeft;boundary[1]=canvas.offsetTop;boundary[2]=newWidth;boundary[3]=newHeight;self.fire("boundary",boundary);lastCanvasWidth=newWidth;lastCanvasHeight=newHeight}
if(newWindowSize){lastWindowWidth=window.innerWidth;lastWindowHeight=window.innerHeight}
if(newCanvasPos){lastCanvasOffsetLeft=canvas.offsetLeft;lastCanvasOffsetTop=canvas.offsetTop}
lastParent=parent}});this.canvas.oncontextmenu=function(e){e.preventDefault()};this._spinner=new Spinner(this.scene,{canvas:this.canvas});this.backgroundColor=cfg.backgroundColor;this.backgroundImage=cfg.backgroundImage}
_createCanvas(){const canvasId="xeogl-canvas-"+math.createUUID();const body=document.getElementsByTagName("body")[0];const div=document.createElement('div');const style=div.style;style.height="100%";style.width="100%";style.padding="0";style.margin="0";style.background="rgba(0,0,0,0);";style.float="left";style.left="0";style.top="0";style.position="absolute";style.opacity="1.0";style["z-index"]="-10000";div.innerHTML+='<canvas id="'+canvasId+'" style="width: 100%; height: 100%; float: left; margin: 0; padding: 0;"></canvas>';body.appendChild(div);this.canvas=document.getElementById(canvasId)}
_createBackground(){const div=document.createElement('div');const style=div.style;style.padding="0";style.margin="0";style.background=null;style.backgroundImage=null;style.float="left";style.left="0";style.top="0";style.width="100%";style.height="100%";style.position="absolute";style.opacity=1;style["z-index"]="-20000";this.canvas.parentElement.appendChild(div);this._backgroundElement=div}
_getElementXY(e){let x=0,y=0;while(e){x+=(e.offsetLeft-e.scrollLeft);y+=(e.offsetTop-e.scrollTop);e=e.offsetParent}
return{x:x,y:y}}
_initWebGL(cfg){if(!this.gl){for(let i=0;!this.gl&&i<WEBGL_CONTEXT_NAMES.length;i++){try{this.gl=this.canvas.getContext(WEBGL_CONTEXT_NAMES[i],this.contextAttr)}catch(e){}}}
if(!this.gl){this.error('Failed to get a WebGL context');this.fire("webglContextFailed",!0,!0)}
if(this.gl){if(this.webgl2){this.gl.hint(this.gl.FRAGMENT_SHADER_DERIVATIVE_HINT,this.gl.FASTEST)}else if(WEBGL_INFO.SUPPORTED_EXTENSIONS.OES_standard_derivatives){const ext=this.gl.getExtension("OES_standard_derivatives");this.gl.hint(ext.FRAGMENT_SHADER_DERIVATIVE_HINT_OES,this.gl.FASTEST)}}}
getSnapshot(params,ok){if(!this.canvas){this.error("Can't get snapshot - no canvas.");ok(null);return}
if(ok){const self=this;requestAnimationFrame(function(){self.scene.render(!0);ok(self._getSnapshot(params))})}else{return this._getSnapshot(params)}}
_getSnapshot(params){params=params||{};const width=params.width||this.canvas.width;const height=params.height||this.canvas.height;const format=params.format||"jpeg";let image;switch(format){case "jpeg":image=Canvas2Image.saveAsJPEG(this.canvas,!1,width,height);break;case "png":image=Canvas2Image.saveAsPNG(this.canvas,!0,width,height);break;case "bmp":image=Canvas2Image.saveAsBMP(this.canvas,!0,width,height);break;default:this.error("Unsupported snapshot format: '"+format+"' - supported types are 'jpeg', 'bmp' and 'png' - defaulting to 'jpeg'");image=Canvas2Image.saveAsJPEG(this.canvas,!0,width,height)}
return image.src}
readPixels(pixels,colors,size,opaqueOnly){return this.scene._renderer.readPixels(pixels,colors,size,opaqueOnly)}
loseWebGLContext(){if(this.canvas.loseContext){this.canvas.loseContext()}}
set backgroundColor(value){if(!value){this._backgroundColor=null}else{(this._backgroundColor=this._backgroundColor||math.vec4()).set(value||[0,0,0,1]);if(!this._backgroundImageSrc){const rgb="rgb("+Math.round(this._backgroundColor[0]*255)+", "+Math.round(this._backgroundColor[1]*255)+","+Math.round(this._backgroundColor[2]*255)+")";this._backgroundElement.style.background=rgb}}}
get backgroundColor(){return this._backgroundColor}
set backgroundImage(value){if(!value){return}
if(!utils.isString(value)){this.error("Value for 'backgroundImage' should be a string");return}
if(value===this._backgroundImageSrc){return}
this._backgroundElement.style.backgroundImage="url('"+value+"')";this._backgroundImageSrc=value;if(!this._backgroundImageSrc){const rgb="rgb("+Math.round(this._backgroundColor[0]*255)+", "+Math.round(this._backgroundColor[1]*255)+","+Math.round(this._backgroundColor[2]*255)+")";this._backgroundElement.style.background=rgb}}
get backgroundImage(){return this._backgroundImageSrc}
get spinner(){return this._spinner}
destroy(){this.scene.off(this._tick);this.canvas.removeEventListener("webglcontextlost",this._webglcontextlostListener);this.canvas.removeEventListener("webglcontextrestored",this._webglcontextrestoredListener);this.canvas=null;this.gl=null;super.destroy()}}
componentClasses[type$2]=Canvas;class Frame{constructor(){this.reset()}
reset(){this.lastProgramId=null;this.backfaces=!1;this.frontface=!0;this.textureUnit=0;this.drawElements=0;this.drawArrays=0;this.useProgram=0;this.bindTexture=0;this.bindArray=0;this.pass=0;this.shadowViewMatrix=null;this.shadowProjMatrix=null;this.pickViewMatrix=null;this.pickProjMatrix=null;this.pickmeshIndex=1}}
class RenderBuffer{constructor(canvas,gl,options){options=options||{};this.gl=gl;this.allocated=!1;this.canvas=canvas;this.buffer=null;this.bound=!1;this.size=options.size}
setSize(size){this.size=size}
webglContextRestored(gl){this.gl=gl;this.buffer=null;this.allocated=!1;this.bound=!1}
bind(){this._touch();if(this.bound){return}
const gl=this.gl;gl.bindFramebuffer(gl.FRAMEBUFFER,this.buffer.framebuf);this.bound=!0}
_touch(){let width;let height;const gl=this.gl;if(this.size){width=this.size[0];height=this.size[1]}else{width=this.canvas.clientWidth;height=this.canvas.clientHeight}
if(this.buffer){if(this.buffer.width===width&&this.buffer.height===height){return}else{gl.deleteTexture(this.buffer.texture);gl.deleteFramebuffer(this.buffer.framebuf);gl.deleteRenderbuffer(this.buffer.renderbuf)}}
const texture=gl.createTexture();gl.bindTexture(gl.TEXTURE_2D,texture);gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,width,height,0,gl.RGBA,gl.UNSIGNED_BYTE,null);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,gl.NEAREST);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,gl.NEAREST);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_S,gl.CLAMP_TO_EDGE);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_T,gl.CLAMP_TO_EDGE);const renderbuf=gl.createRenderbuffer();gl.bindRenderbuffer(gl.RENDERBUFFER,renderbuf);gl.renderbufferStorage(gl.RENDERBUFFER,gl.DEPTH_COMPONENT16,width,height);const framebuf=gl.createFramebuffer();gl.bindFramebuffer(gl.FRAMEBUFFER,framebuf);gl.framebufferTexture2D(gl.FRAMEBUFFER,gl.COLOR_ATTACHMENT0,gl.TEXTURE_2D,texture,0);gl.framebufferRenderbuffer(gl.FRAMEBUFFER,gl.DEPTH_ATTACHMENT,gl.RENDERBUFFER,renderbuf);gl.bindTexture(gl.TEXTURE_2D,null);gl.bindRenderbuffer(gl.RENDERBUFFER,null);gl.bindFramebuffer(gl.FRAMEBUFFER,null);gl.bindFramebuffer(gl.FRAMEBUFFER,framebuf);if(!gl.isFramebuffer(framebuf)){throw "Invalid framebuffer"}
gl.bindFramebuffer(gl.FRAMEBUFFER,null);const status=gl.checkFramebufferStatus(gl.FRAMEBUFFER);switch(status){case gl.FRAMEBUFFER_COMPLETE:break;case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:throw "Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:throw "Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:throw "Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case gl.FRAMEBUFFER_UNSUPPORTED:throw "Incomplete framebuffer: FRAMEBUFFER_UNSUPPORTED";default:throw "Incomplete framebuffer: "+status}
this.buffer={framebuf:framebuf,renderbuf:renderbuf,texture:texture,width:width,height:height};this.bound=!1}
clear(){if(!this.bound){throw "Render buffer not bound"}
const gl=this.gl;gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT)}
read(pickX,pickY){const x=pickX;const y=this.canvas.height-pickY;const pix=new Uint8Array(4);const gl=this.gl;gl.readPixels(x,y,1,1,gl.RGBA,gl.UNSIGNED_BYTE,pix);return pix}
unbind(){const gl=this.gl;gl.bindFramebuffer(gl.FRAMEBUFFER,null);this.bound=!1}
getTexture(){const self=this;return{renderBuffer:this,bind:function(unit){if(self.buffer&&self.buffer.texture){self.gl.activeTexture(self.gl["TEXTURE"+unit]);self.gl.bindTexture(self.gl.TEXTURE_2D,self.buffer.texture);return!0}
return!1},unbind:function(unit){if(self.buffer&&self.buffer.texture){self.gl.activeTexture(self.gl["TEXTURE"+unit]);self.gl.bindTexture(self.gl.TEXTURE_2D,null)}}}}
destroy(){if(this.allocated){const gl=this.gl;gl.deleteTexture(this.buffer.texture);gl.deleteFramebuffer(this.buffer.framebuf);gl.deleteRenderbuffer(this.buffer.renderbuf);this.allocated=!1;this.buffer=null;this.bound=!1}}}
const ids=new Map({});class State{constructor(cfg){this.id=ids.addItem({});for(const key in cfg){if(cfg.hasOwnProperty(key)){this[key]=cfg[key]}}}
destroy(){ids.removeItem(this.id)}}
class ArrayBuffer{constructor(gl,type,data,numItems,itemSize,usage){this._gl=gl;this.type=type;this.allocated=!1;switch(data.constructor){case Uint8Array:this.itemType=gl.UNSIGNED_BYTE;this.itemByteSize=1;break;case Int8Array:this.itemType=gl.BYTE;this.itemByteSize=1;break;case Uint16Array:this.itemType=gl.UNSIGNED_SHORT;this.itemByteSize=2;break;case Int16Array:this.itemType=gl.SHORT;this.itemByteSize=2;break;case Uint32Array:this.itemType=gl.UNSIGNED_INT;this.itemByteSize=4;break;case Int32Array:this.itemType=gl.INT;this.itemByteSize=4;break;default:this.itemType=gl.FLOAT;this.itemByteSize=4}
this.usage=usage;this.length=0;this.numItems=0;this.itemSize=itemSize;this._allocate(data)}
_allocate(data){this.allocated=!1;this._handle=this._gl.createBuffer();if(!this._handle){throw "Failed to allocate WebGL ArrayBuffer"}
if(this._handle){this._gl.bindBuffer(this.type,this._handle);this._gl.bufferData(this.type,data,this.usage);this._gl.bindBuffer(this.type,null);this.length=data.length;this.numItems=this.length/this.itemSize;this.allocated=!0}}
setData(data,offset){if(!this.allocated){return}
if(data.length>this.length){this.destroy();this._allocate(data,data.length)}else{this._gl.bindBuffer(this.type,this._handle);if(offset||offset===0){this._gl.bufferSubData(this.type,offset*this.itemByteSize,data)}else{this._gl.bufferData(this.type,data,this.usage)}
this._gl.bindBuffer(this.type,null)}}
bind(){if(!this.allocated){return}
this._gl.bindBuffer(this.type,this._handle)}
unbind(){if(!this.allocated){return}
this._gl.bindBuffer(this.type,null)}
destroy(){if(!this.allocated){return}
this._gl.deleteBuffer(this._handle);this._handle=null;this.allocated=!1}}
const CHUNK_LEN=bigIndicesSupported?(Number.MAX_SAFE_INTEGER/6):(64000*4);const memoryStats=stats.memory;var bigIndicesSupported=WEBGL_INFO.SUPPORTED_EXTENSIONS.OES_element_index_uint;const nullVertexBufs=new State({});class SceneVertexBufs{constructor(scene,hasPositions,hasNormals,hasColors,hasUVs,quantized){this.scene=scene;this.gl=scene.canvas.gl;this.contextLost=!1;this.geometries={};this.geometryIndicesOffsets={};this.newGeometries=[];this.geometryVertexBufs={};this.needRebuild=!1;this.needAppend=!1;this.positions=hasPositions?[]:null;this.normals=hasNormals?[]:null;this.colors=hasColors?[]:null;this.uv=hasUVs?[]:null;this.quantized=quantized;this.vertexBufs=null}
addGeometry(geometry){if(!geometry.positions||!geometry.indices){this.scene.warn(`Ignoring geometry with no positions or indices: ${geometry.id}`);return}
this.geometries[geometry.id]=geometry;this.geometryIndicesOffsets[geometry.id]=0;this.newGeometries.push(geometry);this.needAppend=!0}
getIndicesOffset(geometry){if(this.needRebuild||this.needAppend){this.build()}
return this.geometryIndicesOffsets[geometry.id]}
getVertexBufs(geometry){if(!this.geometries[geometry.id]){return nullVertexBufs}
if(this.needRebuild||this.needAppend){this.build()}
return this.geometryVertexBufs[geometry.id]}
setPositions(geometry){const vertexBufs=this.geometryVertexBufs[geometry.id];if(!vertexBufs){return}
if(!geometry.positions){return}
const positionsBuf=vertexBufs.positionsBuf;if(!positionsBuf){return}
positionsBuf.setData(geometry.positions,this.geometryIndicesOffsets[geometry.id]*3)}
setNormals(geometry){const vertexBufs=this.geometryVertexBufs[geometry.id];if(!vertexBufs){return}
if(!geometry.normals){return}
const normalsBuf=vertexBufs.normalsBuf;if(!normalsBuf){return}
normalsBuf.setData(geometry.normals,this.geometryIndicesOffsets[geometry.id]*3)}
setUVs(geometry){const vertexBufs=this.geometryVertexBufs[geometry.id];if(!vertexBufs){return}
if(!geometry.uv){return}
const uvBuf=vertexBufs.uvBuf;if(!uvBuf){return}
uvBuf.setData(geometry.uv,this.geometryIndicesOffsets[geometry.id]*2)}
setColors(geometry){const vertexBufs=this.geometryVertexBufs[geometry.id];if(!vertexBufs){return}
if(!geometry.color){return}
const colorsBuf=vertexBufs.colorsBuf;if(!colorsBuf){return}
colorsBuf.setData(geometry.colors,this.geometryIndicesOffsets[geometry.id]*4)}
removeGeometry(geometry){const id=geometry.id;if(!this.geometries[id]){return}
delete this.geometries[id];delete this.geometryIndicesOffsets[id];if(geometry.indicesBufCombined){geometry.indicesBufCombined.destroy()}
this.needRebuild=!0}
webglContextLost(){this.contextLost=!0}
webglContextRestored(){if(this.contextLost){for(const id in this.geometries){if(this.geometries.hasOwnProperty(id)){this.geometries[id].indicesBufCombined=null}}
this.build();this.contextLost=!1}}
build(){const gl=this.scene.canvas.gl;this.geometryVertexBufs={};let id;let geometry;let indicesOffset=0;this.vertexBufs=null;let lenPositions=0;let lenNormals=0;let lenUVs=0;let lenColors=0;for(id in this.geometries){if(this.geometries.hasOwnProperty(id)){geometry=this.geometries[id];if(this.positions){lenPositions+=geometry.positions.length}
if(this.normals){lenNormals+=geometry.normals.length}
if(this.uv){lenUVs+=geometry.uv.length}
if(this.colors){lenColors+=geometry.uv.length}}}
for(id in this.geometries){if(this.geometries.hasOwnProperty(id)){geometry=this.geometries[id];const needNew=(!this.vertexBufs)||(this.positions.length+geometry.positions.length>CHUNK_LEN);if(needNew){if(this.vertexBufs){this.createBufs(this.vertexBufs)}
this.vertexBufs=new State({positionsBuf:null,normalsBuf:null,uvBuf:null,colorsBuf:null,quantized:this.quantized});indicesOffset=0}
this.geometryVertexBufs[id]=this.vertexBufs;if(this.positions){for(var i=0,len=geometry.positions.length;i<len;i++){this.positions.push(geometry.positions[i])}}
if(this.normals){for(var i=0,len=geometry.normals.length;i<len;i++){this.normals.push(geometry.normals[i])}}
if(this.colors){for(var i=0,len=geometry.colors.length;i<len;i++){this.colors.push(geometry.colors[i])}}
if(this.uv){for(var i=0,len=geometry.uv.length;i<len;i++){this.uv.push(geometry.uv[i])}}
this.geometryIndicesOffsets[id]=indicesOffset;let indices;if(indicesOffset){indices=new(bigIndicesSupported?Uint32Array:Uint16Array)(geometry.indices);for(var i=0,len=indices.length;i<len;i++){indices[i]+=indicesOffset;if(indices[i]>(CHUNK_LEN/3)){console.error(`out of range: ${indices[i]}`)}}}else{indices=geometry.indices}
if(!geometry.indicesBufCombined){geometry.indicesBufCombined=new ArrayBuffer(gl,gl.ELEMENT_ARRAY_BUFFER,indices,indices.length,1,gl.STATIC_DRAW)}else{geometry.indicesBufCombined.setData(indices)}
indicesOffset+=geometry.positions.length/3}}
if(this.vertexBufs){this.createBufs(this.vertexBufs)}
this.needRebuild=!1;this.needAppend=!1}
createBufs(vertexBufs){const gl=this.scene.canvas.gl;let array;if(this.positions){array=this.quantized?new Uint16Array(this.positions):new Float32Array(this.positions);vertexBufs.positionsBuf=new ArrayBuffer(gl,gl.ARRAY_BUFFER,array,array.length,3,gl.STATIC_DRAW);memoryStats.positions+=vertexBufs.positionsBuf.numItems;this.positions=[]}
if(this.normals){array=this.quantized?new Int8Array(this.normals):new Float32Array(this.normals);vertexBufs.normalsBuf=new ArrayBuffer(gl,gl.ARRAY_BUFFER,array,array.length,3,gl.STATIC_DRAW);memoryStats.normals+=vertexBufs.normalsBuf.numItems;this.normals=[]}
if(this.colors){array=new Float32Array(this.colors);vertexBufs.colorsBuf=new ArrayBuffer(gl,gl.ARRAY_BUFFER,array,array.length,4,gl.STATIC_DRAW);memoryStats.colors+=vertexBufs.colorsBuf.numItems;this.colors=[]}
if(this.uv){array=this.quantized?new Uint16Array(this.uv):new Float32Array(this.uv);vertexBufs.uvBuf=new ArrayBuffer(gl,gl.ARRAY_BUFFER,array,array.length,2,gl.STATIC_DRAW);memoryStats.uvs+=vertexBufs.uvBuf.numItems;this.uv=[]}}}
const getSceneVertexBufs=(scene,geometry)=>{const hasPositions=!!geometry.positions;const quantized=!!geometry.quantized;const hasNormals=!!geometry.normals;const hasColors=!!geometry.colors;const hasUVs=!!geometry.uv;const hash=([scene.id,hasPositions?"p":"",quantized?"c":"",hasNormals?"n":"",hasColors?"c":"",hasUVs?"u":""]).join(";");if(!scene._sceneVertexBufs){scene._sceneVertexBufs={}}
let sceneVertexBufs=scene._sceneVertexBufs[hash];if(!sceneVertexBufs){sceneVertexBufs=new SceneVertexBufs(scene,hasPositions,hasNormals,hasColors,hasUVs,quantized);scene._sceneVertexBufs[hash]=sceneVertexBufs}
return sceneVertexBufs};const type$3="xeogl.Geometry";const memoryStats$1=stats.memory;var bigIndicesSupported$1=WEBGL_INFO.SUPPORTED_EXTENSIONS.OES_element_index_uint;const IndexArrayType$1=bigIndicesSupported$1?Uint32Array:Uint16Array;const nullVertexBufs$1=new State({});const tempAABB=math.AABB3();class Geometry extends Component{get type(){return type$3}
init(cfg){super.init(cfg);const self=this;this._state=new State({combined:!!cfg.combined,quantized:!!cfg.quantized,autoVertexNormals:!!cfg.autoVertexNormals,primitive:null,primitiveName:null,positions:null,normals:null,colors:null,uv:null,indices:null,positionsDecodeMatrix:null,uvDecodeMatrix:null,positionsBuf:null,normalsBuf:null,colorsbuf:null,uvBuf:null,indicesBuf:null,indicesBufCombined:null,hash:""});this._edgeThreshold=cfg.edgeThreshold||2.0;this._edgesIndicesBuf=null;this._pickTrianglePositionsBuf=null;this._pickTriangleColorsBuf=null;this._boundaryDirty=!0;this._aabb=null;this._aabbDirty=!0;this._obb=null;this._obbDirty=!0;const state=this._state;const gl=this.scene.canvas.gl;cfg.primitive=cfg.primitive||"triangles";switch(cfg.primitive){case "points":state.primitive=gl.POINTS;state.primitiveName=cfg.primitive;break;case "lines":state.primitive=gl.LINES;state.primitiveName=cfg.primitive;break;case "line-loop":state.primitive=gl.LINE_LOOP;state.primitiveName=cfg.primitive;break;case "line-strip":state.primitive=gl.LINE_STRIP;state.primitiveName=cfg.primitive;break;case "triangles":state.primitive=gl.TRIANGLES;state.primitiveName=cfg.primitive;break;case "triangle-strip":state.primitive=gl.TRIANGLE_STRIP;state.primitiveName=cfg.primitive;break;case "triangle-fan":state.primitive=gl.TRIANGLE_FAN;state.primitiveName=cfg.primitive;break;default:this.error("Unsupported value for 'primitive': '"+cfg.primitive+"' - supported values are 'points', 'lines', 'line-loop', 'line-strip', 'triangles', "+"'triangle-strip' and 'triangle-fan'. Defaulting to 'triangles'.");state.primitive=gl.TRIANGLES;state.primitiveName=cfg.primitive}
if(cfg.positions){if(this._state.quantized){var bounds=getBounds(cfg.positions,3);var quantized=quantizeVec3(cfg.positions,bounds.min,bounds.max);state.positions=quantized.quantized;state.positionsDecodeMatrix=quantized.decode}else{state.positions=cfg.positions.constructor===Float32Array?cfg.positions:new Float32Array(cfg.positions)}}
if(cfg.colors){state.colors=cfg.colors.constructor===Float32Array?cfg.colors:new Float32Array(cfg.colors)}
if(cfg.uv){if(this._state.quantized){var bounds=getBounds(cfg.uv,2);var quantized=quantizeVec2(cfg.uv,bounds.min,bounds.max);state.uv=quantized.quantized;state.uvDecodeMatrix=quantized.decode}else{state.uv=cfg.uv.constructor===Float32Array?cfg.uv:new Float32Array(cfg.uv)}}
if(cfg.normals){if(this._state.quantized){state.normals=octEncode(cfg.normals)}else{state.normals=cfg.normals.constructor===Float32Array?cfg.normals:new Float32Array(cfg.normals)}}
if(cfg.indices){if(!bigIndicesSupported$1&&cfg.indices.constructor===Uint32Array){this.error("This WebGL implementation does not support Uint32Array");return}
state.indices=(cfg.indices.constructor===Uint32Array||cfg.indices.constructor===Uint16Array)?cfg.indices:new IndexArrayType$1(cfg.indices)}
if(state.indices){state.indicesBuf=new ArrayBuffer(gl,gl.ELEMENT_ARRAY_BUFFER,state.indices,state.indices.length,1,gl.STATIC_DRAW);memoryStats$1.indices+=state.indicesBuf.numItems}
this._buildHash();memoryStats$1.meshes++;if(this._state.combined){this._sceneVertexBufs=getSceneVertexBufs(this.scene,this._state);this._sceneVertexBufs.addGeometry(this._state)}
this._buildVBOs();self.fire("created",this.created=!0)}
_buildVBOs(){const state=this._state;const gl=this.scene.canvas.gl;if(state.indices){state.indicesBuf=new ArrayBuffer(gl,gl.ELEMENT_ARRAY_BUFFER,state.indices,state.indices.length,1,gl.STATIC_DRAW);memoryStats$1.indices+=state.indicesBuf.numItems}
if(state.combined){if(state.indices){}}else{if(state.positions){state.positionsBuf=new ArrayBuffer(gl,gl.ARRAY_BUFFER,state.positions,state.positions.length,3,gl.STATIC_DRAW);memoryStats$1.positions+=state.positionsBuf.numItems}
if(state.normals){state.normalsBuf=new ArrayBuffer(gl,gl.ARRAY_BUFFER,state.normals,state.normals.length,3,gl.STATIC_DRAW);memoryStats$1.normals+=state.normalsBuf.numItems}
if(state.colors){state.colorsBuf=new ArrayBuffer(gl,gl.ARRAY_BUFFER,state.colors,state.colors.length,4,gl.STATIC_DRAW);memoryStats$1.colors+=state.colorsBuf.numItems}
if(state.uv){state.uvBuf=new ArrayBuffer(gl,gl.ARRAY_BUFFER,state.uv,state.uv.length,2,gl.STATIC_DRAW);memoryStats$1.uvs+=state.uvBuf.numItems}}}
_buildHash(){const state=this._state;const hash=["/g"];hash.push("/"+state.primitive+";");if(state.positions){hash.push("p")}
if(state.colors){hash.push("c")}
if(state.normals||state.autoVertexNormals){hash.push("n")}
if(state.uv){hash.push("u")}
if(state.quantized){hash.push("cp")}
hash.push(";");state.hash=hash.join("")}
_getEdgesIndices(){if(!this._edgesIndicesBuf){this._buildEdgesIndices()}
return this._edgesIndicesBuf}
_getPickTrianglePositions(){if(!this._pickTrianglePositionsBuf){this._buildPickTriangleVBOs()}
return this._pickTrianglePositionsBuf}
_getPickTriangleColors(){if(!this._pickTriangleColorsBuf){this._buildPickTriangleVBOs()}
return this._pickTriangleColorsBuf}
_buildEdgesIndices(){const state=this._state;if(!state.positions||!state.indices){return}
const gl=this.scene.canvas.gl;const edgesIndices=buildEdgesIndices(state.positions,state.indices,state.positionsDecodeMatrix,this._edgeThreshold,state.combined);if(state.combined){const indicesOffset=this._sceneVertexBufs.getIndicesOffset(state);for(let i=0,len=edgesIndices.length;i<len;i++){edgesIndices[i]+=indicesOffset}}
this._edgesIndicesBuf=new ArrayBuffer(gl,gl.ELEMENT_ARRAY_BUFFER,edgesIndices,edgesIndices.length,1,gl.STATIC_DRAW);memoryStats$1.indices+=this._edgesIndicesBuf.numItems}
_buildPickTriangleVBOs(){const state=this._state;if(!state.positions||!state.indices){return}
const gl=this.scene.canvas.gl;const arrays=math.buildPickTriangles(state.positions,state.indices,state.quantized);const positions=arrays.positions;const colors=arrays.colors;this._pickTrianglePositionsBuf=new ArrayBuffer(gl,gl.ARRAY_BUFFER,positions,positions.length,3,gl.STATIC_DRAW);this._pickTriangleColorsBuf=new ArrayBuffer(gl,gl.ARRAY_BUFFER,colors,colors.length,4,gl.STATIC_DRAW,!0);memoryStats$1.positions+=this._pickTrianglePositionsBuf.numItems;memoryStats$1.colors+=this._pickTriangleColorsBuf.numItems}
_buildPickVertexVBOs(){}
_webglContextLost(){if(this._sceneVertexBufs){this._sceneVertexBufs.webglContextLost()}}
_webglContextRestored(){if(this._sceneVertexBufs){this._sceneVertexBufs.webglContextRestored()}
this._buildVBOs();this._edgesIndicesBuf=null;this._pickVertexPositionsBuf=null;this._pickTrianglePositionsBuf=null;this._pickTriangleColorsBuf=null;this._pickVertexPositionsBuf=null;this._pickVertexColorsBuf=null}
get primitive(){return this._state.primitiveName}
get quantized(){return this._state.quantized}
get combined(){return this._state.combined}
get positions(){if(!this._state.positions){return}
if(!this._state.quantized){return this._state.positions}
if(!this._decompressedPositions){this._decompressedPositions=new Float32Array(this._state.positions.length);math.decompressPositions(this._state.positions,this._state.positionsDecodeMatrix,this._decompressedPositions)}
return this._decompressedPositions}
set positions(newPositions){const state=this._state;const positions=state.positions;if(!positions){this.error("can't update geometry positions - geometry has no positions");return}
if(positions.length!==newPositions.length){this.error("can't update geometry positions - new positions are wrong length");return}
if(this._state.quantized){const bounds=getBounds(newPositions,3);const quantized=quantizeVec3(newPositions,bounds.min,bounds.max);newPositions=quantized.quantized;state.positionsDecodeMatrix=quantized.decode}
positions.set(newPositions);if(state.positionsBuf){state.positionsBuf.setData(positions)}
if(this._state.combined){this._sceneVertexBufs.setPositions(state)}
this._setBoundaryDirty();this._renderer.imageDirty()}
get normals(){if(!this._state.normals){return}
if(!this._state.quantized){return this._state.normals}
if(!this._decompressedNormals){const lenCompressed=this._state.normals.length;const lenDecompressed=lenCompressed+(lenCompressed/2);this._decompressedNormals=new Float32Array(lenDecompressed);math.octDecodeVec2s(this._state.normals,this._decompressedNormals)}
return this._decompressedNormals}
set normals(newNormals){if(this._state.quantized){this.error("can't update geometry normals - quantized geometry is immutable");return}
const state=this._state;const normals=state.normals;if(!normals){this.error("can't update geometry normals - geometry has no normals");return}
if(normals.length!==newNormals.length){this.error("can't update geometry normals - new normals are wrong length");return}
normals.set(newNormals);if(state.normalsBuf){state.normalsBuf.setData(normals)}
if(this._state.combined){this._sceneVertexBufs.setNormals(state)}
this._renderer.imageDirty()}
get uv(){if(!this._state.uv){return}
if(!this._state.quantized){return this._state.uv}
if(!this._decompressedUV){this._decompressedUV=new Float32Array(this._state.uv.length);math.decompressUVs(this._state.uv,this._state.uvDecodeMatrix,this._decompressedUV)}
return this._decompressedUV}
set uv(newUV){if(this._state.quantized){this.error("can't update geometry UVs - quantized geometry is immutable");return}
const state=this._state;const uv=state.uv;if(!uv){this.error("can't update geometry UVs - geometry has no UVs");return}
if(uv.length!==newUV.length){this.error("can't update geometry UVs - new UVs are wrong length");return}
uv.set(newUV);if(state.uvBuf){state.uvBuf.setData(uv)}
if(this._state.combined){this._sceneVertexBufs.setUVs(state)}
this._renderer.imageDirty()}
get colors(){return this._state.colors}
set colors(newColors){if(this._state.quantized){this.error("can't update geometry colors - quantized geometry is immutable");return}
const state=this._state;const colors=state.colors;if(!colors){this.error("can't update geometry colors - geometry has no colors");return}
if(colors.length!==newColors.length){this.error("can't update geometry colors - new colors are wrong length");return}
colors.set(newColors);if(state.colorsBuf){state.colorsBuf.setData(colors)}
if(this._state.combined){this._sceneVertexBufs.setColors(state)}
this._renderer.imageDirty()}
get indices(){return this._state.indices}
get aabb(){if(this._aabbDirty){if(!this._aabb){this._aabb=math.AABB3()}
math.positions3ToAABB3(this._state.positions,this._aabb,this._state.positionsDecodeMatrix);this._aabbDirty=!1}
return this._aabb}
get obb(){if(this._obbDirty){if(!this._obb){this._obb=math.OBB3()}
math.positions3ToAABB3(this._state.positions,tempAABB,this._state.positionsDecodeMatrix);math.AABB3ToOBB3(tempAABB,this._obb);this._obbDirty=!1}
return this._obb}
get kdtree(){const state=this._state;if(!state.indices||!state.positions){this.error("Can't provide a KD-tree: no indices/positions");return}
if(!this._kdtree){this._kdtree=math.buildKDTree(state.indices,state.positions,this._state.positionsDecodeMatrix)}
return this._kdtree}
_setBoundaryDirty(){if(this._boundaryDirty){return}
this._boundaryDirty=!0;this._aabbDirty=!0;this._obbDirty=!0;this.fire("boundary")}
_getState(){return this._state}
_getVertexBufs(){return this._state&&this._state.combined?this._sceneVertexBufs.getVertexBufs(this._state):nullVertexBufs$1}
destroy(){super.destroy();const state=this._state;if(state.indicesBuf){state.indicesBuf.destroy()}
if(this._edgesIndicesBuf){this._edgesIndicesBuf.destroy()}
if(this._pickTrianglePositionsBuf){this._pickTrianglePositionsBuf.destroy()}
if(this._pickTriangleColorsBuf){this._pickTriangleColorsBuf.destroy()}
if(this._pickVertexPositionsBuf){this._pickVertexPositionsBuf.destroy()}
if(this._pickVertexColorsBuf){this._pickVertexColorsBuf.destroy()}
if(this._state.combined){this._sceneVertexBufs.removeGeometry(state)}
state.destroy();memoryStats$1.meshes--}}
function getBounds(array,stride){const min=new Float32Array(stride);const max=new Float32Array(stride);let i,j;for(i=0;i<stride;i++){min[i]=Number.MAX_VALUE;max[i]=-Number.MAX_VALUE}
for(i=0;i<array.length;i+=stride){for(j=0;j<stride;j++){min[j]=Math.min(min[j],array[i+j]);max[j]=Math.max(max[j],array[i+j])}}
return{min:min,max:max}}
var quantizeVec3=(function(){const translate=math.mat4();const scale=math.mat4();return function(array,min,max){const quantized=new Uint16Array(array.length);const multiplier=new Float32Array([65535/(max[0]-min[0]),65535/(max[1]-min[1]),65535/(max[2]-min[2])]);let i;for(i=0;i<array.length;i+=3){quantized[i+0]=Math.floor((array[i+0]-min[0])*multiplier[0]);quantized[i+1]=Math.floor((array[i+1]-min[1])*multiplier[1]);quantized[i+2]=Math.floor((array[i+2]-min[2])*multiplier[2])}
math.identityMat4(translate);math.translationMat4v(min,translate);math.identityMat4(scale);math.scalingMat4v([(max[0]-min[0])/65535,(max[1]-min[1])/65535,(max[2]-min[2])/65535],scale);const decodeMat=math.mulMat4(translate,scale,math.identityMat4());return{quantized:quantized,decode:decodeMat}}})();var quantizeVec2=(function(){const translate=math.mat3();const scale=math.mat3();return function(array,min,max){const quantized=new Uint16Array(array.length);const multiplier=new Float32Array([65535/(max[0]-min[0]),65535/(max[1]-min[1])]);let i;for(i=0;i<array.length;i+=2){quantized[i+0]=Math.floor((array[i+0]-min[0])*multiplier[0]);quantized[i+1]=Math.floor((array[i+1]-min[1])*multiplier[1])}
math.identityMat3(translate);math.translationMat3v(min,translate);math.identityMat3(scale);math.scalingMat3v([(max[0]-min[0])/65535,(max[1]-min[1])/65535],scale);const decodeMat=math.mulMat3(translate,scale,math.identityMat3());return{quantized:quantized,decode:decodeMat}}})();function octEncode(array){const encoded=new Int8Array(array.length*2/3);let oct,dec,best,currentCos,bestCos;let i,ei;for(i=0,ei=0;i<array.length;i+=3,ei+=2){best=oct=octEncodeVec3(array,i,"floor","floor");dec=octDecodeVec2(oct);currentCos=bestCos=dot(array,i,dec);oct=octEncodeVec3(array,i,"ceil","floor");dec=octDecodeVec2(oct);currentCos=dot(array,i,dec);if(currentCos>bestCos){best=oct;bestCos=currentCos}
oct=octEncodeVec3(array,i,"floor","ceil");dec=octDecodeVec2(oct);currentCos=dot(array,i,dec);if(currentCos>bestCos){best=oct;bestCos=currentCos}
oct=octEncodeVec3(array,i,"ceil","ceil");dec=octDecodeVec2(oct);currentCos=dot(array,i,dec);if(currentCos>bestCos){best=oct;bestCos=currentCos}
encoded[ei]=best[0];encoded[ei+1]=best[1]}
return encoded}
function octEncodeVec3(array,i,xfunc,yfunc){let x=array[i]/(Math.abs(array[i])+Math.abs(array[i+1])+Math.abs(array[i+2]));let y=array[i+1]/(Math.abs(array[i])+Math.abs(array[i+1])+Math.abs(array[i+2]));if(array[i+2]<0){let tempx=x;let tempy=y;tempx=(1-Math.abs(y))*(x>=0?1:-1);tempy=(1-Math.abs(x))*(y>=0?1:-1);x=tempx;y=tempy}
return new Int8Array([Math[xfunc](x*127.5+(x<0?-1:0)),Math[yfunc](y*127.5+(y<0?-1:0))])}
function octDecodeVec2(oct){let x=oct[0];let y=oct[1];x/=x<0?127:128;y/=y<0?127:128;const z=1-Math.abs(x)-Math.abs(y);if(z<0){x=(1-Math.abs(y))*(x>=0?1:-1);y=(1-Math.abs(x))*(y>=0?1:-1)}
const length=Math.sqrt(x*x+y*y+z*z);return[x/length,y/length,z/length]}
function dot(array,i,vec3){return array[i]*vec3[0]+array[i+1]*vec3[1]+array[i+2]*vec3[2]}
var buildEdgesIndices=(function(){const uniquePositions=[];const indicesLookup=[];const indicesReverseLookup=[];const weldedIndices=[];function weldVertices(positions,indices){const positionsMap={};let vx;let vy;let vz;let key;const precisionPoints=4;const precision=Math.pow(10,precisionPoints);let i;let len;let lenUniquePositions=0;for(i=0,len=positions.length;i<len;i+=3){vx=positions[i];vy=positions[i+1];vz=positions[i+2];key=Math.round(vx*precision)+'_'+Math.round(vy*precision)+'_'+Math.round(vz*precision);if(positionsMap[key]===undefined){positionsMap[key]=lenUniquePositions/3;uniquePositions[lenUniquePositions++]=vx;uniquePositions[lenUniquePositions++]=vy;uniquePositions[lenUniquePositions++]=vz}
indicesLookup[i/3]=positionsMap[key]}
for(i=0,len=indices.length;i<len;i++){weldedIndices[i]=indicesLookup[indices[i]];indicesReverseLookup[weldedIndices[i]]=indices[i]}}
const faces=[];let numFaces=0;const compa=new Uint16Array(3);const compb=new Uint16Array(3);const compc=new Uint16Array(3);const a=math.vec3();const b=math.vec3();const c=math.vec3();const cb=math.vec3();const ab=math.vec3();const cross=math.vec3();const normal=math.vec3();function buildFaces(numIndices,positionsDecodeMatrix){numFaces=0;for(let i=0,len=numIndices;i<len;i+=3){const ia=((weldedIndices[i])*3);const ib=((weldedIndices[i+1])*3);const ic=((weldedIndices[i+2])*3);if(positionsDecodeMatrix){compa[0]=uniquePositions[ia];compa[1]=uniquePositions[ia+1];compa[2]=uniquePositions[ia+2];compb[0]=uniquePositions[ib];compb[1]=uniquePositions[ib+1];compb[2]=uniquePositions[ib+2];compc[0]=uniquePositions[ic];compc[1]=uniquePositions[ic+1];compc[2]=uniquePositions[ic+2];math.decompressPosition(compa,positionsDecodeMatrix,a);math.decompressPosition(compb,positionsDecodeMatrix,b);math.decompressPosition(compc,positionsDecodeMatrix,c)}else{a[0]=uniquePositions[ia];a[1]=uniquePositions[ia+1];a[2]=uniquePositions[ia+2];b[0]=uniquePositions[ib];b[1]=uniquePositions[ib+1];b[2]=uniquePositions[ib+2];c[0]=uniquePositions[ic];c[1]=uniquePositions[ic+1];c[2]=uniquePositions[ic+2]}
math.subVec3(c,b,cb);math.subVec3(a,b,ab);math.cross3Vec3(cb,ab,cross);math.normalizeVec3(cross,normal);const face=faces[numFaces]||(faces[numFaces]={normal:math.vec3()});face.normal[0]=normal[0];face.normal[1]=normal[1];face.normal[2]=normal[2];numFaces++}}
return function(positions,indices,positionsDecodeMatrix,edgeThreshold,combined){weldVertices(positions,indices);buildFaces(indices.length,positionsDecodeMatrix);const edgeIndices=[];const thresholdDot=Math.cos(math.DEGTORAD*edgeThreshold);const edges={};let edge1;let edge2;let index1;let index2;let key;let largeIndex=!1;let edge;let normal1;let normal2;let dot;let ia;let ib;for(let i=0,len=indices.length;i<len;i+=3){const faceIndex=i/3;for(let j=0;j<3;j++){edge1=weldedIndices[i+j];edge2=weldedIndices[i+((j+1)%3)];index1=Math.min(edge1,edge2);index2=Math.max(edge1,edge2);key=index1+","+index2;if(edges[key]===undefined){edges[key]={index1:index1,index2:index2,face1:faceIndex,face2:undefined}}else{edges[key].face2=faceIndex}}}
for(key in edges){edge=edges[key];if(edge.face2!==undefined){normal1=faces[edge.face1].normal;normal2=faces[edge.face2].normal;dot=math.dotVec3(normal1,normal2);if(dot>thresholdDot){continue}}
ia=indicesReverseLookup[edge.index1];ib=indicesReverseLookup[edge.index2];if(!largeIndex&&ia>65535||ib>65535){largeIndex=!0}
edgeIndices.push(ia);edgeIndices.push(ib)}
return(largeIndex||combined)?new Uint32Array(edgeIndices):new Uint16Array(edgeIndices)}})();componentClasses[type$3]=Geometry;const type$4="xeogl.AABBGeometry";class AABBGeometry extends Geometry{get type(){return type$4}
init(cfg){super.init(utils.apply(cfg,{combined:!0,quantized:!0,primitive:cfg.primitive||"lines",indices:[0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7],positions:cfg.positions||[1.0,1.0,1.0,1.0,-1.0,1.0,-1.0,-1.0,1.0,-1.0,1.0,1.0,1.0,1.0,-1.0,1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,1.0,-1.0]}));if(cfg.target){this.target=cfg.target}else if(cfg.targetAABB){this.targetAABB=cfg.targetAABB}}
set target(target){let geometryDirty=!1;const self=this;this._attach({name:"target",type:"xeogl.Component",component:target,sceneDefault:!1,on:{boundary:function(){if(geometryDirty){return}
geometryDirty=!0;tasks.scheduleTask(function(){self._setPositionsFromAABB(self._attached.target.aabb);geometryDirty=!1})}},onAttached:function(){self._setPositionsFromAABB(self._attached.target.aabb)}})}
get target(){return this._attached.target}
set targetAABB(aabb){if(!aabb){return}
if(this._attached.target){this.target=null}
this._setPositionsFromAABB(aabb)}
_setPositionsFromAABB(aabb){this.positions=[aabb[3],aabb[4],aabb[5],aabb[3],aabb[1],aabb[5],aabb[0],aabb[1],aabb[5],aabb[0],aabb[4],aabb[5],aabb[3],aabb[4],aabb[2],aabb[3],aabb[1],aabb[2],aabb[0],aabb[1],aabb[2],aabb[0],aabb[4],aabb[2]]}}
componentClasses[type$4]=AABBGeometry;const type$5="xeogl.Material";class Material extends Component{get type(){return type$5}
init(cfg){super.init(cfg);stats.memory.materials++}
destroy(){super.destroy();stats.memory.materials--}}
componentClasses[type$5]=Material;const type$6="xeogl.PhongMaterial";const alphaModes={"opaque":0,"mask":1,"blend":2};const alphaModeNames=["opaque","mask","blend"];class PhongMaterial extends Material{get type(){return type$6}
init(cfg){super.init(cfg);this._state=new State({type:"PhongMaterial",ambient:math.vec3([1.0,1.0,1.0]),diffuse:math.vec3([1.0,1.0,1.0]),specular:math.vec3([1.0,1.0,1.0]),emissive:math.vec3([0.0,0.0,0.0]),alpha:null,shininess:null,reflectivity:null,alphaMode:null,alphaCutoff:null,lineWidth:null,pointSize:null,backfaces:null,frontface:null,hash:null});this.ambient=cfg.ambient;this.diffuse=cfg.diffuse;this.specular=cfg.specular;this.emissive=cfg.emissive;this.alpha=cfg.alpha;this.shininess=cfg.shininess;this.reflectivity=cfg.reflectivity;this.lineWidth=cfg.lineWidth;this.pointSize=cfg.pointSize;if(cfg.ambientMap){this._ambientMap=this._checkComponent("xeogl.Texture",cfg.ambientMap)}
if(cfg.diffuseMap){this._diffuseMap=this._checkComponent("xeogl.Texture",cfg.diffuseMap)}
if(cfg.specularMap){this._specularMap=this._checkComponent("xeogl.Texture",cfg.specularMap)}
if(cfg.emissiveMap){this._emissiveMap=this._checkComponent("xeogl.Texture",cfg.emissiveMap)}
if(cfg.alphaMap){this._alphaMap=this._checkComponent("xeogl.Texture",cfg.alphaMap)}
if(cfg.reflectivityMap){this._reflectivityMap=this._checkComponent("xeogl.Texture",cfg.reflectivityMap)}
if(cfg.normalMap){this._normalMap=this._checkComponent("xeogl.Texture",cfg.normalMap)}
if(cfg.occlusionMap){this._occlusionMap=this._checkComponent("xeogl.Texture",cfg.occlusionMap)}
if(cfg.diffuseFresnel){this._diffuseFresnel=this._checkComponent("xeogl.Fresnel",cfg.diffuseFresnel)}
if(cfg.specularFresnel){this._specularFresnel=this._checkComponent("xeogl.Fresnel",cfg.specularFresnel)}
if(cfg.emissiveFresnel){this._emissiveFresnel=this._checkComponent("xeogl.Fresnel",cfg.emissiveFresnel)}
if(cfg.alphaFresnel){this._alphaFresnel=this._checkComponent("xeogl.Fresnel",cfg.alphaFresnel)}
if(cfg.reflectivityFresnel){this._reflectivityFresnel=this._checkComponent("xeogl.Fresnel",cfg.reflectivityFresnel)}
this.alphaMode=cfg.alphaMode;this.alphaCutoff=cfg.alphaCutoff;this.backfaces=cfg.backfaces;this.frontface=cfg.frontface;this._makeHash()}
_makeHash(){const state=this._state;const hash=["/p"];if(this._normalMap){hash.push("/nm");if(this._normalMap.hasMatrix){hash.push("/mat")}}
if(this._ambientMap){hash.push("/am");if(this._ambientMap.hasMatrix){hash.push("/mat")}
hash.push("/"+this._ambientMap.encoding)}
if(this._diffuseMap){hash.push("/dm");if(this._diffuseMap.hasMatrix){hash.push("/mat")}
hash.push("/"+this._diffuseMap.encoding)}
if(this._specularMap){hash.push("/sm");if(this._specularMap.hasMatrix){hash.push("/mat")}}
if(this._emissiveMap){hash.push("/em");if(this._emissiveMap.hasMatrix){hash.push("/mat")}
hash.push("/"+this._emissiveMap.encoding)}
if(this._alphaMap){hash.push("/opm");if(this._alphaMap.hasMatrix){hash.push("/mat")}}
if(this._reflectivityMap){hash.push("/rm");if(this._reflectivityMap.hasMatrix){hash.push("/mat")}}
if(this._occlusionMap){hash.push("/ocm");if(this._occlusionMap.hasMatrix){hash.push("/mat")}}
if(this._diffuseFresnel){hash.push("/df")}
if(this._specularFresnel){hash.push("/sf")}
if(this._emissiveFresnel){hash.push("/ef")}
if(this._alphaFresnel){hash.push("/of")}
if(this._reflectivityFresnel){hash.push("/rf")}
hash.push(";");state.hash=hash.join("")}
set ambient(value){let ambient=this._state.ambient;if(!ambient){ambient=this._state.ambient=new Float32Array(3)}else if(value&&ambient[0]===value[0]&&ambient[1]===value[1]&&ambient[2]===value[2]){return}
if(value){ambient[0]=value[0];ambient[1]=value[1];ambient[2]=value[2]}else{ambient[0]=.2;ambient[1]=.2;ambient[2]=.2}
this._renderer.imageDirty()}
get ambient(){return this._state.ambient}
set diffuse(value){let diffuse=this._state.diffuse;if(!diffuse){diffuse=this._state.diffuse=new Float32Array(3)}else if(value&&diffuse[0]===value[0]&&diffuse[1]===value[1]&&diffuse[2]===value[2]){return}
if(value){diffuse[0]=value[0];diffuse[1]=value[1];diffuse[2]=value[2]}else{diffuse[0]=1;diffuse[1]=1;diffuse[2]=1}
this._renderer.imageDirty()}
get diffuse(){return this._state.diffuse}
set specular(value){let specular=this._state.specular;if(!specular){specular=this._state.specular=new Float32Array(3)}else if(value&&specular[0]===value[0]&&specular[1]===value[1]&&specular[2]===value[2]){return}
if(value){specular[0]=value[0];specular[1]=value[1];specular[2]=value[2]}else{specular[0]=1;specular[1]=1;specular[2]=1}
this._renderer.imageDirty()}
get specular(){return this._state.specular}
set emissive(value){let emissive=this._state.emissive;if(!emissive){emissive=this._state.emissive=new Float32Array(3)}else if(value&&emissive[0]===value[0]&&emissive[1]===value[1]&&emissive[2]===value[2]){return}
if(value){emissive[0]=value[0];emissive[1]=value[1];emissive[2]=value[2]}else{emissive[0]=0;emissive[1]=0;emissive[2]=0}
this._renderer.imageDirty()}
get emissive(){return this._state.emissive}
set alpha(value){value=(value!==undefined&&value!==null)?value:1.0;if(this._state.alpha===value){return}
this._state.alpha=value;this._renderer.imageDirty()}
get alpha(){return this._state.alpha}
set shininess(value){this._state.shininess=value!==undefined?value:80;this._renderer.imageDirty()}
get shininess(){return this._state.shininess}
set lineWidth(value){this._state.lineWidth=value||1.0;this._renderer.imageDirty()}
get lineWidth(){return this._state.lineWidth}
set pointSize(value){this._state.pointSize=value||1.0;this._renderer.imageDirty()}
get pointSize(){return this._state.pointSize}
set reflectivity(value){this._state.reflectivity=value!==undefined?value:1.0;this._renderer.imageDirty()}
get reflectivity(){return this._state.reflectivity}
get normalMap(){return this._normalMap}
get ambientMap(){return this._ambientMap}
get diffuseMap(){return this._diffuseMap}
get specularMap(){return this._specularMap}
get emissiveMap(){return this._emissiveMap}
get alphaMap(){return this._alphaMap}
get reflectivityMap(){return this._reflectivityMap}
get occlusionMap(){return this._occlusionMap}
get diffuseFresnel(){return this._diffuseFresnel}
get specularFresnel(){return this._specularFresnel}
get emissiveFresnel(){return this._emissiveFresnel}
get alphaFresnel(){return this._alphaFresnel}
get reflectivityFresnel(){return this._reflectivityFresnel}
set alphaMode(alphaMode){alphaMode=alphaMode||"opaque";let value=alphaModes[alphaMode];if(value===undefined){this.error("Unsupported value for 'alphaMode': "+alphaMode+" - defaulting to 'opaque'");value="opaque"}
if(this._state.alphaMode===value){return}
this._state.alphaMode=value;this._renderer.imageDirty()}
get alphaMode(){return alphaModeNames[this._state.alphaMode]}
set alphaCutoff(alphaCutoff){if(alphaCutoff===null||alphaCutoff===undefined){alphaCutoff=0.5}
if(this._state.alphaCutoff===alphaCutoff){return}
this._state.alphaCutoff=alphaCutoff}
get alphaCutoff(){return this._state.alphaCutoff}
set backfaces(value){value=!!value;if(this._state.backfaces===value){return}
this._state.backfaces=value;this._renderer.imageDirty()}
get backfaces(){return this._state.backfaces}
set frontface(value){value=value!=="cw";if(this._state.frontface===value){return}
this._state.frontface=value;this._renderer.imageDirty()}
get frontface(){return this._state.frontface?"ccw":"cw"}
destroy(){super.destroy();this._state.destroy()}}
componentClasses[type$6]=PhongMaterial;const type$7="xeogl.Object";const angleAxis=new Float32Array(4);const q1=new Float32Array(4);const q2=new Float32Array(4);const xAxis=new Float32Array([1,0,0]);const yAxis=new Float32Array([0,1,0]);const zAxis=new Float32Array([0,0,1]);const veca=new Float32Array(3);const vecb=new Float32Array(3);const identityMat=math.identityMat4();class xeoglObject extends Component{get type(){return type$7}
init(cfg){super.init(cfg);this._guid=cfg.guid;this._parent=null;this._childList=[];this._childMap={};this._childIDs=null;this._aabb=null;this._aabbDirty=!0;this.scene._aabbDirty=!0;this._scale=math.vec3();this._quaternion=math.identityQuaternion();this._rotation=math.vec3();this._position=math.vec3();this._worldMatrix=math.identityMat4();this._worldNormalMatrix=math.identityMat4();this._localMatrixDirty=!0;this._worldMatrixDirty=!0;this._worldNormalMatrixDirty=!0;if(cfg.matrix){this.matrix=cfg.matrix}else{this.scale=cfg.scale;this.position=cfg.position;if(cfg.quaternion){}else{this.rotation=cfg.rotation}}
if(cfg.entityType){this._entityType=cfg.entityType;this.scene._entityTypeAssigned(this,this._entityType)}
this.visible=cfg.visible;this.culled=cfg.culled;this.pickable=cfg.pickable;this.clippable=cfg.clippable;this.collidable=cfg.collidable;this.castShadow=cfg.castShadow;this.receiveShadow=cfg.receiveShadow;this.outlined=cfg.outlined;this.solid=cfg.solid;this.ghosted=cfg.ghosted;this.highlighted=cfg.highlighted;this.selected=cfg.selected;this.edges=cfg.edges;this.aabbVisible=cfg.aabbVisible;this.layer=cfg.layer;this.colorize=cfg.colorize;this.opacity=cfg.opacity;if(cfg.children){const children=cfg.children;for(let i=0,len=children.length;i<len;i++){this.addChild(children[i],cfg.inheritStates)}}
if(cfg.parent){cfg.parent.addChild(this)}
this.scene._objectCreated(this)}
_setLocalMatrixDirty(){this._localMatrixDirty=!0;this._setWorldMatrixDirty()}
_setWorldMatrixDirty(){this._worldMatrixDirty=!0;this._worldNormalMatrixDirty=!0;if(this._childList){for(let i=0,len=this._childList.length;i<len;i++){this._childList[i]._setWorldMatrixDirty()}}}
_buildWorldMatrix(){const localMatrix=this.matrix;if(!this._parent){for(let i=0,len=localMatrix.length;i<len;i++){this._worldMatrix[i]=localMatrix[i]}}else{math.mulMat4(this._parent.worldMatrix,localMatrix,this._worldMatrix)}
this._worldMatrixDirty=!1}
_buildWorldNormalMatrix(){if(this._worldMatrixDirty){this._buildWorldMatrix()}
if(!this._worldNormalMatrix){this._worldNormalMatrix=math.mat4()}
math.inverseMat4(this._worldMatrix,this._worldNormalMatrix);math.transposeMat4(this._worldNormalMatrix);this._worldNormalMatrixDirty=!1}
_setSubtreeAABBsDirty(object){object._aabbDirty=!0;object.fire("boundary",!0);if(object._childList){for(let i=0,len=object._childList.length;i<len;i++){this._setSubtreeAABBsDirty(object._childList[i])}}}
_setAABBDirty(){this._setSubtreeAABBsDirty(this);if(this.collidable){for(let object=this;object;object=object._parent){object._aabbDirty=!0;object.fire("boundary",!0)}}}
_updateAABB(){this.scene._aabbDirty=!0;if(!this._aabb){this._aabb=math.AABB3()}
if(this._buildMeshAABB){this._buildMeshAABB(this.worldMatrix,this._aabb)}else{math.collapseAABB3(this._aabb);let object;for(let i=0,len=this._childList.length;i<len;i++){object=this._childList[i];if(!object.collidable){continue}
math.expandAABB3(this._aabb,object.aabb)}}
if(!this._aabbCenter){this._aabbCenter=new Float32Array(3)}
math.getAABB3Center(this._aabb,this._aabbCenter);this._aabbDirty=!1}
addChild(object,inheritStates){if(utils.isNumeric(object)||utils.isString(object)){const objectId=object;object=this.scene.objects[objectId];if(!object){this.warn("Object not found: "+utils.inQuotes(objectId));return}}else if(utils.isObject(object)){throw "addChild( * ) not implemented";if(!object){return}}else{if(!object.isType("xeogl.Object")){this.error("Not a xeogl.Object: "+object.id);return}
if(object._parent){if(object._parent.id===this.id){this.warn("Already a child object: "+object.id);return}
object._parent.removeChild(object)}}
const id=object.id;if(object.scene.id!==this.scene.id){this.error("Object not in same Scene: "+object.id);return}
delete this.scene.rootObjects[object.id];this._childList.push(object);this._childMap[object.id]=object;this._childIDs=null;object._parent=this;if(!!inheritStates){object.visible=this.visible;object.culled=this.culled;object.ghosted=this.ghosted;object.highlited=this.highlighted;object.selected=this.selected;object.edges=this.edges;object.outlined=this.outlined;object.clippable=this.clippable;object.pickable=this.pickable;object.collidable=this.collidable;object.castShadow=this.castShadow;object.receiveShadow=this.receiveShadow;object.colorize=this.colorize;object.opacity=this.opacity}
object._setWorldMatrixDirty();object._setAABBDirty();return object}
removeChild(object){for(let i=0,len=this._childList.length;i<len;i++){if(this._childList[i].id===object.id){object._parent=null;this._childList=this._childList.splice(i,1);delete this._childMap[object.id];this._childIDs=null;this.scene.rootObjects[object.id]=object;object._setWorldMatrixDirty();object._setAABBDirty();this._setAABBDirty();return}}}
removeChildren(){let object;for(let i=0,len=this._childList.length;i<len;i++){object=this._childList[i];object._parent=null;this.scene.rootObjects[object.id]=object;object._setWorldMatrixDirty();object._setAABBDirty()}
this._childList=[];this._childMap={};this._childIDs=null;this._setAABBDirty()}
rotate(axis,angle){angleAxis[0]=axis[0];angleAxis[1]=axis[1];angleAxis[2]=axis[2];angleAxis[3]=angle*math.DEGTORAD;math.angleAxisToQuaternion(angleAxis,q1);math.mulQuaternions(this.quaternion,q1,q2);this.quaternion=q2;this._setLocalMatrixDirty();this._setAABBDirty();this._renderer.imageDirty();return this}
rotateOnWorldAxis(axis,angle){angleAxis[0]=axis[0];angleAxis[1]=axis[1];angleAxis[2]=axis[2];angleAxis[3]=angle*math.DEGTORAD;math.angleAxisToQuaternion(angleAxis,q1);math.mulQuaternions(q1,this.quaternion,q1);return this}
rotateX(angle){return this.rotate(xAxis,angle)}
rotateY(angle){return this.rotate(yAxis,angle)}
rotateZ(angle){return this.rotate(zAxis,angle)}
translate(axis,distance){math.vec3ApplyQuaternion(this.quaternion,axis,veca);math.mulVec3Scalar(veca,distance,vecb);math.addVec3(this.position,vecb,this.position);this._setLocalMatrixDirty();this._setAABBDirty();this._renderer.imageDirty();return this}
translateX(distance){return this.translate(xAxis,distance)}
translateY(distance){return this.translate(yAxis,distance)}
translateZ(distance){return this.translate(zAxis,distance)}
get guid(){return this._guid}
get entityType(){return this._entityType}
get numChildren(){return this._childList.length}
get children(){return this._childList}
get childMap(){return this._childMap}
get childIDs(){if(!this._childIDs){this._childIDs=Object.keys(this._childMap)}
return this._childIDs}
set parent(object){if(utils.isNumeric(object)||utils.isString(object)){const objectId=object;object=this.scene.objects[objectId];if(!object){this.warn("Group not found: "+utils.inQuotes(objectId));return}}
if(object.scene.id!==this.scene.id){this.error("Group not in same Scene: "+object.id);return}
if(this._parent&&this._parent.id===object.id){this.warn("Already a child of Group: "+object.id);return}
object.addChild(this)}
get parent(){return this._parent}
set position(value){this._position.set(value||[0,0,0]);this._setLocalMatrixDirty();this._setAABBDirty();this._renderer.imageDirty()}
get position(){return this._position}
set rotation(value){this._rotation.set(value||[0,0,0]);math.eulerToQuaternion(this._rotation,"XYZ",this._quaternion);this._setLocalMatrixDirty();this._setAABBDirty();this._renderer.imageDirty()}
get rotation(){return this._rotation}
set quaternion(value){this._quaternion.set(value||[0,0,0,1]);math.quaternionToEuler(this._quaternion,"XYZ",this._rotation);this._setLocalMatrixDirty();this._setAABBDirty();this._renderer.imageDirty()}
get quaternion(){return this._quaternion}
set scale(value){this._scale.set(value||[1,1,1]);this._setLocalMatrixDirty();this._setAABBDirty();this._renderer.imageDirty()}
get scale(){return this._scale}
set matrix(value){if(!this.__localMatrix){this.__localMatrix=math.identityMat4()}
this.__localMatrix.set(value||identityMat);math.decomposeMat4(this.__localMatrix,this._position,this._quaternion,this._scale);this._localMatrixDirty=!1;this._setWorldMatrixDirty();this._setAABBDirty();this._renderer.imageDirty()}
get matrix(){if(this._localMatrixDirty){if(!this.__localMatrix){this.__localMatrix=math.identityMat4()}
math.composeMat4(this._position,this._quaternion,this._scale,this.__localMatrix);this._localMatrixDirty=!1}
return this.__localMatrix}
get worldMatrix(){if(this._worldMatrixDirty){this._buildWorldMatrix()}
return this._worldMatrix}
get worldNormalMatrix(){if(this._worldNormalMatrixDirty){this._buildWorldNormalMatrix()}
return this._worldNormalMatrix}
get aabb(){if(this._aabbDirty){this._updateAABB()}
return this._aabb}
get center(){if(this._aabbDirty){this._updateAABB()}
return this._aabbCenter}
set visible(visible){visible=visible!==!1;this._visible=visible;for(let i=0,len=this._childList.length;i<len;i++){this._childList[i].visible=visible}
if(this._entityType){this.scene._entityVisibilityUpdated(this,visible)}}
get visible(){return this._visible}
set highlighted(highlighted){highlighted=!!highlighted;this._highlighted=highlighted;for(let i=0,len=this._childList.length;i<len;i++){this._childList[i].highlighted=highlighted}
if(this._entityType){this.scene._entityHighlightedUpdated(this,highlighted)}}
get highlighted(){return this._highlighted}
set ghosted(ghosted){ghosted=!!ghosted;this._ghosted=ghosted;for(let i=0,len=this._childList.length;i<len;i++){this._childList[i].ghosted=ghosted}
if(this._entityType){this.scene._entityGhostedUpdated(this,ghosted)}}
get ghosted(){return this._ghosted}
set selected(selected){selected=!!selected;this._selected=selected;for(let i=0,len=this._childList.length;i<len;i++){this._childList[i].selected=selected}
if(this._entityType){this.scene._entitySelectedUpdated(this,selected)}}
get selected(){return this._selected}
set edges(edges){edges=!!edges;this._edges=edges;for(let i=0,len=this._childList.length;i<len;i++){this._childList[i].edges=edges}}
get edges(){return this._edges}
set culled(culled){culled=!!culled;this._culled=culled;for(let i=0,len=this._childList.length;i<len;i++){this._childList[i].culled=culled}}
get culled(){return this._culled}
set clippable(clippable){clippable=clippable!==!1;this._clippable=clippable;for(let i=0,len=this._childList.length;i<len;i++){this._childList[i].clippable=clippable}}
get clippable(){return this._clippable}
set collidable(collidable){collidable=collidable!==!1;this._collidable=collidable;for(let i=0,len=this._childList.length;i<len;i++){this._childList[i].collidable=collidable}}
get collidable(){return this._collidable}
set pickable(pickable){pickable=pickable!==!1;this._pickable=pickable;for(let i=0,len=this._childList.length;i<len;i++){this._childList[i].pickable=pickable}}
get pickable(){return this._pickable}
set colorize(rgb){let colorize=this._colorize;if(!colorize){colorize=this._colorize=new Float32Array(4);colorize[3]=1.0}
if(rgb){colorize[0]=rgb[0];colorize[1]=rgb[1];colorize[2]=rgb[2]}else{colorize[0]=1;colorize[1]=1;colorize[2]=1}
for(let i=0,len=this._childList.length;i<len;i++){this._childList[i].colorize=colorize}}
get colorize(){return this._colorize.slice(0,3)}
set opacity(opacity){let colorize=this._colorize;if(!colorize){colorize=this._colorize=new Float32Array(4);colorize[0]=1;colorize[1]=1;colorize[2]=1}
colorize[3]=opacity!==null&&opacity!==undefined?opacity:1.0;for(let i=0,len=this._childList.length;i<len;i++){this._childList[i].opacity=opacity}}
get opacity(){return this._colorize[3]}
set outlined(outlined){outlined=!!outlined;this._outlined=outlined;for(let i=0,len=this._childList.length;i<len;i++){this._childList[i].outlined=outlined}}
get outlined(){return this._outlined}
set castShadow(castShadow){castShadow=!!castShadow;this._castShadow=castShadow;for(let i=0,len=this._childList.length;i<len;i++){this._childList[i].castShadow=castShadow}}
get castShadow(){return this._castShadow}
set receiveShadow(receiveShadow){receiveShadow=!!receiveShadow;this._receiveShadow=receiveShadow;for(let i=0,len=this._childList.length;i<len;i++){this._childList[i].receiveShadow=receiveShadow}}
get receiveShadow(){return this._receiveShadow}
set aabbVisible(visible){if(!visible&&!this._aabbHelper){return}
if(!this._aabbHelper){this._aabbHelper=new Mesh(this,{geometry:new AABBGeometry(this,{target:this}),material:new PhongMaterial(this,{diffuse:[0.5,1.0,0.5],emissive:[0.5,1.0,0.5],lineWidth:2})})}
this._aabbHelper.visible=visible}
get aabbVisible(){return this._aabbHelper?this._aabbHelper.visible:!1}
destroy(){super.destroy();if(this._parent){this._parent.removeChild(this)}
if(this._entityType){const scene=this.scene;scene._entityTypeRemoved(this,this._entityType);if(this._visible){scene._entityVisibilityUpdated(this,!1)}
if(this._ghosted){scene._entityGhostedUpdated(this,!1)}
if(this._selected){scene._entitySelectedUpdated(this,!1)}
if(this._highlighted){scene._entityHighlightedUpdated(this,!1)}}
if(this._childList.length){const tempChildList=this._childList.splice();let object;for(let i=0,len=tempChildList.length;i<len;i++){object=tempChildList[i];object.destroy()}}
this._childList=[];this._childMap={};this._childIDs=null;this._setAABBDirty();this.scene._aabbDirty=!0;this.scene._objectDestroyed(this)}}
componentClasses[type$7]=xeoglObject;const DrawShaderSource=function(mesh){if(mesh._material._state.type==="LambertMaterial"){this.vertex=buildVertexLambert(mesh);this.fragment=buildFragmentLambert(mesh)}else{this.vertex=buildVertexDraw(mesh);this.fragment=buildFragmentDraw(mesh)}};const TEXTURE_DECODE_FUNCS={"linear":"linearToLinear","sRGB":"sRGBToLinear","gamma":"gammaToLinear"};function receivesShadow(mesh){if(!mesh._state.receiveShadow){return!1}
const lights=mesh.scene._lightsState.lights;if(!lights||lights.length===0){return!1}
for(let i=0,len=lights.length;i<len;i++){if(lights[i].shadow){return!0}}
return!1}
function hasTextures(mesh){if(!mesh._geometry._state.uv){return!1}
const material=mesh._material;return!!(material._ambientMap||material._occlusionMap||material._baseColorMap||material._diffuseMap||material._alphaMap||material._specularMap||material._glossinessMap||material._specularGlossinessMap||material._emissiveMap||material._metallicMap||material._roughnessMap||material._metallicRoughnessMap||material._reflectivityMap||material._normalMap)}
function hasNormals(mesh){const primitive=mesh._geometry._state.primitiveName;if((mesh._geometry._state.autoVertexNormals||mesh._geometry._state.normals)&&(primitive==="triangles"||primitive==="triangle-strip"||primitive==="triangle-fan")){return!0}
return!1}
function getFragmentFloatPrecision(gl){if(!gl.getShaderPrecisionFormat){return"mediump"}
if(gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER,gl.HIGH_FLOAT).precision>0){return"highp"}
if(gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER,gl.MEDIUM_FLOAT).precision>0){return"mediump"}
return"lowp"}
function buildVertexLambert(mesh){const clipsState=mesh.scene._clipsState;const lightsState=mesh.scene._lightsState;const geometryState=mesh._geometry._state;const billboard=mesh._state.billboard;const stationary=mesh._state.stationary;const clipping=clipsState.clips.length>0;const quantizedGeometry=!!geometryState.quantized;let i;let len;let light;const src=[];src.push("// Lambertian drawing vertex shader");src.push("attribute vec3 position;");src.push("uniform mat4 modelMatrix;");src.push("uniform mat4 viewMatrix;");src.push("uniform mat4 projMatrix;");src.push("uniform vec4 colorize;");if(quantizedGeometry){src.push("uniform mat4 positionsDecodeMatrix;")}
if(clipping){src.push("varying vec4 vWorldPosition;")}
src.push("uniform vec4 lightAmbient;");src.push("uniform vec4 materialColor;");if(geometryState.normals){src.push("attribute vec3 normal;");src.push("uniform mat4 modelNormalMatrix;");src.push("uniform mat4 viewNormalMatrix;");for(i=0,len=lightsState.lights.length;i<len;i++){light=lightsState.lights[i];if(light.type==="ambient"){continue}
src.push("uniform vec4 lightColor"+i+";");if(light.type==="dir"){src.push("uniform vec3 lightDir"+i+";")}
if(light.type==="point"){src.push("uniform vec3 lightPos"+i+";")}
if(light.type==="spot"){src.push("uniform vec3 lightPos"+i+";");src.push("uniform vec3 lightDir"+i+";")}}
if(quantizedGeometry){src.push("vec3 octDecode(vec2 oct) {");src.push("    vec3 v = vec3(oct.xy, 1.0 - abs(oct.x) - abs(oct.y));");src.push("    if (v.z < 0.0) {");src.push("        v.xy = (1.0 - abs(v.yx)) * vec2(v.x >= 0.0 ? 1.0 : -1.0, v.y >= 0.0 ? 1.0 : -1.0);");src.push("    }");src.push("    return normalize(v);");src.push("}")}}
src.push("varying vec4 vColor;");if(geometryState.primitiveName==="points"){src.push("uniform float pointSize;")}
if(billboard==="spherical"||billboard==="cylindrical"){src.push("void billboard(inout mat4 mat) {");src.push("   mat[0][0] = 1.0;");src.push("   mat[0][1] = 0.0;");src.push("   mat[0][2] = 0.0;");if(billboard==="spherical"){src.push("   mat[1][0] = 0.0;");src.push("   mat[1][1] = 1.0;");src.push("   mat[1][2] = 0.0;")}
src.push("   mat[2][0] = 0.0;");src.push("   mat[2][1] = 0.0;");src.push("   mat[2][2] =1.0;");src.push("}")}
src.push("void main(void) {");src.push("vec4 localPosition = vec4(position, 1.0); ");src.push("vec4 worldPosition;");if(quantizedGeometry){src.push("localPosition = positionsDecodeMatrix * localPosition;")}
if(geometryState.normals){if(quantizedGeometry){src.push("vec4 localNormal = vec4(octDecode(normal.xy), 0.0); ")}else{src.push("vec4 localNormal = vec4(normal, 0.0); ")}
src.push("mat4 modelNormalMatrix2 = modelNormalMatrix;");src.push("mat4 viewNormalMatrix2 = viewNormalMatrix;")}
src.push("mat4 viewMatrix2 = viewMatrix;");src.push("mat4 modelMatrix2 = modelMatrix;");if(stationary){src.push("viewMatrix2[3][0] = viewMatrix2[3][1] = viewMatrix2[3][2] = 0.0;")}
if(billboard==="spherical"||billboard==="cylindrical"){src.push("mat4 modelViewMatrix = viewMatrix2 * modelMatrix2;");src.push("billboard(modelMatrix2);");src.push("billboard(viewMatrix2);");src.push("billboard(modelViewMatrix);");if(geometryState.normals){src.push("mat4 modelViewNormalMatrix =  viewNormalMatrix2 * modelNormalMatrix2;");src.push("billboard(modelNormalMatrix2);");src.push("billboard(viewNormalMatrix2);");src.push("billboard(modelViewNormalMatrix);")}
src.push("worldPosition = modelMatrix2 * localPosition;");src.push("vec4 viewPosition = modelViewMatrix * localPosition;")}else{src.push("worldPosition = modelMatrix2 * localPosition;");src.push("vec4 viewPosition  = viewMatrix2 * worldPosition; ")}
if(geometryState.normals){src.push("vec3 viewNormal = normalize((viewNormalMatrix2 * modelNormalMatrix2 * localNormal).xyz);")}
src.push("vec3 reflectedColor = vec3(0.0, 0.0, 0.0);");src.push("vec3 viewLightDir = vec3(0.0, 0.0, -1.0);");src.push("float lambertian = 1.0;");if(geometryState.normals){for(i=0,len=lightsState.lights.length;i<len;i++){light=lightsState.lights[i];if(light.type==="ambient"){continue}
if(light.type==="dir"){if(light.space==="view"){src.push("viewLightDir = normalize(lightDir"+i+");")}else{src.push("viewLightDir = normalize((viewMatrix2 * vec4(lightDir"+i+", 0.0)).xyz);")}}else if(light.type==="point"){if(light.space==="view"){src.push("viewLightDir = normalize(lightPos"+i+" - viewPosition.xyz);")}else{src.push("viewLightDir = normalize((viewMatrix2 * vec4(lightPos"+i+", 0.0)).xyz);")}}else if(light.type==="spot"){if(light.space==="view"){src.push("viewLightDir = normalize(lightDir"+i+");")}else{src.push("viewLightDir = normalize((viewMatrix2 * vec4(lightDir"+i+", 0.0)).xyz);")}}else{continue}
src.push("lambertian = max(dot(-viewNormal, viewLightDir), 0.0);");src.push("reflectedColor += lambertian * (lightColor"+i+".rgb * lightColor"+i+".a);")}}
src.push("vColor = vec4((reflectedColor * materialColor.rgb), materialColor.a) * colorize;");if(clipping){src.push("vWorldPosition = worldPosition;")}
if(geometryState.primitiveName==="points"){src.push("gl_PointSize = pointSize;")}
src.push("   gl_Position = projMatrix * viewPosition;");src.push("}");return src}
function buildFragmentLambert(mesh){const scene=mesh.scene;const clipsState=scene._clipsState;const materialState=mesh._material._state;const geometryState=mesh._geometry._state;let i;let len;const clipping=clipsState.clips.length>0;const solid=!1&&materialState.backfaces;const gammaOutput=scene.gammaOutput;const src=[];src.push("// Lambertian drawing fragment shader");src.push("precision lowp float;");if(clipping){src.push("varying vec4 vWorldPosition;");src.push("uniform bool clippable;");for(i=0,len=clipsState.clips.length;i<len;i++){src.push("uniform bool clipActive"+i+";");src.push("uniform vec3 clipPos"+i+";");src.push("uniform vec3 clipDir"+i+";")}}
src.push("varying vec4 vColor;");if(gammaOutput){src.push("uniform float gammaFactor;");src.push("    vec4 linearToGamma( in vec4 value, in float gammaFactor ) {");src.push("    return vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );");src.push("}")}
src.push("void main(void) {");if(clipping){src.push("if (clippable) {");src.push("  float dist = 0.0;");for(i=0,len=clipsState.clips.length;i<len;i++){src.push("if (clipActive"+i+") {");src.push("   dist += clamp(dot(-clipDir"+i+".xyz, vWorldPosition.xyz - clipPos"+i+".xyz), 0.0, 1000.0);");src.push("}")}
src.push("  if (dist > 0.0) { discard; }");if(solid){src.push("  if (gl_FrontFacing == false) {");src.push("     gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);");src.push("     return;");src.push("  }")}
src.push("}")}
if(geometryState.primitiveName==="points"){src.push("vec2 cxy = 2.0 * gl_PointCoord - 1.0;");src.push("float r = dot(cxy, cxy);");src.push("if (r > 1.0) {");src.push("   discard;");src.push("}")}
if(gammaOutput){src.push("gl_FragColor = linearToGamma(vColor, gammaFactor);")}else{src.push("gl_FragColor = vColor;")}
src.push("}");return src}
function buildVertexDraw(mesh){const scene=mesh.scene;const material=mesh._material;const meshState=mesh._state;const clipsState=scene._clipsState;const geometryState=mesh._geometry._state;const lightsState=scene._lightsState;let i;let len;let light;const billboard=meshState.billboard;const stationary=meshState.stationary;const texturing=hasTextures(mesh);const normals=hasNormals(mesh);const clipping=clipsState.clips.length>0;const receiveShadow=receivesShadow(mesh);const quantizedGeometry=!!geometryState.quantized;const src=[];if(normals&&material._normalMap){src.push("#extension GL_OES_standard_derivatives : enable")}
src.push("// Drawing vertex shader");src.push("attribute  vec3 position;");if(quantizedGeometry){src.push("uniform mat4 positionsDecodeMatrix;")}
src.push("uniform  mat4 modelMatrix;");src.push("uniform  mat4 viewMatrix;");src.push("uniform  mat4 projMatrix;");src.push("varying  vec3 vViewPosition;");if(clipping){src.push("varying vec4 vWorldPosition;")}
if(lightsState.lightMaps.length>0){src.push("varying    vec3 vWorldNormal;")}
if(normals){src.push("attribute  vec3 normal;");src.push("uniform    mat4 modelNormalMatrix;");src.push("uniform    mat4 viewNormalMatrix;");src.push("varying    vec3 vViewNormal;");for(i=0,len=lightsState.lights.length;i<len;i++){light=lightsState.lights[i];if(light.type==="ambient"){continue}
if(light.type==="dir"){src.push("uniform vec3 lightDir"+i+";")}
if(light.type==="point"){src.push("uniform vec3 lightPos"+i+";")}
if(light.type==="spot"){src.push("uniform vec3 lightPos"+i+";");src.push("uniform vec3 lightDir"+i+";")}
if(!(light.type==="dir"&&light.space==="view")){src.push("varying vec4 vViewLightReverseDirAndDist"+i+";")}}
if(quantizedGeometry){src.push("vec3 octDecode(vec2 oct) {");src.push("    vec3 v = vec3(oct.xy, 1.0 - abs(oct.x) - abs(oct.y));");src.push("    if (v.z < 0.0) {");src.push("        v.xy = (1.0 - abs(v.yx)) * vec2(v.x >= 0.0 ? 1.0 : -1.0, v.y >= 0.0 ? 1.0 : -1.0);");src.push("    }");src.push("    return normalize(v);");src.push("}")}}
if(texturing){src.push("attribute vec2 uv;");src.push("varying vec2 vUV;");if(quantizedGeometry){src.push("uniform mat3 uvDecodeMatrix;")}}
if(geometryState.colors){src.push("attribute vec4 color;");src.push("varying vec4 vColor;")}
if(geometryState.primitiveName==="points"){src.push("uniform float pointSize;")}
if(billboard==="spherical"||billboard==="cylindrical"){src.push("void billboard(inout mat4 mat) {");src.push("   mat[0][0] = 1.0;");src.push("   mat[0][1] = 0.0;");src.push("   mat[0][2] = 0.0;");if(billboard==="spherical"){src.push("   mat[1][0] = 0.0;");src.push("   mat[1][1] = 1.0;");src.push("   mat[1][2] = 0.0;")}
src.push("   mat[2][0] = 0.0;");src.push("   mat[2][1] = 0.0;");src.push("   mat[2][2] =1.0;");src.push("}")}
if(receiveShadow){src.push("const mat4 texUnitConverter = mat4(0.5, 0.0, 0.0, 0.0, 0.0, 0.5, 0.0, 0.0, 0.0, 0.0, 0.5, 0.0, 0.5, 0.5, 0.5, 1.0);");for(i=0,len=lightsState.lights.length;i<len;i++){if(lightsState.lights[i].shadow){src.push("uniform mat4 shadowViewMatrix"+i+";");src.push("uniform mat4 shadowProjMatrix"+i+";");src.push("varying vec4 vShadowPosFromLight"+i+";")}}}
src.push("void main(void) {");src.push("vec4 localPosition = vec4(position, 1.0); ");src.push("vec4 worldPosition;");if(quantizedGeometry){src.push("localPosition = positionsDecodeMatrix * localPosition;")}
if(normals){if(quantizedGeometry){src.push("vec4 localNormal = vec4(octDecode(normal.xy), 0.0); ")}else{src.push("vec4 localNormal = vec4(normal, 0.0); ")}
src.push("mat4 modelNormalMatrix2    = modelNormalMatrix;");src.push("mat4 viewNormalMatrix2     = viewNormalMatrix;")}
src.push("mat4 viewMatrix2           = viewMatrix;");src.push("mat4 modelMatrix2          = modelMatrix;");if(stationary){src.push("viewMatrix2[3][0] = viewMatrix2[3][1] = viewMatrix2[3][2] = 0.0;")}
if(billboard==="spherical"||billboard==="cylindrical"){src.push("mat4 modelViewMatrix = viewMatrix2 * modelMatrix2;");src.push("billboard(modelMatrix2);");src.push("billboard(viewMatrix2);");src.push("billboard(modelViewMatrix);");if(normals){src.push("mat4 modelViewNormalMatrix =  viewNormalMatrix2 * modelNormalMatrix2;");src.push("billboard(modelNormalMatrix2);");src.push("billboard(viewNormalMatrix2);");src.push("billboard(modelViewNormalMatrix);")}
src.push("worldPosition = modelMatrix2 * localPosition;");src.push("vec4 viewPosition = modelViewMatrix * localPosition;")}else{src.push("worldPosition = modelMatrix2 * localPosition;");src.push("vec4 viewPosition  = viewMatrix2 * worldPosition; ")}
if(normals){src.push("vec3 worldNormal = (modelNormalMatrix2 * localNormal).xyz; ");if(lightsState.lightMaps.length>0){src.push("vWorldNormal = worldNormal;")}
src.push("vViewNormal = normalize((viewNormalMatrix2 * vec4(worldNormal, 1.0)).xyz);");src.push("vec3 tmpVec3;");src.push("float lightDist;");for(i=0,len=lightsState.lights.length;i<len;i++){light=lightsState.lights[i];if(light.type==="ambient"){continue}
if(light.type==="dir"){if(light.space==="world"){src.push("tmpVec3 = vec3(viewMatrix2 * vec4(lightDir"+i+", 0.0) ).xyz;");src.push("vViewLightReverseDirAndDist"+i+" = vec4(-tmpVec3, 0.0);")}}
if(light.type==="point"){if(light.space==="world"){src.push("tmpVec3 = (viewMatrix2 * vec4(lightPos"+i+", 1.0)).xyz - viewPosition.xyz;");src.push("lightDist = abs(length(tmpVec3));")}else{src.push("tmpVec3 = lightPos"+i+".xyz - viewPosition.xyz;");src.push("lightDist = abs(length(tmpVec3));")}
src.push("vViewLightReverseDirAndDist"+i+" = vec4(tmpVec3, lightDist);")}}}
if(texturing){if(quantizedGeometry){src.push("vUV = (uvDecodeMatrix * vec3(uv, 1.0)).xy;")}else{src.push("vUV = uv;")}}
if(geometryState.colors){src.push("vColor = color;")}
if(geometryState.primitiveName==="points"){src.push("gl_PointSize = pointSize;")}
if(clipping){src.push("vWorldPosition = worldPosition;")}
src.push("   vViewPosition = viewPosition.xyz;");src.push("   gl_Position = projMatrix * viewPosition;");src.push("const mat4 texUnitConverter = mat4(0.5, 0.0, 0.0, 0.0, 0.0, 0.5, 0.0, 0.0, 0.0, 0.0, 0.5, 0.0, 0.5, 0.5, 0.5, 1.0);");if(receiveShadow){src.push("vec4 tempx; ");for(i=0,len=lightsState.lights.length;i<len;i++){if(lightsState.lights[i].shadow){src.push("vShadowPosFromLight"+i+" = texUnitConverter * shadowProjMatrix"+i+" * (shadowViewMatrix"+i+" * worldPosition); ")}}}
src.push("}");return src}
function buildFragmentDraw(mesh){const scene=mesh.scene;const gl=scene.canvas.gl;const material=mesh._material;const geometryState=mesh._geometry._state;const clipsState=mesh.scene._clipsState;const lightsState=mesh.scene._lightsState;const materialState=mesh._material._state;const clipping=clipsState.clips.length>0;const normals=hasNormals(mesh);const uvs=geometryState.uv;const solid=!1&&materialState.backfaces;const phongMaterial=(materialState.type==="PhongMaterial");const metallicMaterial=(materialState.type==="MetallicMaterial");const specularMaterial=(materialState.type==="SpecularMaterial");const receiveShadow=receivesShadow(mesh);const gammaInput=scene.gammaInput;const gammaOutput=scene.gammaOutput;var i;let len;let light;const src=[];src.push("// Drawing fragment shader");if(normals&&material._normalMap){src.push("#extension GL_OES_standard_derivatives : enable")}
src.push("precision "+getFragmentFloatPrecision(gl)+" float;");if(receiveShadow){src.push("float unpackDepth (vec4 color) {");src.push("  const vec4 bitShift = vec4(1.0, 1.0/256.0, 1.0/(256.0 * 256.0), 1.0/(256.0*256.0*256.0));");src.push("  return dot(color, bitShift);");src.push("}")}
src.push("uniform float gammaFactor;");src.push("vec4 linearToLinear( in vec4 value ) {");src.push("  return value;");src.push("}");src.push("vec4 sRGBToLinear( in vec4 value ) {");src.push("  return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );");src.push("}");src.push("vec4 gammaToLinear( in vec4 value) {");src.push("  return vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );");src.push("}");if(gammaOutput){src.push("vec4 linearToGamma( in vec4 value, in float gammaFactor ) {");src.push("  return vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );");src.push("}")}
if(clipping){src.push("varying vec4 vWorldPosition;");src.push("uniform bool clippable;");for(var i=0;i<clipsState.clips.length;i++){src.push("uniform bool clipActive"+i+";");src.push("uniform vec3 clipPos"+i+";");src.push("uniform vec3 clipDir"+i+";")}}
if(normals){if(lightsState.lightMaps.length>0){src.push("uniform samplerCube lightMap;");src.push("uniform mat4 viewNormalMatrix;")}
if(lightsState.reflectionMaps.length>0){src.push("uniform samplerCube reflectionMap;")}
if(lightsState.lightMaps.length>0||lightsState.reflectionMaps.length>0){src.push("uniform mat4 viewMatrix;")}
src.push("#define PI 3.14159265359");src.push("#define RECIPROCAL_PI 0.31830988618");src.push("#define RECIPROCAL_PI2 0.15915494");src.push("#define EPSILON 1e-6");src.push("#define saturate(a) clamp( a, 0.0, 1.0 )");src.push("vec3 inverseTransformDirection(in vec3 dir, in mat4 matrix) {");src.push("   return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );");src.push("}");src.push("struct IncidentLight {");src.push("   vec3 color;");src.push("   vec3 direction;");src.push("};");src.push("struct ReflectedLight {");src.push("   vec3 diffuse;");src.push("   vec3 specular;");src.push("};");src.push("struct Geometry {");src.push("   vec3 position;");src.push("   vec3 viewNormal;");src.push("   vec3 worldNormal;");src.push("   vec3 viewEyeDir;");src.push("};");src.push("struct Material {");src.push("   vec3    diffuseColor;");src.push("   float   specularRoughness;");src.push("   vec3    specularColor;");src.push("   float   shine;");src.push("};");if(phongMaterial){if(lightsState.lightMaps.length>0||lightsState.reflectionMaps.length>0){src.push("void computePhongLightMapping(const in Geometry geometry, const in Material material, inout ReflectedLight reflectedLight) {");if(lightsState.lightMaps.length>0){src.push("   vec3 irradiance = "+TEXTURE_DECODE_FUNCS[lightsState.lightMaps[0].encoding]+"(textureCube(lightMap, geometry.worldNormal)).rgb;");src.push("   irradiance *= PI;");src.push("   vec3 diffuseBRDFContrib = (RECIPROCAL_PI * material.diffuseColor);");src.push("   reflectedLight.diffuse += irradiance * diffuseBRDFContrib;")}
if(lightsState.reflectionMaps.length>0){src.push("   vec3 reflectVec             = reflect(-geometry.viewEyeDir, geometry.viewNormal);");src.push("   vec3 radiance               = textureCube(reflectionMap, reflectVec).rgb * 0.2;");src.push("   reflectedLight.specular     += radiance;")}
src.push("}")}
src.push("void computePhongLighting(const in IncidentLight directLight, const in Geometry geometry, const in Material material, inout ReflectedLight reflectedLight) {");src.push("   float dotNL     = saturate(dot(geometry.viewNormal, directLight.direction));");src.push("   vec3 irradiance = dotNL * directLight.color * PI;");src.push("   reflectedLight.diffuse  += irradiance * (RECIPROCAL_PI * material.diffuseColor);");src.push("   reflectedLight.specular += directLight.color * material.specularColor * pow(max(dot(reflect(-directLight.direction, -geometry.viewNormal), geometry.viewEyeDir), 0.0), material.shine);");src.push("}")}
if(metallicMaterial||specularMaterial){src.push("float GGXRoughnessToBlinnExponent(const in float ggxRoughness) {");src.push("   float r = ggxRoughness + 0.0001;");src.push("   return (2.0 / (r * r) - 2.0);");src.push("}");src.push("float getSpecularMIPLevel(const in float blinnShininessExponent, const in int maxMIPLevel) {");src.push("   float maxMIPLevelScalar = float( maxMIPLevel );");src.push("   float desiredMIPLevel = maxMIPLevelScalar - 0.79248 - 0.5 * log2( ( blinnShininessExponent * blinnShininessExponent ) + 1.0 );");src.push("   return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );");src.push("}");if(lightsState.reflectionMaps.length>0){src.push("vec3 getLightProbeIndirectRadiance(const in vec3 reflectVec, const in float blinnShininessExponent, const in int maxMIPLevel) {");src.push("   float mipLevel = 0.5 * getSpecularMIPLevel(blinnShininessExponent, maxMIPLevel);");src.push("   vec3 envMapColor = "+TEXTURE_DECODE_FUNCS[lightsState.reflectionMaps[0].encoding]+"(textureCube(reflectionMap, reflectVec, mipLevel)).rgb;");src.push("  return envMapColor;");src.push("}")}
src.push("vec3 F_Schlick(const in vec3 specularColor, const in float dotLH) {");src.push("   float fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );");src.push("   return ( 1.0 - specularColor ) * fresnel + specularColor;");src.push("}");src.push("float G_GGX_Smith(const in float alpha, const in float dotNL, const in float dotNV) {");src.push("   float a2 = ( alpha * alpha );");src.push("   float gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * ( dotNL * dotNL ) );");src.push("   float gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * ( dotNV * dotNV ) );");src.push("   return 1.0 / ( gl * gv );");src.push("}");src.push("float G_GGX_SmithCorrelated(const in float alpha, const in float dotNL, const in float dotNV) {");src.push("   float a2 = ( alpha * alpha );");src.push("   float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * ( dotNV * dotNV ) );");src.push("   float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * ( dotNL * dotNL ) );");src.push("   return 0.5 / max( gv + gl, EPSILON );");src.push("}");src.push("float D_GGX(const in float alpha, const in float dotNH) {");src.push("   float a2 = ( alpha * alpha );");src.push("   float denom = ( dotNH * dotNH) * ( a2 - 1.0 ) + 1.0;");src.push("   return RECIPROCAL_PI * a2 / ( denom * denom);");src.push("}");src.push("vec3 BRDF_Specular_GGX(const in IncidentLight incidentLight, const in Geometry geometry, const in vec3 specularColor, const in float roughness) {");src.push("   float alpha = ( roughness * roughness );");src.push("   vec3 halfDir = normalize( incidentLight.direction + geometry.viewEyeDir );");src.push("   float dotNL = saturate( dot( geometry.viewNormal, incidentLight.direction ) );");src.push("   float dotNV = saturate( dot( geometry.viewNormal, geometry.viewEyeDir ) );");src.push("   float dotNH = saturate( dot( geometry.viewNormal, halfDir ) );");src.push("   float dotLH = saturate( dot( incidentLight.direction, halfDir ) );");src.push("   vec3  F = F_Schlick( specularColor, dotLH );");src.push("   float G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );");src.push("   float D = D_GGX( alpha, dotNH );");src.push("   return F * (G * D);");src.push("}");src.push("vec3 BRDF_Specular_GGX_Environment(const in Geometry geometry, const in vec3 specularColor, const in float roughness) {");src.push("   float dotNV = saturate(dot(geometry.viewNormal, geometry.viewEyeDir));");src.push("   const vec4 c0 = vec4( -1, -0.0275, -0.572,  0.022);");src.push("   const vec4 c1 = vec4(  1,  0.0425,   1.04, -0.04);");src.push("   vec4 r = roughness * c0 + c1;");src.push("   float a004 = min(r.x * r.x, exp2(-9.28 * dotNV)) * r.x + r.y;");src.push("   vec2 AB    = vec2(-1.04, 1.04) * a004 + r.zw;");src.push("   return specularColor * AB.x + AB.y;");src.push("}");if(lightsState.lightMaps.length>0||lightsState.reflectionMaps.length>0){src.push("void computePBRLightMapping(const in Geometry geometry, const in Material material, inout ReflectedLight reflectedLight) {");if(lightsState.lightMaps.length>0){src.push("   vec3 irradiance = sRGBToLinear(textureCube(lightMap, geometry.worldNormal)).rgb;");src.push("   irradiance *= PI;");src.push("   vec3 diffuseBRDFContrib = (RECIPROCAL_PI * material.diffuseColor);");src.push("   reflectedLight.diffuse += irradiance * diffuseBRDFContrib;")}
if(lightsState.reflectionMaps.length>0){src.push("   vec3 reflectVec             = reflect(-geometry.viewEyeDir, geometry.viewNormal);");src.push("   reflectVec                  = inverseTransformDirection(reflectVec, viewMatrix);");src.push("   float blinnExpFromRoughness = GGXRoughnessToBlinnExponent(material.specularRoughness);");src.push("   vec3 radiance               = getLightProbeIndirectRadiance(reflectVec, blinnExpFromRoughness, 8);");src.push("   vec3 specularBRDFContrib    = BRDF_Specular_GGX_Environment(geometry, material.specularColor, material.specularRoughness);");src.push("   reflectedLight.specular     += radiance * specularBRDFContrib;")}
src.push("}")}
src.push("void computePBRLighting(const in IncidentLight incidentLight, const in Geometry geometry, const in Material material, inout ReflectedLight reflectedLight) {");src.push("   float dotNL     = saturate(dot(geometry.viewNormal, incidentLight.direction));");src.push("   vec3 irradiance = dotNL * incidentLight.color * PI;");src.push("   reflectedLight.diffuse  += irradiance * (RECIPROCAL_PI * material.diffuseColor);");src.push("   reflectedLight.specular += irradiance * BRDF_Specular_GGX(incidentLight, geometry, material.specularColor, material.specularRoughness);");src.push("}")}}
src.push("varying vec3 vViewPosition;");if(geometryState.colors){src.push("varying vec4 vColor;")}
if(uvs&&((normals&&material._normalMap)||material._ambientMap||material._baseColorMap||material._diffuseMap||material._emissiveMap||material._metallicMap||material._roughnessMap||material._metallicRoughnessMap||material._specularMap||material._glossinessMap||material._specularGlossinessMap||material._occlusionMap||material._alphaMap)){src.push("varying vec2 vUV;")}
if(normals){if(lightsState.lightMaps.length>0){src.push("varying vec3 vWorldNormal;")}
src.push("varying vec3 vViewNormal;")}
if(materialState.ambient){src.push("uniform vec3 materialAmbient;")}
if(materialState.baseColor){src.push("uniform vec3 materialBaseColor;")}
if(materialState.alpha!==undefined&&materialState.alpha!==null){src.push("uniform vec4 materialAlphaModeCutoff;")}
if(materialState.emissive){src.push("uniform vec3 materialEmissive;")}
if(materialState.diffuse){src.push("uniform vec3 materialDiffuse;")}
if(materialState.glossiness!==undefined&&materialState.glossiness!==null){src.push("uniform float materialGlossiness;")}
if(materialState.shininess!==undefined&&materialState.shininess!==null){src.push("uniform float materialShininess;")}
if(materialState.specular){src.push("uniform vec3 materialSpecular;")}
if(materialState.metallic!==undefined&&materialState.metallic!==null){src.push("uniform float materialMetallic;")}
if(materialState.roughness!==undefined&&materialState.roughness!==null){src.push("uniform float materialRoughness;")}
if(materialState.specularF0!==undefined&&materialState.specularF0!==null){src.push("uniform float materialSpecularF0;")}
if(uvs&&material._ambientMap){src.push("uniform sampler2D ambientMap;");if(material._ambientMap._state.matrix){src.push("uniform mat4 ambientMapMatrix;")}}
if(uvs&&material._baseColorMap){src.push("uniform sampler2D baseColorMap;");if(material._baseColorMap._state.matrix){src.push("uniform mat4 baseColorMapMatrix;")}}
if(uvs&&material._diffuseMap){src.push("uniform sampler2D diffuseMap;");if(material._diffuseMap._state.matrix){src.push("uniform mat4 diffuseMapMatrix;")}}
if(uvs&&material._emissiveMap){src.push("uniform sampler2D emissiveMap;");if(material._emissiveMap._state.matrix){src.push("uniform mat4 emissiveMapMatrix;")}}
if(normals&&uvs&&material._metallicMap){src.push("uniform sampler2D metallicMap;");if(material._metallicMap._state.matrix){src.push("uniform mat4 metallicMapMatrix;")}}
if(normals&&uvs&&material._roughnessMap){src.push("uniform sampler2D roughnessMap;");if(material._roughnessMap._state.matrix){src.push("uniform mat4 roughnessMapMatrix;")}}
if(normals&&uvs&&material._metallicRoughnessMap){src.push("uniform sampler2D metallicRoughnessMap;");if(material._metallicRoughnessMap._state.matrix){src.push("uniform mat4 metallicRoughnessMapMatrix;")}}
if(normals&&material._normalMap){src.push("uniform sampler2D normalMap;");if(material._normalMap._state.matrix){src.push("uniform mat4 normalMapMatrix;")}
src.push("vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {");src.push("      vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );");src.push("      vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );");src.push("      vec2 st0 = dFdx( uv.st );");src.push("      vec2 st1 = dFdy( uv.st );");src.push("      vec3 S = normalize( q0 * st1.t - q1 * st0.t );");src.push("      vec3 T = normalize( -q0 * st1.s + q1 * st0.s );");src.push("      vec3 N = normalize( surf_norm );");src.push("      vec3 mapN = texture2D( normalMap, uv ).xyz * 2.0 - 1.0;");src.push("      mat3 tsn = mat3( S, T, N );");src.push("      return normalize( tsn * mapN );");src.push("}")}
if(uvs&&material._occlusionMap){src.push("uniform sampler2D occlusionMap;");if(material._occlusionMap._state.matrix){src.push("uniform mat4 occlusionMapMatrix;")}}
if(uvs&&material._alphaMap){src.push("uniform sampler2D alphaMap;");if(material._alphaMap._state.matrix){src.push("uniform mat4 alphaMapMatrix;")}}
if(normals&&uvs&&material._specularMap){src.push("uniform sampler2D specularMap;");if(material._specularMap._state.matrix){src.push("uniform mat4 specularMapMatrix;")}}
if(normals&&uvs&&material._glossinessMap){src.push("uniform sampler2D glossinessMap;");if(material._glossinessMap._state.matrix){src.push("uniform mat4 glossinessMapMatrix;")}}
if(normals&&uvs&&material._specularGlossinessMap){src.push("uniform sampler2D materialSpecularGlossinessMap;");if(material._specularGlossinessMap._state.matrix){src.push("uniform mat4 materialSpecularGlossinessMapMatrix;")}}
if(normals&&(material._diffuseFresnel||material._specularFresnel||material._alphaFresnel||material._emissiveFresnel||material._reflectivityFresnel)){src.push("float fresnel(vec3 eyeDir, vec3 normal, float edgeBias, float centerBias, float power) {");src.push("    float fr = abs(dot(eyeDir, normal));");src.push("    float finalFr = clamp((fr - edgeBias) / (centerBias - edgeBias), 0.0, 1.0);");src.push("    return pow(finalFr, power);");src.push("}");if(material._diffuseFresnel){src.push("uniform float  diffuseFresnelCenterBias;");src.push("uniform float  diffuseFresnelEdgeBias;");src.push("uniform float  diffuseFresnelPower;");src.push("uniform vec3   diffuseFresnelCenterColor;");src.push("uniform vec3   diffuseFresnelEdgeColor;")}
if(material._specularFresnel){src.push("uniform float  specularFresnelCenterBias;");src.push("uniform float  specularFresnelEdgeBias;");src.push("uniform float  specularFresnelPower;");src.push("uniform vec3   specularFresnelCenterColor;");src.push("uniform vec3   specularFresnelEdgeColor;")}
if(material._alphaFresnel){src.push("uniform float  alphaFresnelCenterBias;");src.push("uniform float  alphaFresnelEdgeBias;");src.push("uniform float  alphaFresnelPower;");src.push("uniform vec3   alphaFresnelCenterColor;");src.push("uniform vec3   alphaFresnelEdgeColor;")}
if(material._reflectivityFresnel){src.push("uniform float  materialSpecularF0FresnelCenterBias;");src.push("uniform float  materialSpecularF0FresnelEdgeBias;");src.push("uniform float  materialSpecularF0FresnelPower;");src.push("uniform vec3   materialSpecularF0FresnelCenterColor;");src.push("uniform vec3   materialSpecularF0FresnelEdgeColor;")}
if(material._emissiveFresnel){src.push("uniform float  emissiveFresnelCenterBias;");src.push("uniform float  emissiveFresnelEdgeBias;");src.push("uniform float  emissiveFresnelPower;");src.push("uniform vec3   emissiveFresnelCenterColor;");src.push("uniform vec3   emissiveFresnelEdgeColor;")}}
src.push("uniform vec4   lightAmbient;");if(normals){for(i=0,len=lightsState.lights.length;i<len;i++){light=lightsState.lights[i];if(light.type==="ambient"){continue}
src.push("uniform vec4 lightColor"+i+";");if(light.type==="point"){src.push("uniform vec3 lightAttenuation"+i+";")}
if(light.type==="dir"&&light.space==="view"){src.push("uniform vec3 lightDir"+i+";")}
if(light.type==="point"&&light.space==="view"){src.push("uniform vec3 lightPos"+i+";")}else{src.push("varying vec4 vViewLightReverseDirAndDist"+i+";")}}}
if(receiveShadow){for(i=0,len=lightsState.lights.length;i<len;i++){if(lightsState.lights[i].shadow){src.push("varying vec4 vShadowPosFromLight"+i+";");src.push("uniform sampler2D shadowMap"+i+";")}}}
src.push("uniform vec4 colorize;");src.push("void main(void) {");if(clipping){src.push("if (clippable) {");src.push("  float dist = 0.0;");for(var i=0;i<clipsState.clips.length;i++){src.push("if (clipActive"+i+") {");src.push("   dist += clamp(dot(-clipDir"+i+".xyz, vWorldPosition.xyz - clipPos"+i+".xyz), 0.0, 1000.0);");src.push("}")}
src.push("  if (dist > 0.0) { discard; }");if(solid){src.push("  if (gl_FrontFacing == false) {");src.push("     gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);");src.push("     return;");src.push("  }")}
src.push("}")}
if(geometryState.primitiveName==="points"){src.push("vec2 cxy = 2.0 * gl_PointCoord - 1.0;");src.push("float r = dot(cxy, cxy);");src.push("if (r > 1.0) {");src.push("   discard;");src.push("}")}
src.push("float occlusion = 1.0;");if(materialState.ambient){src.push("vec3 ambientColor = materialAmbient;")}else{src.push("vec3 ambientColor = vec3(1.0, 1.0, 1.0);")}
if(materialState.diffuse){src.push("vec3 diffuseColor = materialDiffuse;")}else if(materialState.baseColor){src.push("vec3 diffuseColor = materialBaseColor;")}else{src.push("vec3 diffuseColor = vec3(1.0, 1.0, 1.0);")}
if(geometryState.colors){src.push("diffuseColor *= vColor.rgb;")}
if(materialState.emissive){src.push("vec3 emissiveColor = materialEmissive;")}else{src.push("vec3  emissiveColor = vec3(0.0, 0.0, 0.0);")}
if(materialState.specular){src.push("vec3 specular = materialSpecular;")}else{src.push("vec3 specular = vec3(1.0, 1.0, 1.0);")}
if(materialState.alpha!==undefined){src.push("float alpha = materialAlphaModeCutoff[0];")}else{src.push("float alpha = 1.0;")}
if(geometryState.colors){src.push("alpha *= vColor.a;")}
if(materialState.glossiness!==undefined){src.push("float glossiness = materialGlossiness;")}else{src.push("float glossiness = 1.0;")}
if(materialState.metallic!==undefined){src.push("float metallic = materialMetallic;")}else{src.push("float metallic = 1.0;")}
if(materialState.roughness!==undefined){src.push("float roughness = materialRoughness;")}else{src.push("float roughness = 1.0;")}
if(materialState.specularF0!==undefined){src.push("float specularF0 = materialSpecularF0;")}else{src.push("float specularF0 = 1.0;")}
if(uvs&&((normals&&material._normalMap)||material._ambientMap||material._baseColorMap||material._diffuseMap||material._occlusionMap||material._emissiveMap||material._metallicMap||material._roughnessMap||material._metallicRoughnessMap||material._specularMap||material._glossinessMap||material._specularGlossinessMap||material._alphaMap)){src.push("vec4 texturePos = vec4(vUV.s, vUV.t, 1.0, 1.0);");src.push("vec2 textureCoord;")}
if(uvs&&material._ambientMap){if(material._ambientMap._state.matrix){src.push("textureCoord = (ambientMapMatrix * texturePos).xy;")}else{src.push("textureCoord = texturePos.xy;")}
src.push("vec4 ambientTexel = texture2D(ambientMap, textureCoord).rgb;");src.push("ambientTexel = "+TEXTURE_DECODE_FUNCS[material._ambientMap._state.encoding]+"(ambientTexel);");src.push("ambientColor *= ambientTexel.rgb;")}
if(uvs&&material._diffuseMap){if(material._diffuseMap._state.matrix){src.push("textureCoord = (diffuseMapMatrix * texturePos).xy;")}else{src.push("textureCoord = texturePos.xy;")}
src.push("vec4 diffuseTexel = texture2D(diffuseMap, textureCoord);");src.push("diffuseTexel = "+TEXTURE_DECODE_FUNCS[material._diffuseMap._state.encoding]+"(diffuseTexel);");src.push("diffuseColor *= diffuseTexel.rgb;");src.push("alpha *= diffuseTexel.a;")}
if(uvs&&material._baseColorMap){if(material._baseColorMap._state.matrix){src.push("textureCoord = (baseColorMapMatrix * texturePos).xy;")}else{src.push("textureCoord = texturePos.xy;")}
src.push("vec4 baseColorTexel = texture2D(baseColorMap, textureCoord);");src.push("baseColorTexel = "+TEXTURE_DECODE_FUNCS[material._baseColorMap._state.encoding]+"(baseColorTexel);");src.push("diffuseColor *= baseColorTexel.rgb;");src.push("alpha *= baseColorTexel.a;")}
if(uvs&&material._emissiveMap){if(material._emissiveMap._state.matrix){src.push("textureCoord = (emissiveMapMatrix * texturePos).xy;")}else{src.push("textureCoord = texturePos.xy;")}
src.push("vec4 emissiveTexel = texture2D(emissiveMap, textureCoord);");src.push("emissiveTexel = "+TEXTURE_DECODE_FUNCS[material._emissiveMap._state.encoding]+"(emissiveTexel);");src.push("emissiveColor *= emissiveTexel.rgb;")}
if(uvs&&material._alphaMap){if(material._alphaMap._state.matrix){src.push("textureCoord = (alphaMapMatrix * texturePos).xy;")}else{src.push("textureCoord = texturePos.xy;")}
src.push("alpha *= texture2D(alphaMap, textureCoord).r;")}
if(uvs&&material._occlusionMap){if(material._occlusionMap._state.matrix){src.push("textureCoord = (occlusionMapMatrix * texturePos).xy;")}else{src.push("textureCoord = texturePos.xy;")}
src.push("occlusion *= texture2D(occlusionMap, textureCoord).r;")}
if(normals&&((lightsState.lights.length>0)||lightsState.lightMaps.length>0||lightsState.reflectionMaps.length>0)){if(uvs&&material._normalMap){if(material._normalMap._state.matrix){src.push("textureCoord = (normalMapMatrix * texturePos).xy;")}else{src.push("textureCoord = texturePos.xy;")}
src.push("vec3 viewNormal = perturbNormal2Arb( vViewPosition, normalize(vViewNormal), textureCoord );")}else{src.push("vec3 viewNormal = normalize(vViewNormal);")}
if(uvs&&material._specularMap){if(material._specularMap._state.matrix){src.push("textureCoord = (specularMapMatrix * texturePos).xy;")}else{src.push("textureCoord = texturePos.xy;")}
src.push("specular *= texture2D(specularMap, textureCoord).rgb;")}
if(uvs&&material._glossinessMap){if(material._glossinessMap._state.matrix){src.push("textureCoord = (glossinessMapMatrix * texturePos).xy;")}else{src.push("textureCoord = texturePos.xy;")}
src.push("glossiness *= texture2D(glossinessMap, textureCoord).r;")}
if(uvs&&material._specularGlossinessMap){if(material._specularGlossinessMap._state.matrix){src.push("textureCoord = (materialSpecularGlossinessMapMatrix * texturePos).xy;")}else{src.push("textureCoord = texturePos.xy;")}
src.push("vec4 specGlossRGB = texture2D(materialSpecularGlossinessMap, textureCoord).rgba;");src.push("specular *= specGlossRGB.rgb;");src.push("glossiness *= specGlossRGB.a;")}
if(uvs&&material._metallicMap){if(material._metallicMap._state.matrix){src.push("textureCoord = (metallicMapMatrix * texturePos).xy;")}else{src.push("textureCoord = texturePos.xy;")}
src.push("metallic *= texture2D(metallicMap, textureCoord).r;")}
if(uvs&&material._roughnessMap){if(material._roughnessMap._state.matrix){src.push("textureCoord = (roughnessMapMatrix * texturePos).xy;")}else{src.push("textureCoord = texturePos.xy;")}
src.push("roughness *= texture2D(roughnessMap, textureCoord).r;")}
if(uvs&&material._metallicRoughnessMap){if(material._metallicRoughnessMap._state.matrix){src.push("textureCoord = (metallicRoughnessMapMatrix * texturePos).xy;")}else{src.push("textureCoord = texturePos.xy;")}
src.push("vec3 metalRoughRGB = texture2D(metallicRoughnessMap, textureCoord).rgb;");src.push("metallic *= metalRoughRGB.b;");src.push("roughness *= metalRoughRGB.g;")}
src.push("vec3 viewEyeDir = normalize(-vViewPosition);");if(material._diffuseFresnel){src.push("float diffuseFresnel = fresnel(viewEyeDir, viewNormal, diffuseFresnelEdgeBias, diffuseFresnelCenterBias, diffuseFresnelPower);");src.push("diffuseColor *= mix(diffuseFresnelEdgeColor, diffuseFresnelCenterColor, diffuseFresnel);")}
if(material._specularFresnel){src.push("float specularFresnel = fresnel(viewEyeDir, viewNormal, specularFresnelEdgeBias, specularFresnelCenterBias, specularFresnelPower);");src.push("specular *= mix(specularFresnelEdgeColor, specularFresnelCenterColor, specularFresnel);")}
if(material._alphaFresnel){src.push("float alphaFresnel = fresnel(viewEyeDir, viewNormal, alphaFresnelEdgeBias, alphaFresnelCenterBias, alphaFresnelPower);");src.push("alpha *= mix(alphaFresnelEdgeColor.r, alphaFresnelCenterColor.r, alphaFresnel);")}
if(material._emissiveFresnel){src.push("float emissiveFresnel = fresnel(viewEyeDir, viewNormal, emissiveFresnelEdgeBias, emissiveFresnelCenterBias, emissiveFresnelPower);");src.push("emissiveColor *= mix(emissiveFresnelEdgeColor, emissiveFresnelCenterColor, emissiveFresnel);")}
src.push("if (materialAlphaModeCutoff[1] == 1.0 && alpha < materialAlphaModeCutoff[2]) {");src.push("   discard;");src.push("}");src.push("IncidentLight  light;");src.push("Material       material;");src.push("Geometry       geometry;");src.push("ReflectedLight reflectedLight = ReflectedLight(vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0));");src.push("vec3           viewLightDir;");if(phongMaterial){src.push("material.diffuseColor      = diffuseColor;");src.push("material.specularColor     = specular;");src.push("material.shine             = materialShininess;")}
if(specularMaterial){src.push("float oneMinusSpecularStrength = 1.0 - max(max(specular.r, specular.g ),specular.b);");src.push("material.diffuseColor      = diffuseColor * oneMinusSpecularStrength;");src.push("material.specularRoughness = clamp( 1.0 - glossiness, 0.04, 1.0 );");src.push("material.specularColor     = specular;")}
if(metallicMaterial){src.push("float dielectricSpecular = 0.16 * specularF0 * specularF0;");src.push("material.diffuseColor      = diffuseColor * (1.0 - dielectricSpecular) * (1.0 - metallic);");src.push("material.specularRoughness = clamp(roughness, 0.04, 1.0);");src.push("material.specularColor     = mix(vec3(dielectricSpecular), diffuseColor, metallic);")}
src.push("geometry.position      = vViewPosition;");if(lightsState.lightMaps.length>0){src.push("geometry.worldNormal   = normalize(vWorldNormal);")}
src.push("geometry.viewNormal    = viewNormal;");src.push("geometry.viewEyeDir    = viewEyeDir;");if((phongMaterial)&&(lightsState.lightMaps.length>0||lightsState.reflectionMaps.length>0)){src.push("computePhongLightMapping(geometry, material, reflectedLight);")}
if((specularMaterial||metallicMaterial)&&(lightsState.lightMaps.length>0||lightsState.reflectionMaps.length>0)){src.push("computePBRLightMapping(geometry, material, reflectedLight);")}
src.push("float shadow = 1.0;");src.push("float shadowAcneRemover = 0.007;");src.push("vec3 fragmentDepth;");src.push("float texelSize = 1.0 / 1024.0;");src.push("float amountInLight = 0.0;");src.push("vec3 shadowCoord;");src.push('vec4 rgbaDepth;');src.push("float depth;");for(i=0,len=lightsState.lights.length;i<len;i++){light=lightsState.lights[i];if(light.type==="ambient"){continue}
if(light.type==="dir"&&light.space==="view"){src.push("viewLightDir = -normalize(lightDir"+i+");")}else if(light.type==="point"&&light.space==="view"){src.push("viewLightDir = normalize(lightPos"+i+" - vViewPosition);")}else{src.push("viewLightDir = normalize(vViewLightReverseDirAndDist"+i+".xyz);")}
if(receiveShadow&&light.shadow){src.push("shadow = 0.0;");src.push("fragmentDepth = vShadowPosFromLight"+i+".xyz;");src.push("fragmentDepth.z -= shadowAcneRemover;");src.push("for (int x = -3; x <= 3; x++) {");src.push("  for (int y = -3; y <= 3; y++) {");src.push("      float texelDepth = unpackDepth(texture2D(shadowMap"+i+", fragmentDepth.xy + vec2(x, y) * texelSize));");src.push("      if (fragmentDepth.z < texelDepth) {");src.push("          shadow += 1.0;");src.push("      }");src.push("  }");src.push("}");src.push("shadow = shadow / 9.0;");src.push("light.color =  lightColor"+i+".rgb * (lightColor"+i+".a * shadow);")}else{src.push("light.color =  lightColor"+i+".rgb * (lightColor"+i+".a );")}
src.push("light.direction = viewLightDir;");if(phongMaterial){src.push("computePhongLighting(light, geometry, material, reflectedLight);")}
if(specularMaterial||metallicMaterial){src.push("computePBRLighting(light, geometry, material, reflectedLight);")}}
if(phongMaterial){src.push("ambientColor *= (lightAmbient.rgb * lightAmbient.a);");src.push("vec3 outgoingLight =  ((occlusion * (( reflectedLight.diffuse + reflectedLight.specular)))) + emissiveColor;")}else{src.push("vec3 outgoingLight = (occlusion * (reflectedLight.diffuse)) + (occlusion * reflectedLight.specular) + emissiveColor;")}}
else{src.push("ambientColor *= (lightAmbient.rgb * lightAmbient.a);");src.push("vec3 outgoingLight = emissiveColor + ambientColor;")}
src.push("gl_FragColor = vec4(outgoingLight, alpha) * colorize;");if(gammaOutput){src.push("gl_FragColor = linearToGamma(gl_FragColor, gammaFactor);")}
src.push("}");return src}
class Shader{constructor(gl,type,source){this.allocated=!1;this.compiled=!1;this.handle=gl.createShader(type);if(!this.handle){this.errors=["Failed to allocate"];return}
this.allocated=!0;gl.shaderSource(this.handle,source);gl.compileShader(this.handle);this.compiled=gl.getShaderParameter(this.handle,gl.COMPILE_STATUS);if(!this.compiled){if(!gl.isContextLost()){const lines=source.split("\n");const numberedLines=[];for(let i=0;i<lines.length;i++){numberedLines.push((i+1)+": "+lines[i]+"\n")}
this.errors=[];this.errors.push("");this.errors.push(gl.getShaderInfoLog(this.handle));this.errors=this.errors.concat(numberedLines.join(""))}}}
destroy(){}}
class Sampler{constructor(gl,location){this.bindTexture=function(texture,unit){if(texture.bind(unit)){gl.uniform1i(location,unit);return!0}
return!1}}}
class Attribute{constructor(gl,location){this._gl=gl;this.location=location}
bindArrayBuffer(buffer,type){if(!buffer){return}
buffer.bind();this._gl.enableVertexAttribArray(this.location);this._gl.vertexAttribPointer(this.location,type===this._gl.BYTE?2:buffer.itemSize,type||this._gl.FLOAT,type===this._gl.BYTE,0,0)}}
const ids$1=new Map({});function joinSansComments(srcLines){const src=[];let line;let n;for(let i=0,len=srcLines.length;i<len;i++){line=srcLines[i];n=line.indexOf("/");if(n>0){if(line.charAt(n+1)==="/"){line=line.substring(0,n)}}
src.push(line)}
return src.join("\n")}
class Program{constructor(gl,shaderSource){this.id=ids$1.addItem({});this.source=shaderSource;this.init(gl)}
init(gl){this.gl=gl;this.allocated=!1;this.compiled=!1;this.linked=!1;this.validated=!1;this.errors=null;this.uniforms={};this.samplers={};this.attributes={};this._vertexShader=new Shader(gl,gl.VERTEX_SHADER,joinSansComments(this.source.vertex));this._fragmentShader=new Shader(gl,gl.FRAGMENT_SHADER,joinSansComments(this.source.fragment));if(!this._vertexShader.allocated){this.errors=["Vertex shader failed to allocate"].concat(this._vertexShader.errors);return}
if(!this._fragmentShader.allocated){this.errors=["Fragment shader failed to allocate"].concat(this._fragmentShader.errors);return}
this.allocated=!0;if(!this._vertexShader.compiled){this.errors=["Vertex shader failed to compile"].concat(this._vertexShader.errors);return}
if(!this._fragmentShader.compiled){this.errors=["Fragment shader failed to compile"].concat(this._fragmentShader.errors);return}
this.compiled=!0;let a;let i;let u;let uName;let location;this.handle=gl.createProgram();if(!this.handle){this.errors=["Failed to allocate program"];return}
gl.attachShader(this.handle,this._vertexShader.handle);gl.attachShader(this.handle,this._fragmentShader.handle);gl.linkProgram(this.handle);this.linked=gl.getProgramParameter(this.handle,gl.LINK_STATUS);this.validated=!0;if(!this.linked||!this.validated){this.errors=[];this.errors.push("");this.errors.push(gl.getProgramInfoLog(this.handle));this.errors.push("\nVertex shader:\n");this.errors=this.errors.concat(shaderSource.vertex);this.errors.push("\nFragment shader:\n");this.errors=this.errors.concat(shaderSource.fragment);return}
const numUniforms=gl.getProgramParameter(this.handle,gl.ACTIVE_UNIFORMS);for(i=0;i<numUniforms;++i){u=gl.getActiveUniform(this.handle,i);if(u){uName=u.name;if(uName[uName.length-1]==="\u0000"){uName=uName.substr(0,uName.length-1)}
location=gl.getUniformLocation(this.handle,uName);if((u.type===gl.SAMPLER_2D)||(u.type===gl.SAMPLER_CUBE)||(u.type===35682)){this.samplers[uName]=new Sampler(gl,location)}else{this.uniforms[uName]=location}}}
const numAttribs=gl.getProgramParameter(this.handle,gl.ACTIVE_ATTRIBUTES);for(i=0;i<numAttribs;i++){a=gl.getActiveAttrib(this.handle,i);if(a){location=gl.getAttribLocation(this.handle,a.name);this.attributes[a.name]=new Attribute(gl,location)}}
this.allocated=!0}
bind(){if(!this.allocated){return}
this.gl.useProgram(this.handle)}
getLocation(name){if(!this.allocated){return}
return this.uniforms[name]}
getAttribute(name){if(!this.allocated){return}
return this.attributes[name]}
bindTexture(name,texture,unit){if(!this.allocated){return!1}
const sampler=this.samplers[name];if(sampler){return sampler.bindTexture(texture,unit)}else{return!1}}
destroy(){if(!this.allocated){return}
ids$1.removeItem(this.id);this.gl.deleteProgram(this.handle);this.gl.deleteShader(this._vertexShader.handle);this.gl.deleteShader(this._fragmentShader.handle);this.handle=null;this.attributes=null;this.uniforms=null;this.samplers=null;this.allocated=!1}}
const ids$2=new Map({});const DrawRenderer=function(hash,mesh){this.id=ids$2.addItem({});this._hash=hash;this._scene=mesh.scene;this._useCount=0;this._shaderSource=new DrawShaderSource(mesh);this._allocate(mesh)};const drawRenderers={};DrawRenderer.get=function(mesh){const scene=mesh.scene;const hash=[scene.canvas.canvas.id,(scene.gammaInput?"gi;":";")+(scene.gammaOutput?"go":""),scene._lightsState.getHash(),scene._clipsState.getHash(),mesh._geometry._state.hash,mesh._material._state.hash,mesh._state.hash].join(";");let renderer=drawRenderers[hash];if(!renderer){renderer=new DrawRenderer(hash,mesh);if(renderer.errors){console.log(renderer.errors.join("\n"));return null}
drawRenderers[hash]=renderer;stats.memory.programs++}
renderer._useCount++;return renderer};DrawRenderer.prototype.put=function(){if(--this._useCount===0){ids$2.removeItem(this.id);if(this._program){this._program.destroy()}
delete drawRenderers[this._hash];stats.memory.programs--}};DrawRenderer.prototype.webglContextRestored=function(){this._program=null};DrawRenderer.prototype.drawMesh=function(frame,mesh){if(!this._program){this._allocate(mesh)}
const maxTextureUnits=WEBGL_INFO.MAX_TEXTURE_UNITS;const scene=mesh.scene;const material=mesh._material;const gl=scene.canvas.gl;const program=this._program;const meshState=mesh._state;const materialState=mesh._material._state;const geometryState=mesh._geometry._state;if(frame.lastProgramId!==this._program.id){frame.lastProgramId=this._program.id;this._bindProgram(frame)}
if(materialState.id!==this._lastMaterialId){frame.textureUnit=this._baseTextureUnit;const backfaces=materialState.backfaces;if(frame.backfaces!==backfaces){if(backfaces){gl.disable(gl.CULL_FACE)}else{gl.enable(gl.CULL_FACE)}
frame.backfaces=backfaces}
const frontface=materialState.frontface;if(frame.frontface!==frontface){if(frontface){gl.frontFace(gl.CCW)}else{gl.frontFace(gl.CW)}
frame.frontface=frontface}
if(frame.lineWidth!==materialState.lineWidth){gl.lineWidth(materialState.lineWidth);frame.lineWidth=materialState.lineWidth}
if(this._uPointSize){gl.uniform1f(this._uPointSize,materialState.pointSize)}
switch(materialState.type){case "LambertMaterial":if(this._uMaterialAmbient){gl.uniform3fv(this._uMaterialAmbient,materialState.ambient)}
if(this._uMaterialColor){gl.uniform4f(this._uMaterialColor,materialState.color[0],materialState.color[1],materialState.color[2],materialState.alpha)}
if(this._uMaterialEmissive){gl.uniform3fv(this._uMaterialEmissive,materialState.emissive)}
break;case "PhongMaterial":if(this._uMaterialShininess){gl.uniform1f(this._uMaterialShininess,materialState.shininess)}
if(this._uMaterialAmbient){gl.uniform3fv(this._uMaterialAmbient,materialState.ambient)}
if(this._uMaterialDiffuse){gl.uniform3fv(this._uMaterialDiffuse,materialState.diffuse)}
if(this._uMaterialSpecular){gl.uniform3fv(this._uMaterialSpecular,materialState.specular)}
if(this._uMaterialEmissive){gl.uniform3fv(this._uMaterialEmissive,materialState.emissive)}
if(this._uAlphaModeCutoff){gl.uniform4f(this._uAlphaModeCutoff,1.0*materialState.alpha,materialState.alphaMode===1?1.0:0.0,materialState.alphaCutoff,0)}
if(material._ambientMap&&material._ambientMap._state.texture&&this._uMaterialAmbientMap){program.bindTexture(this._uMaterialAmbientMap,material._ambientMap._state.texture,frame.textureUnit);frame.textureUnit=(frame.textureUnit+1)%maxTextureUnits;frame.bindTexture++;if(this._uMaterialAmbientMapMatrix){gl.uniformMatrix4fv(this._uMaterialAmbientMapMatrix,!1,material._ambientMap._state.matrix)}}
if(material._diffuseMap&&material._diffuseMap._state.texture&&this._uDiffuseMap){program.bindTexture(this._uDiffuseMap,material._diffuseMap._state.texture,frame.textureUnit);frame.textureUnit=(frame.textureUnit+1)%maxTextureUnits;frame.bindTexture++;if(this._uDiffuseMapMatrix){gl.uniformMatrix4fv(this._uDiffuseMapMatrix,!1,material._diffuseMap._state.matrix)}}
if(material._specularMap&&material._specularMap._state.texture&&this._uSpecularMap){program.bindTexture(this._uSpecularMap,material._specularMap._state.texture,frame.textureUnit);frame.textureUnit=(frame.textureUnit+1)%maxTextureUnits;frame.bindTexture++;if(this._uSpecularMapMatrix){gl.uniformMatrix4fv(this._uSpecularMapMatrix,!1,material._specularMap._state.matrix)}}
if(material._emissiveMap&&material._emissiveMap._state.texture&&this._uEmissiveMap){program.bindTexture(this._uEmissiveMap,material._emissiveMap._state.texture,frame.textureUnit);frame.textureUnit=(frame.textureUnit+1)%maxTextureUnits;frame.bindTexture++;if(this._uEmissiveMapMatrix){gl.uniformMatrix4fv(this._uEmissiveMapMatrix,!1,material._emissiveMap._state.matrix)}}
if(material._alphaMap&&material._alphaMap._state.texture&&this._uAlphaMap){program.bindTexture(this._uAlphaMap,material._alphaMap._state.texture,frame.textureUnit);frame.textureUnit=(frame.textureUnit+1)%maxTextureUnits;frame.bindTexture++;if(this._uAlphaMapMatrix){gl.uniformMatrix4fv(this._uAlphaMapMatrix,!1,material._alphaMap._state.matrix)}}
if(material._reflectivityMap&&material._reflectivityMap._state.texture&&this._uReflectivityMap){program.bindTexture(this._uReflectivityMap,material._reflectivityMap._state.texture,frame.textureUnit);frame.textureUnit=(frame.textureUnit+1)%maxTextureUnits;if(this._uReflectivityMapMatrix){gl.uniformMatrix4fv(this._uReflectivityMapMatrix,!1,material._reflectivityMap._state.matrix)}}
if(material._normalMap&&material._normalMap._state.texture&&this._uNormalMap){program.bindTexture(this._uNormalMap,material._normalMap._state.texture,frame.textureUnit);frame.textureUnit=(frame.textureUnit+1)%maxTextureUnits;frame.bindTexture++;if(this._uNormalMapMatrix){gl.uniformMatrix4fv(this._uNormalMapMatrix,!1,material._normalMap._state.matrix)}}
if(material._occlusionMap&&material._occlusionMap._state.texture&&this._uOcclusionMap){program.bindTexture(this._uOcclusionMap,material._occlusionMap._state.texture,frame.textureUnit);frame.textureUnit=(frame.textureUnit+1)%maxTextureUnits;frame.bindTexture++;if(this._uOcclusionMapMatrix){gl.uniformMatrix4fv(this._uOcclusionMapMatrix,!1,material._occlusionMap._state.matrix)}}
if(material._diffuseFresnel){if(this._uDiffuseFresnelEdgeBias){gl.uniform1f(this._uDiffuseFresnelEdgeBias,material._diffuseFresnel.edgeBias)}
if(this._uDiffuseFresnelCenterBias){gl.uniform1f(this._uDiffuseFresnelCenterBias,material._diffuseFresnel.centerBias)}
if(this._uDiffuseFresnelEdgeColor){gl.uniform3fv(this._uDiffuseFresnelEdgeColor,material._diffuseFresnel.edgeColor)}
if(this._uDiffuseFresnelCenterColor){gl.uniform3fv(this._uDiffuseFresnelCenterColor,material._diffuseFresnel.centerColor)}
if(this._uDiffuseFresnelPower){gl.uniform1f(this._uDiffuseFresnelPower,material._diffuseFresnel.power)}}
if(material._specularFresnel){if(this._uSpecularFresnelEdgeBias){gl.uniform1f(this._uSpecularFresnelEdgeBias,material._specularFresnel.edgeBias)}
if(this._uSpecularFresnelCenterBias){gl.uniform1f(this._uSpecularFresnelCenterBias,material._specularFresnel.centerBias)}
if(this._uSpecularFresnelEdgeColor){gl.uniform3fv(this._uSpecularFresnelEdgeColor,material._specularFresnel.edgeColor)}
if(this._uSpecularFresnelCenterColor){gl.uniform3fv(this._uSpecularFresnelCenterColor,material._specularFresnel.centerColor)}
if(this._uSpecularFresnelPower){gl.uniform1f(this._uSpecularFresnelPower,material._specularFresnel.power)}}
if(material._alphaFresnel){if(this._uAlphaFresnelEdgeBias){gl.uniform1f(this._uAlphaFresnelEdgeBias,material._alphaFresnel.edgeBias)}
if(this._uAlphaFresnelCenterBias){gl.uniform1f(this._uAlphaFresnelCenterBias,material._alphaFresnel.centerBias)}
if(this._uAlphaFresnelEdgeColor){gl.uniform3fv(this._uAlphaFresnelEdgeColor,material._alphaFresnel.edgeColor)}
if(this._uAlphaFresnelCenterColor){gl.uniform3fv(this._uAlphaFresnelCenterColor,material._alphaFresnel.centerColor)}
if(this._uAlphaFresnelPower){gl.uniform1f(this._uAlphaFresnelPower,material._alphaFresnel.power)}}
if(material._reflectivityFresnel){if(this._uReflectivityFresnelEdgeBias){gl.uniform1f(this._uReflectivityFresnelEdgeBias,material._reflectivityFresnel.edgeBias)}
if(this._uReflectivityFresnelCenterBias){gl.uniform1f(this._uReflectivityFresnelCenterBias,material._reflectivityFresnel.centerBias)}
if(this._uReflectivityFresnelEdgeColor){gl.uniform3fv(this._uReflectivityFresnelEdgeColor,material._reflectivityFresnel.edgeColor)}
if(this._uReflectivityFresnelCenterColor){gl.uniform3fv(this._uReflectivityFresnelCenterColor,material._reflectivityFresnel.centerColor)}
if(this._uReflectivityFresnelPower){gl.uniform1f(this._uReflectivityFresnelPower,material._reflectivityFresnel.power)}}
if(material._emissiveFresnel){if(this._uEmissiveFresnelEdgeBias){gl.uniform1f(this._uEmissiveFresnelEdgeBias,material._emissiveFresnel.edgeBias)}
if(this._uEmissiveFresnelCenterBias){gl.uniform1f(this._uEmissiveFresnelCenterBias,material._emissiveFresnel.centerBias)}
if(this._uEmissiveFresnelEdgeColor){gl.uniform3fv(this._uEmissiveFresnelEdgeColor,material._emissiveFresnel.edgeColor)}
if(this._uEmissiveFresnelCenterColor){gl.uniform3fv(this._uEmissiveFresnelCenterColor,material._emissiveFresnel.centerColor)}
if(this._uEmissiveFresnelPower){gl.uniform1f(this._uEmissiveFresnelPower,material._emissiveFresnel.power)}}
break;case "MetallicMaterial":if(this._uBaseColor){gl.uniform3fv(this._uBaseColor,materialState.baseColor)}
if(this._uMaterialMetallic){gl.uniform1f(this._uMaterialMetallic,materialState.metallic)}
if(this._uMaterialRoughness){gl.uniform1f(this._uMaterialRoughness,materialState.roughness)}
if(this._uMaterialSpecularF0){gl.uniform1f(this._uMaterialSpecularF0,materialState.specularF0)}
if(this._uMaterialEmissive){gl.uniform3fv(this._uMaterialEmissive,materialState.emissive)}
if(this._uAlphaModeCutoff){gl.uniform4f(this._uAlphaModeCutoff,1.0*materialState.alpha,materialState.alphaMode===1?1.0:0.0,materialState.alphaCutoff,0.0)}
const baseColorMap=material._baseColorMap;if(baseColorMap&&baseColorMap._state.texture&&this._uBaseColorMap){program.bindTexture(this._uBaseColorMap,baseColorMap._state.texture,frame.textureUnit);frame.textureUnit=(frame.textureUnit+1)%maxTextureUnits;frame.bindTexture++;if(this._uBaseColorMapMatrix){gl.uniformMatrix4fv(this._uBaseColorMapMatrix,!1,baseColorMap._state.matrix)}}
const metallicMap=material._metallicMap;if(metallicMap&&metallicMap._state.texture&&this._uMetallicMap){program.bindTexture(this._uMetallicMap,metallicMap._state.texture,frame.textureUnit);frame.textureUnit=(frame.textureUnit+1)%maxTextureUnits;frame.bindTexture++;if(this._uMetallicMapMatrix){gl.uniformMatrix4fv(this._uMetallicMapMatrix,!1,metallicMap._state.matrix)}}
const roughnessMap=material._roughnessMap;if(roughnessMap&&roughnessMap._state.texture&&this._uRoughnessMap){program.bindTexture(this._uRoughnessMap,roughnessMap._state.texture,frame.textureUnit);frame.textureUnit=(frame.textureUnit+1)%maxTextureUnits;frame.bindTexture++;if(this._uRoughnessMapMatrix){gl.uniformMatrix4fv(this._uRoughnessMapMatrix,!1,roughnessMap._state.matrix)}}
const metallicRoughnessMap=material._metallicRoughnessMap;if(metallicRoughnessMap&&metallicRoughnessMap._state.texture&&this._uMetallicRoughnessMap){program.bindTexture(this._uMetallicRoughnessMap,metallicRoughnessMap._state.texture,frame.textureUnit);frame.textureUnit=(frame.textureUnit+1)%maxTextureUnits;frame.bindTexture++;if(this._uMetallicRoughnessMapMatrix){gl.uniformMatrix4fv(this._uMetallicRoughnessMapMatrix,!1,metallicRoughnessMap._state.matrix)}}
var emissiveMap=material._emissiveMap;if(emissiveMap&&emissiveMap._state.texture&&this._uEmissiveMap){program.bindTexture(this._uEmissiveMap,emissiveMap._state.texture,frame.textureUnit);frame.textureUnit=(frame.textureUnit+1)%maxTextureUnits;frame.bindTexture++;if(this._uEmissiveMapMatrix){gl.uniformMatrix4fv(this._uEmissiveMapMatrix,!1,emissiveMap._state.matrix)}}
var occlusionMap=material._occlusionMap;if(occlusionMap&&material._occlusionMap._state.texture&&this._uOcclusionMap){program.bindTexture(this._uOcclusionMap,occlusionMap._state.texture,frame.textureUnit);frame.textureUnit=(frame.textureUnit+1)%maxTextureUnits;frame.bindTexture++;if(this._uOcclusionMapMatrix){gl.uniformMatrix4fv(this._uOcclusionMapMatrix,!1,occlusionMap._state.matrix)}}
var alphaMap=material._alphaMap;if(alphaMap&&alphaMap._state.texture&&this._uAlphaMap){program.bindTexture(this._uAlphaMap,alphaMap._state.texture,frame.textureUnit);frame.textureUnit=(frame.textureUnit+1)%maxTextureUnits;frame.bindTexture++;if(this._uAlphaMapMatrix){gl.uniformMatrix4fv(this._uAlphaMapMatrix,!1,alphaMap._state.matrix)}}
var normalMap=material._normalMap;if(normalMap&&normalMap._state.texture&&this._uNormalMap){program.bindTexture(this._uNormalMap,normalMap._state.texture,frame.textureUnit);frame.textureUnit=(frame.textureUnit+1)%maxTextureUnits;frame.bindTexture++;if(this._uNormalMapMatrix){gl.uniformMatrix4fv(this._uNormalMapMatrix,!1,normalMap._state.matrix)}}
break;case "SpecularMaterial":if(this._uMaterialDiffuse){gl.uniform3fv(this._uMaterialDiffuse,materialState.diffuse)}
if(this._uMaterialSpecular){gl.uniform3fv(this._uMaterialSpecular,materialState.specular)}
if(this._uMaterialGlossiness){gl.uniform1f(this._uMaterialGlossiness,materialState.glossiness)}
if(this._uMaterialReflectivity){gl.uniform1f(this._uMaterialReflectivity,materialState.reflectivity)}
if(this._uMaterialEmissive){gl.uniform3fv(this._uMaterialEmissive,materialState.emissive)}
if(this._uAlphaModeCutoff){gl.uniform4f(this._uAlphaModeCutoff,1.0*materialState.alpha,materialState.alphaMode===1?1.0:0.0,materialState.alphaCutoff,0.0)}
const diffuseMap=material._diffuseMap;if(diffuseMap&&diffuseMap._state.texture&&this._uDiffuseMap){program.bindTexture(this._uDiffuseMap,diffuseMap._state.texture,frame.textureUnit);frame.textureUnit=(frame.textureUnit+1)%maxTextureUnits;frame.bindTexture++;if(this._uDiffuseMapMatrix){gl.uniformMatrix4fv(this._uDiffuseMapMatrix,!1,diffuseMap._state.matrix)}}
const specularMap=material._specularMap;if(specularMap&&specularMap._state.texture&&this._uSpecularMap){program.bindTexture(this._uSpecularMap,specularMap._state.texture,frame.textureUnit);frame.textureUnit=(frame.textureUnit+1)%maxTextureUnits;frame.bindTexture++;if(this._uSpecularMapMatrix){gl.uniformMatrix4fv(this._uSpecularMapMatrix,!1,specularMap._state.matrix)}}
const glossinessMap=material._glossinessMap;if(glossinessMap&&glossinessMap._state.texture&&this._uGlossinessMap){program.bindTexture(this._uGlossinessMap,glossinessMap._state.texture,frame.textureUnit);frame.textureUnit=(frame.textureUnit+1)%maxTextureUnits;frame.bindTexture++;if(this._uGlossinessMapMatrix){gl.uniformMatrix4fv(this._uGlossinessMapMatrix,!1,glossinessMap._state.matrix)}}
const specularGlossinessMap=material._specularGlossinessMap;if(specularGlossinessMap&&specularGlossinessMap._state.texture&&this._uSpecularGlossinessMap){program.bindTexture(this._uSpecularGlossinessMap,specularGlossinessMap._state.texture,frame.textureUnit);frame.textureUnit=(frame.textureUnit+1)%maxTextureUnits;frame.bindTexture++;if(this._uSpecularGlossinessMapMatrix){gl.uniformMatrix4fv(this._uSpecularGlossinessMapMatrix,!1,specularGlossinessMap._state.matrix)}}
var emissiveMap=material._emissiveMap;if(emissiveMap&&emissiveMap._state.texture&&this._uEmissiveMap){program.bindTexture(this._uEmissiveMap,emissiveMap._state.texture,frame.textureUnit);frame.textureUnit=(frame.textureUnit+1)%maxTextureUnits;frame.bindTexture++;if(this._uEmissiveMapMatrix){gl.uniformMatrix4fv(this._uEmissiveMapMatrix,!1,emissiveMap._state.matrix)}}
var occlusionMap=material._occlusionMap;if(occlusionMap&&occlusionMap._state.texture&&this._uOcclusionMap){program.bindTexture(this._uOcclusionMap,occlusionMap._state.texture,frame.textureUnit);frame.textureUnit=(frame.textureUnit+1)%maxTextureUnits;frame.bindTexture++;if(this._uOcclusionMapMatrix){gl.uniformMatrix4fv(this._uOcclusionMapMatrix,!1,occlusionMap._state.matrix)}}
var alphaMap=material._alphaMap;if(alphaMap&&alphaMap._state.texture&&this._uAlphaMap){program.bindTexture(this._uAlphaMap,alphaMap._state.texture,frame.textureUnit);frame.textureUnit=(frame.textureUnit+1)%maxTextureUnits;frame.bindTexture++;if(this._uAlphaMapMatrix){gl.uniformMatrix4fv(this._uAlphaMapMatrix,!1,alphaMap._state.matrix)}}
var normalMap=material._normalMap;if(normalMap&&normalMap._state.texture&&this._uNormalMap){program.bindTexture(this._uNormalMap,normalMap._state.texture,frame.textureUnit);frame.textureUnit=(frame.textureUnit+1)%maxTextureUnits;frame.bindTexture++;if(this._uNormalMapMatrix){gl.uniformMatrix4fv(this._uNormalMapMatrix,!1,normalMap._state.matrix)}}
break}
this._lastMaterialId=materialState.id}
gl.uniformMatrix4fv(this._uModelMatrix,gl.FALSE,mesh.worldMatrix);if(this._uModelNormalMatrix){gl.uniformMatrix4fv(this._uModelNormalMatrix,gl.FALSE,mesh.worldNormalMatrix)}
if(this._uClippable){gl.uniform1i(this._uClippable,meshState.clippable)}
if(this._uColorize){const colorize=meshState.colorize;const lastColorize=this._lastColorize;if(lastColorize[0]!==colorize[0]||lastColorize[1]!==colorize[1]||lastColorize[2]!==colorize[2]||lastColorize[3]!==colorize[3]){gl.uniform4fv(this._uColorize,colorize);lastColorize[0]=colorize[0];lastColorize[1]=colorize[1];lastColorize[2]=colorize[2];lastColorize[3]=colorize[3]}}
if(geometryState.combined){const vertexBufs=mesh._geometry._getVertexBufs();if(vertexBufs.id!==this._lastVertexBufsId){if(vertexBufs.positionsBuf&&this._aPosition){this._aPosition.bindArrayBuffer(vertexBufs.positionsBuf,vertexBufs.quantized?gl.UNSIGNED_SHORT:gl.FLOAT);frame.bindArray++}
if(vertexBufs.normalsBuf&&this._aNormal){this._aNormal.bindArrayBuffer(vertexBufs.normalsBuf,vertexBufs.quantized?gl.BYTE:gl.FLOAT);frame.bindArray++}
if(vertexBufs.uvBuf&&this._aUV){this._aUV.bindArrayBuffer(vertexBufs.uvBuf,geometryState.quantized?gl.UNSIGNED_SHORT:gl.FLOAT);frame.bindArray++}
if(vertexBufs.colorsBuf&&this._aColor){this._aColor.bindArrayBuffer(vertexBufs.colorsBuf);frame.bindArray++}
if(vertexBufs.flagsBuf&&this._aFlags){this._aFlags.bindArrayBuffer(vertexBufs.flagsBuf,gl.UNSIGNED_SHORT);frame.bindArray++}
this._lastVertexBufsId=vertexBufs.id}}
if(geometryState.id!==this._lastGeometryId){if(this._uPositionsDecodeMatrix){gl.uniformMatrix4fv(this._uPositionsDecodeMatrix,!1,geometryState.positionsDecodeMatrix)}
if(this._uUVDecodeMatrix){gl.uniformMatrix3fv(this._uUVDecodeMatrix,!1,geometryState.uvDecodeMatrix)}
if(geometryState.combined){if(geometryState.indicesBufCombined){geometryState.indicesBufCombined.bind();frame.bindArray++}}else{if(this._aPosition){this._aPosition.bindArrayBuffer(geometryState.positionsBuf,geometryState.quantized?gl.UNSIGNED_SHORT:gl.FLOAT);frame.bindArray++}
if(this._aNormal){this._aNormal.bindArrayBuffer(geometryState.normalsBuf,geometryState.quantized?gl.BYTE:gl.FLOAT);frame.bindArray++}
if(this._aUV){this._aUV.bindArrayBuffer(geometryState.uvBuf,geometryState.quantized?gl.UNSIGNED_SHORT:gl.FLOAT);frame.bindArray++}
if(this._aColor){this._aColor.bindArrayBuffer(geometryState.colorsBuf);frame.bindArray++}
if(this._aFlags){this._aFlags.bindArrayBuffer(geometryState.flagsBuf);frame.bindArray++}
if(geometryState.indicesBuf){geometryState.indicesBuf.bind();frame.bindArray++}else if(geometryState.positions){}}
this._lastGeometryId=geometryState.id}
if(geometryState.combined){if(geometryState.indicesBufCombined){gl.drawElements(geometryState.primitive,geometryState.indicesBufCombined.numItems,geometryState.indicesBufCombined.itemType,0);frame.drawElements++}else{}}else{if(geometryState.indicesBuf){gl.drawElements(geometryState.primitive,geometryState.indicesBuf.numItems,geometryState.indicesBuf.itemType,0);frame.drawElements++}else if(geometryState.positions){gl.drawArrays(gl.TRIANGLES,0,geometryState.positions.numItems);frame.drawArrays++}}};DrawRenderer.prototype._allocate=function(mesh){const gl=mesh.scene.canvas.gl;const material=mesh._material;const lightsState=mesh.scene._lightsState;const clipsState=mesh.scene._clipsState;const materialState=mesh._material._state;this._program=new Program(gl,this._shaderSource);if(this._program.errors){this.errors=this._program.errors;return}
const program=this._program;this._uPositionsDecodeMatrix=program.getLocation("positionsDecodeMatrix");this._uUVDecodeMatrix=program.getLocation("uvDecodeMatrix");this._uModelMatrix=program.getLocation("modelMatrix");this._uModelNormalMatrix=program.getLocation("modelNormalMatrix");this._uViewMatrix=program.getLocation("viewMatrix");this._uViewNormalMatrix=program.getLocation("viewNormalMatrix");this._uProjMatrix=program.getLocation("projMatrix");this._uGammaFactor=program.getLocation("gammaFactor");this._uLightAmbient=[];this._uLightColor=[];this._uLightDir=[];this._uLightPos=[];this._uLightAttenuation=[];this._uShadowViewMatrix=[];this._uShadowProjMatrix=[];const lights=lightsState.lights;let light;for(var i=0,len=lights.length;i<len;i++){light=lights[i];switch(light.type){case "ambient":this._uLightAmbient[i]=program.getLocation("lightAmbient");break;case "dir":this._uLightColor[i]=program.getLocation("lightColor"+i);this._uLightPos[i]=null;this._uLightDir[i]=program.getLocation("lightDir"+i);break;case "point":this._uLightColor[i]=program.getLocation("lightColor"+i);this._uLightPos[i]=program.getLocation("lightPos"+i);this._uLightDir[i]=null;this._uLightAttenuation[i]=program.getLocation("lightAttenuation"+i);break;case "spot":this._uLightColor[i]=program.getLocation("lightColor"+i);this._uLightPos[i]=program.getLocation("lightPos"+i);this._uLightDir[i]=program.getLocation("lightDir"+i);this._uLightAttenuation[i]=program.getLocation("lightAttenuation"+i);break}
if(light.shadow){this._uShadowViewMatrix[i]=program.getLocation("shadowViewMatrix"+i);this._uShadowProjMatrix[i]=program.getLocation("shadowProjMatrix"+i)}}
if(lightsState.lightMaps.length>0){this._uLightMap="lightMap"}
if(lightsState.reflectionMaps.length>0){this._uReflectionMap="reflectionMap"}
this._uClips=[];const clips=clipsState.clips;for(var i=0,len=clips.length;i<len;i++){this._uClips.push({active:program.getLocation("clipActive"+i),pos:program.getLocation("clipPos"+i),dir:program.getLocation("clipDir"+i)})}
this._uPointSize=program.getLocation("pointSize");switch(materialState.type){case "LambertMaterial":this._uMaterialColor=program.getLocation("materialColor");this._uMaterialEmissive=program.getLocation("materialEmissive");this._uAlphaModeCutoff=program.getLocation("materialAlphaModeCutoff");break;case "PhongMaterial":this._uMaterialAmbient=program.getLocation("materialAmbient");this._uMaterialDiffuse=program.getLocation("materialDiffuse");this._uMaterialSpecular=program.getLocation("materialSpecular");this._uMaterialEmissive=program.getLocation("materialEmissive");this._uAlphaModeCutoff=program.getLocation("materialAlphaModeCutoff");this._uMaterialShininess=program.getLocation("materialShininess");if(material._ambientMap){this._uMaterialAmbientMap="ambientMap";this._uMaterialAmbientMapMatrix=program.getLocation("ambientMapMatrix")}
if(material._diffuseMap){this._uDiffuseMap="diffuseMap";this._uDiffuseMapMatrix=program.getLocation("diffuseMapMatrix")}
if(material._specularMap){this._uSpecularMap="specularMap";this._uSpecularMapMatrix=program.getLocation("specularMapMatrix")}
if(material._emissiveMap){this._uEmissiveMap="emissiveMap";this._uEmissiveMapMatrix=program.getLocation("emissiveMapMatrix")}
if(material._alphaMap){this._uAlphaMap="alphaMap";this._uAlphaMapMatrix=program.getLocation("alphaMapMatrix")}
if(material._reflectivityMap){this._uReflectivityMap="reflectivityMap";this._uReflectivityMapMatrix=program.getLocation("reflectivityMapMatrix")}
if(material._normalMap){this._uNormalMap="normalMap";this._uNormalMapMatrix=program.getLocation("normalMapMatrix")}
if(material._occlusionMap){this._uOcclusionMap="occlusionMap";this._uOcclusionMapMatrix=program.getLocation("occlusionMapMatrix")}
if(material._diffuseFresnel){this._uDiffuseFresnelEdgeBias=program.getLocation("diffuseFresnelEdgeBias");this._uDiffuseFresnelCenterBias=program.getLocation("diffuseFresnelCenterBias");this._uDiffuseFresnelEdgeColor=program.getLocation("diffuseFresnelEdgeColor");this._uDiffuseFresnelCenterColor=program.getLocation("diffuseFresnelCenterColor");this._uDiffuseFresnelPower=program.getLocation("diffuseFresnelPower")}
if(material._specularFresnel){this._uSpecularFresnelEdgeBias=program.getLocation("specularFresnelEdgeBias");this._uSpecularFresnelCenterBias=program.getLocation("specularFresnelCenterBias");this._uSpecularFresnelEdgeColor=program.getLocation("specularFresnelEdgeColor");this._uSpecularFresnelCenterColor=program.getLocation("specularFresnelCenterColor");this._uSpecularFresnelPower=program.getLocation("specularFresnelPower")}
if(material._alphaFresnel){this._uAlphaFresnelEdgeBias=program.getLocation("alphaFresnelEdgeBias");this._uAlphaFresnelCenterBias=program.getLocation("alphaFresnelCenterBias");this._uAlphaFresnelEdgeColor=program.getLocation("alphaFresnelEdgeColor");this._uAlphaFresnelCenterColor=program.getLocation("alphaFresnelCenterColor");this._uAlphaFresnelPower=program.getLocation("alphaFresnelPower")}
if(material._reflectivityFresnel){this._uReflectivityFresnelEdgeBias=program.getLocation("reflectivityFresnelEdgeBias");this._uReflectivityFresnelCenterBias=program.getLocation("reflectivityFresnelCenterBias");this._uReflectivityFresnelEdgeColor=program.getLocation("reflectivityFresnelEdgeColor");this._uReflectivityFresnelCenterColor=program.getLocation("reflectivityFresnelCenterColor");this._uReflectivityFresnelPower=program.getLocation("reflectivityFresnelPower")}
if(material._emissiveFresnel){this._uEmissiveFresnelEdgeBias=program.getLocation("emissiveFresnelEdgeBias");this._uEmissiveFresnelCenterBias=program.getLocation("emissiveFresnelCenterBias");this._uEmissiveFresnelEdgeColor=program.getLocation("emissiveFresnelEdgeColor");this._uEmissiveFresnelCenterColor=program.getLocation("emissiveFresnelCenterColor");this._uEmissiveFresnelPower=program.getLocation("emissiveFresnelPower")}
break;case "MetallicMaterial":this._uBaseColor=program.getLocation("materialBaseColor");this._uMaterialMetallic=program.getLocation("materialMetallic");this._uMaterialRoughness=program.getLocation("materialRoughness");this._uMaterialSpecularF0=program.getLocation("materialSpecularF0");this._uMaterialEmissive=program.getLocation("materialEmissive");this._uAlphaModeCutoff=program.getLocation("materialAlphaModeCutoff");if(material._baseColorMap){this._uBaseColorMap="baseColorMap";this._uBaseColorMapMatrix=program.getLocation("baseColorMapMatrix")}
if(material._metallicMap){this._uMetallicMap="metallicMap";this._uMetallicMapMatrix=program.getLocation("metallicMapMatrix")}
if(material._roughnessMap){this._uRoughnessMap="roughnessMap";this._uRoughnessMapMatrix=program.getLocation("roughnessMapMatrix")}
if(material._metallicRoughnessMap){this._uMetallicRoughnessMap="metallicRoughnessMap";this._uMetallicRoughnessMapMatrix=program.getLocation("metallicRoughnessMapMatrix")}
if(material._emissiveMap){this._uEmissiveMap="emissiveMap";this._uEmissiveMapMatrix=program.getLocation("emissiveMapMatrix")}
if(material._occlusionMap){this._uOcclusionMap="occlusionMap";this._uOcclusionMapMatrix=program.getLocation("occlusionMapMatrix")}
if(material._alphaMap){this._uAlphaMap="alphaMap";this._uAlphaMapMatrix=program.getLocation("alphaMapMatrix")}
if(material._normalMap){this._uNormalMap="normalMap";this._uNormalMapMatrix=program.getLocation("normalMapMatrix")}
break;case "SpecularMaterial":this._uMaterialDiffuse=program.getLocation("materialDiffuse");this._uMaterialSpecular=program.getLocation("materialSpecular");this._uMaterialGlossiness=program.getLocation("materialGlossiness");this._uMaterialReflectivity=program.getLocation("reflectivityFresnel");this._uMaterialEmissive=program.getLocation("materialEmissive");this._uAlphaModeCutoff=program.getLocation("materialAlphaModeCutoff");if(material._diffuseMap){this._uDiffuseMap="diffuseMap";this._uDiffuseMapMatrix=program.getLocation("diffuseMapMatrix")}
if(material._specularMap){this._uSpecularMap="specularMap";this._uSpecularMapMatrix=program.getLocation("specularMapMatrix")}
if(material._glossinessMap){this._uGlossinessMap="glossinessMap";this._uGlossinessMapMatrix=program.getLocation("glossinessMapMatrix")}
if(material._specularGlossinessMap){this._uSpecularGlossinessMap="materialSpecularGlossinessMap";this._uSpecularGlossinessMapMatrix=program.getLocation("materialSpecularGlossinessMapMatrix")}
if(material._emissiveMap){this._uEmissiveMap="emissiveMap";this._uEmissiveMapMatrix=program.getLocation("emissiveMapMatrix")}
if(material._occlusionMap){this._uOcclusionMap="occlusionMap";this._uOcclusionMapMatrix=program.getLocation("occlusionMapMatrix")}
if(material._alphaMap){this._uAlphaMap="alphaMap";this._uAlphaMapMatrix=program.getLocation("alphaMapMatrix")}
if(material._normalMap){this._uNormalMap="normalMap";this._uNormalMapMatrix=program.getLocation("normalMapMatrix")}
break}
this._aPosition=program.getAttribute("position");this._aNormal=program.getAttribute("normal");this._aUV=program.getAttribute("uv");this._aColor=program.getAttribute("color");this._aFlags=program.getAttribute("flags");this._uClippable=program.getLocation("clippable");this._uColorize=program.getLocation("colorize");this._lastMaterialId=null;this._lastVertexBufsId=null;this._lastGeometryId=null;this._lastColorize=new Float32Array(4);this._baseTextureUnit=0};DrawRenderer.prototype._bindProgram=function(frame){const maxTextureUnits=WEBGL_INFO.MAX_TEXTURE_UNITS;const scene=this._scene;const gl=scene.canvas.gl;const lightsState=scene._lightsState;const clipsState=scene._clipsState;const lights=lightsState.lights;let light;const program=this._program;program.bind();frame.useProgram++;frame.textureUnit=0;this._lastMaterialId=null;this._lastVertexBufsId=null;this._lastGeometryId=null;this._lastColorize[0]=-1;this._lastColorize[1]=-1;this._lastColorize[2]=-1;this._lastColorize[3]=-1;const camera=scene.camera;const cameraState=camera._state;gl.uniformMatrix4fv(this._uViewMatrix,!1,cameraState.matrix);gl.uniformMatrix4fv(this._uViewNormalMatrix,!1,cameraState.normalMatrix);gl.uniformMatrix4fv(this._uProjMatrix,!1,camera._project._state.matrix);for(var i=0,len=lightsState.lights.length;i<len;i++){light=lightsState.lights[i];if(this._uLightAmbient[i]){gl.uniform4f(this._uLightAmbient[i],light.color[0],light.color[1],light.color[2],light.intensity)}else{if(this._uLightColor[i]){gl.uniform4f(this._uLightColor[i],light.color[0],light.color[1],light.color[2],light.intensity)}
if(this._uLightPos[i]){gl.uniform3fv(this._uLightPos[i],light.pos);if(this._uLightAttenuation[i]){gl.uniform1f(this._uLightAttenuation[i],light.attenuation)}}
if(this._uLightDir[i]){gl.uniform3fv(this._uLightDir[i],light.dir)}
if(light.shadow){if(this._uShadowViewMatrix[i]){gl.uniformMatrix4fv(this._uShadowViewMatrix[i],!1,light.getShadowViewMatrix())}
if(this._uShadowProjMatrix[i]){gl.uniformMatrix4fv(this._uShadowProjMatrix[i],!1,light.getShadowProjMatrix())}
const shadowRenderBuf=light.getShadowRenderBuf();if(shadowRenderBuf){program.bindTexture("shadowMap"+i,shadowRenderBuf.getTexture(),frame.textureUnit);frame.textureUnit=(frame.textureUnit+1)%maxTextureUnits;frame.bindTexture++}}}}
if(lightsState.lightMaps.length>0&&lightsState.lightMaps[0].texture&&this._uLightMap){program.bindTexture(this._uLightMap,lightsState.lightMaps[0].texture,frame.textureUnit);frame.textureUnit=(frame.textureUnit+1)%maxTextureUnits;frame.bindTexture++}
if(lightsState.reflectionMaps.length>0&&lightsState.reflectionMaps[0].texture&&this._uReflectionMap){program.bindTexture(this._uReflectionMap,lightsState.reflectionMaps[0].texture,frame.textureUnit);frame.textureUnit=(frame.textureUnit+1)%maxTextureUnits;frame.bindTexture++}
if(clipsState.clips.length>0){const clips=scene._clipsState.clips;let clipUniforms;let uClipActive;let clip;let uClipPos;let uClipDir;for(var i=0,len=this._uClips.length;i<len;i++){clipUniforms=this._uClips[i];uClipActive=clipUniforms.active;clip=clips[i];if(uClipActive){gl.uniform1i(uClipActive,clip.active)}
uClipPos=clipUniforms.pos;if(uClipPos){gl.uniform3fv(clipUniforms.pos,clip.pos)}
uClipDir=clipUniforms.dir;if(uClipDir){gl.uniform3fv(clipUniforms.dir,clip.dir)}}}
if(this._uGammaFactor){gl.uniform1f(this._uGammaFactor,scene.gammaFactor)}
this._baseTextureUnit=frame.textureUnit};class EmphasisFillShaderSource{constructor(mesh){this.vertex=buildVertex(mesh);this.fragment=buildFragment(mesh)}}
function buildVertex(mesh){const scene=mesh.scene;const lightsState=scene._lightsState;const normals=hasNormals$1(mesh);const clipping=scene._clipsState.clips.length>0;const quantizedGeometry=!!mesh._geometry._state.quantized;const billboard=mesh._state.billboard;const stationary=mesh._state.stationary;const src=[];let i;let len;let light;src.push("// EmphasisFillShaderSource vertex shader");src.push("attribute vec3 position;");src.push("uniform mat4 modelMatrix;");src.push("uniform mat4 viewMatrix;");src.push("uniform mat4 projMatrix;");src.push("uniform vec4 colorize;");if(quantizedGeometry){src.push("uniform mat4 positionsDecodeMatrix;")}
if(clipping){src.push("varying vec4 vWorldPosition;")}
src.push("uniform vec4   lightAmbient;");src.push("uniform vec4   fillColor;");if(normals){src.push("attribute vec3 normal;");src.push("uniform mat4 modelNormalMatrix;");src.push("uniform mat4 viewNormalMatrix;");for(i=0,len=lightsState.lights.length;i<len;i++){light=lightsState.lights[i];if(light.type==="ambient"){continue}
src.push("uniform vec4 lightColor"+i+";");if(light.type==="dir"){src.push("uniform vec3 lightDir"+i+";")}
if(light.type==="point"){src.push("uniform vec3 lightPos"+i+";")}
if(light.type==="spot"){src.push("uniform vec3 lightPos"+i+";")}}
if(quantizedGeometry){src.push("vec3 octDecode(vec2 oct) {");src.push("    vec3 v = vec3(oct.xy, 1.0 - abs(oct.x) - abs(oct.y));");src.push("    if (v.z < 0.0) {");src.push("        v.xy = (1.0 - abs(v.yx)) * vec2(v.x >= 0.0 ? 1.0 : -1.0, v.y >= 0.0 ? 1.0 : -1.0);");src.push("    }");src.push("    return normalize(v);");src.push("}")}}
src.push("varying vec4 vColor;");if(billboard==="spherical"||billboard==="cylindrical"){src.push("void billboard(inout mat4 mat) {");src.push("   mat[0][0] = 1.0;");src.push("   mat[0][1] = 0.0;");src.push("   mat[0][2] = 0.0;");if(billboard==="spherical"){src.push("   mat[1][0] = 0.0;");src.push("   mat[1][1] = 1.0;");src.push("   mat[1][2] = 0.0;")}
src.push("   mat[2][0] = 0.0;");src.push("   mat[2][1] = 0.0;");src.push("   mat[2][2] =1.0;");src.push("}")}
src.push("void main(void) {");src.push("vec4 localPosition = vec4(position, 1.0); ");src.push("vec4 worldPosition;");if(quantizedGeometry){src.push("localPosition = positionsDecodeMatrix * localPosition;")}
if(normals){if(quantizedGeometry){src.push("vec4 localNormal = vec4(octDecode(normal.xy), 0.0); ")}else{src.push("vec4 localNormal = vec4(normal, 0.0); ")}
src.push("mat4 modelNormalMatrix2 = modelNormalMatrix;");src.push("mat4 viewNormalMatrix2 = viewNormalMatrix;")}
src.push("mat4 viewMatrix2 = viewMatrix;");src.push("mat4 modelMatrix2 = modelMatrix;");if(stationary){src.push("viewMatrix2[3][0] = viewMatrix2[3][1] = viewMatrix2[3][2] = 0.0;")}
if(billboard==="spherical"||billboard==="cylindrical"){src.push("mat4 modelViewMatrix = viewMatrix2 * modelMatrix2;");src.push("billboard(modelMatrix2);");src.push("billboard(viewMatrix2);");src.push("billboard(modelViewMatrix);");if(normals){src.push("mat4 modelViewNormalMatrix =  viewNormalMatrix2 * modelNormalMatrix2;");src.push("billboard(modelNormalMatrix2);");src.push("billboard(viewNormalMatrix2);");src.push("billboard(modelViewNormalMatrix);")}
src.push("worldPosition = modelMatrix2 * localPosition;");src.push("vec4 viewPosition = modelViewMatrix * localPosition;")}else{src.push("worldPosition = modelMatrix2 * localPosition;");src.push("vec4 viewPosition  = viewMatrix2 * worldPosition; ")}
if(normals){src.push("vec3 viewNormal = normalize((viewNormalMatrix2 * modelNormalMatrix2 * localNormal).xyz);")}
src.push("vec3 reflectedColor = vec3(0.0, 0.0, 0.0);");src.push("vec3 viewLightDir = vec3(0.0, 0.0, -1.0);");src.push("float lambertian = 1.0;");if(normals){for(i=0,len=lightsState.lights.length;i<len;i++){light=lightsState.lights[i];if(light.type==="ambient"){continue}
if(light.type==="dir"){if(light.space==="view"){src.push("viewLightDir = normalize(lightDir"+i+");")}else{src.push("viewLightDir = normalize((viewMatrix2 * vec4(lightDir"+i+", 0.0)).xyz);")}}else if(light.type==="point"){if(light.space==="view"){src.push("viewLightDir = normalize(lightPos"+i+" - viewPosition.xyz);")}else{src.push("viewLightDir = normalize((viewMatrix2 * vec4(lightPos"+i+", 0.0)).xyz);")}}else{continue}
src.push("lambertian = max(dot(-viewNormal, viewLightDir), 0.0);");src.push("reflectedColor += lambertian * (lightColor"+i+".rgb * lightColor"+i+".a);")}}
src.push("vColor = vec4(reflectedColor * fillColor.rgb, fillColor.a);");if(clipping){src.push("vWorldPosition = worldPosition;")}
if(mesh._geometry._state.primitiveName==="points"){src.push("gl_PointSize = pointSize;")}
src.push("   gl_Position = projMatrix * viewPosition;");src.push("}");return src}
function hasNormals$1(mesh){const primitive=mesh._geometry._state.primitiveName;if((mesh._geometry._state.autoVertexNormals||mesh._geometry._state.normals)&&(primitive==="triangles"||primitive==="triangle-strip"||primitive==="triangle-fan")){return!0}
return!1}
function buildFragment(mesh){const clipsState=mesh.scene._clipsState;const gammaOutput=mesh.scene.gammaOutput;const clipping=clipsState.clips.length>0;let i;let len;const src=[];src.push("// Lambertian drawing fragment shader");src.push("precision lowp float;");if(gammaOutput){src.push("uniform float gammaFactor;");src.push("vec4 linearToGamma( in vec4 value, in float gammaFactor ) {");src.push("  return vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );");src.push("}")}
if(clipping){src.push("varying vec4 vWorldPosition;");src.push("uniform bool clippable;");for(i=0,len=clipsState.clips.length;i<len;i++){src.push("uniform bool clipActive"+i+";");src.push("uniform vec3 clipPos"+i+";");src.push("uniform vec3 clipDir"+i+";")}}
src.push("varying vec4 vColor;");src.push("void main(void) {");if(clipping){src.push("if (clippable) {");src.push("  float dist = 0.0;");for(i=0,len=clipsState.clips.length;i<len;i++){src.push("if (clipActive"+i+") {");src.push("   dist += clamp(dot(-clipDir"+i+".xyz, vWorldPosition.xyz - clipPos"+i+".xyz), 0.0, 1000.0);");src.push("}")}
src.push("  if (dist > 0.0) { discard; }");src.push("}")}
if(mesh._geometry._state.primitiveName==="points"){src.push("vec2 cxy = 2.0 * gl_PointCoord - 1.0;");src.push("float r = dot(cxy, cxy);");src.push("if (r > 1.0) {");src.push("   discard;");src.push("}")}
src.push("gl_FragColor = vColor;");if(gammaOutput){src.push("gl_FragColor = linearToGamma(vColor, gammaFactor);")}else{src.push("gl_FragColor = vColor;")}
src.push("}");return src}
const ids$3=new Map({});const EmphasisFillRenderer=function(hash,mesh){this.id=ids$3.addItem({});this._hash=hash;this._scene=mesh.scene;this._useCount=0;this._shaderSource=new EmphasisFillShaderSource(mesh);this._allocate(mesh)};const ghostFillRenderers={};EmphasisFillRenderer.get=function(mesh){const hash=[mesh.scene.id,mesh.scene.gammaOutput?"go":"",mesh.scene._clipsState.getHash(),!!mesh._geometry.normals?"n":"",mesh._geometry._state.quantized?"cp":"",mesh._state.hash].join(";");let renderer=ghostFillRenderers[hash];if(!renderer){renderer=new EmphasisFillRenderer(hash,mesh);ghostFillRenderers[hash]=renderer;stats.memory.programs++}
renderer._useCount++;return renderer};EmphasisFillRenderer.prototype.put=function(){if(--this._useCount===0){ids$3.removeItem(this.id);if(this._program){this._program.destroy()}
delete ghostFillRenderers[this._hash];stats.memory.programs--}};EmphasisFillRenderer.prototype.webglContextRestored=function(){this._program=null};EmphasisFillRenderer.prototype.drawMesh=function(frame,mesh,mode){if(!this._program){this._allocate(mesh)}
const scene=this._scene;const gl=scene.canvas.gl;const materialState=mode===0?mesh._ghostMaterial._state:(mode===1?mesh._highlightMaterial._state:mesh._selectedMaterial._state);const meshState=mesh._state;const geometryState=mesh._geometry._state;if(frame.lastProgramId!==this._program.id){frame.lastProgramId=this._program.id;this._bindProgram(frame)}
if(materialState.id!==this._lastMaterialId){const fillColor=materialState.fillColor;const backfaces=materialState.backfaces;if(frame.backfaces!==backfaces){if(backfaces){gl.disable(gl.CULL_FACE)}else{gl.enable(gl.CULL_FACE)}
frame.backfaces=backfaces}
gl.uniform4f(this._uFillColor,fillColor[0],fillColor[1],fillColor[2],materialState.fillAlpha);this._lastMaterialId=materialState.id}
gl.uniformMatrix4fv(this._uModelMatrix,gl.FALSE,mesh.worldMatrix);if(this._uModelNormalMatrix){gl.uniformMatrix4fv(this._uModelNormalMatrix,gl.FALSE,mesh.worldNormalMatrix)}
if(this._uClippable){gl.uniform1i(this._uClippable,meshState.clippable)}
if(geometryState.combined){const vertexBufs=mesh._geometry._getVertexBufs();if(vertexBufs.id!==this._lastVertexBufsId){if(vertexBufs.positionsBuf&&this._aPosition){this._aPosition.bindArrayBuffer(vertexBufs.positionsBuf,vertexBufs.quantized?gl.UNSIGNED_SHORT:gl.FLOAT);frame.bindArray++}
if(vertexBufs.normalsBuf&&this._aNormal){this._aNormal.bindArrayBuffer(vertexBufs.normalsBuf,vertexBufs.quantized?gl.BYTE:gl.FLOAT);frame.bindArray++}
this._lastVertexBufsId=vertexBufs.id}}
if(geometryState.id!==this._lastGeometryId){if(this._uPositionsDecodeMatrix){gl.uniformMatrix4fv(this._uPositionsDecodeMatrix,!1,geometryState.positionsDecodeMatrix)}
if(this._uUVDecodeMatrix){gl.uniformMatrix3fv(this._uUVDecodeMatrix,!1,geometryState.uvDecodeMatrix)}
if(geometryState.combined){if(geometryState.indicesBufCombined){geometryState.indicesBufCombined.bind();frame.bindArray++}}else{if(this._aPosition){this._aPosition.bindArrayBuffer(geometryState.positionsBuf,geometryState.quantized?gl.UNSIGNED_SHORT:gl.FLOAT);frame.bindArray++}
if(this._aNormal){this._aNormal.bindArrayBuffer(geometryState.normalsBuf,geometryState.quantized?gl.BYTE:gl.FLOAT);frame.bindArray++}
if(geometryState.indicesBuf){geometryState.indicesBuf.bind();frame.bindArray++}else if(geometryState.positions){}}
this._lastGeometryId=geometryState.id}
if(geometryState.combined){if(geometryState.indicesBufCombined){gl.drawElements(geometryState.primitive,geometryState.indicesBufCombined.numItems,geometryState.indicesBufCombined.itemType,0);frame.drawElements++}else{}}else{if(geometryState.indicesBuf){gl.drawElements(geometryState.primitive,geometryState.indicesBuf.numItems,geometryState.indicesBuf.itemType,0);frame.drawElements++}else if(geometryState.positions){gl.drawArrays(gl.TRIANGLES,0,geometryState.positions.numItems);frame.drawArrays++}}};EmphasisFillRenderer.prototype._allocate=function(mesh){const lightsState=mesh.scene._lightsState;const clipsState=mesh.scene._clipsState;const gl=mesh.scene.canvas.gl;this._program=new Program(gl,this._shaderSource);if(this._program.errors){this.errors=this._program.errors;return}
const program=this._program;this._uPositionsDecodeMatrix=program.getLocation("positionsDecodeMatrix");this._uModelMatrix=program.getLocation("modelMatrix");this._uModelNormalMatrix=program.getLocation("modelNormalMatrix");this._uViewMatrix=program.getLocation("viewMatrix");this._uViewNormalMatrix=program.getLocation("viewNormalMatrix");this._uProjMatrix=program.getLocation("projMatrix");this._uLightAmbient=[];this._uLightColor=[];this._uLightDir=[];this._uLightPos=[];this._uLightAttenuation=[];for(var i=0,len=lightsState.lights.length;i<len;i++){const light=lightsState.lights[i];switch(light.type){case "ambient":this._uLightAmbient[i]=program.getLocation("lightAmbient");break;case "dir":this._uLightColor[i]=program.getLocation("lightColor"+i);this._uLightPos[i]=null;this._uLightDir[i]=program.getLocation("lightDir"+i);break;case "point":this._uLightColor[i]=program.getLocation("lightColor"+i);this._uLightPos[i]=program.getLocation("lightPos"+i);this._uLightDir[i]=null;this._uLightAttenuation[i]=program.getLocation("lightAttenuation"+i);break}}
this._uClips=[];for(var i=0,len=clipsState.clips.length;i<len;i++){this._uClips.push({active:program.getLocation("clipActive"+i),pos:program.getLocation("clipPos"+i),dir:program.getLocation("clipDir"+i)})}
this._uFillColor=program.getLocation("fillColor");this._aPosition=program.getAttribute("position");this._aNormal=program.getAttribute("normal");this._uClippable=program.getLocation("clippable");this._uGammaFactor=program.getLocation("gammaFactor");this._lastMaterialId=null;this._lastVertexBufsId=null;this._lastGeometryId=null};EmphasisFillRenderer.prototype._bindProgram=function(frame){const scene=this._scene;const gl=scene.canvas.gl;const clipsState=scene._clipsState;const lightsState=scene._lightsState;const camera=scene.camera;const cameraState=camera._state;let light;const program=this._program;program.bind();frame.useProgram++;frame.textureUnit=0;this._lastMaterialId=null;this._lastVertexBufsId=null;this._lastGeometryId=null;this._lastIndicesBufId=null;gl.uniformMatrix4fv(this._uViewMatrix,!1,cameraState.matrix);gl.uniformMatrix4fv(this._uViewNormalMatrix,!1,cameraState.normalMatrix);gl.uniformMatrix4fv(this._uProjMatrix,!1,camera.project._state.matrix);for(var i=0,len=lightsState.lights.length;i<len;i++){light=lightsState.lights[i];if(this._uLightAmbient[i]){gl.uniform4f(this._uLightAmbient[i],light.color[0],light.color[1],light.color[2],light.intensity)}else{if(this._uLightColor[i]){gl.uniform4f(this._uLightColor[i],light.color[0],light.color[1],light.color[2],light.intensity)}
if(this._uLightPos[i]){gl.uniform3fv(this._uLightPos[i],light.pos);if(this._uLightAttenuation[i]){gl.uniform1f(this._uLightAttenuation[i],light.attenuation)}}
if(this._uLightDir[i]){gl.uniform3fv(this._uLightDir[i],light.dir)}}}
if(clipsState.clips.length>0){const clips=scene._clipsState.clips;let clipUniforms;let uClipActive;let clip;let uClipPos;let uClipDir;for(var i=0,len=this._uClips.length;i<len;i++){clipUniforms=this._uClips[i];uClipActive=clipUniforms.active;clip=clips[i];if(uClipActive){gl.uniform1i(uClipActive,clip.active)}
uClipPos=clipUniforms.pos;if(uClipPos){gl.uniform3fv(clipUniforms.pos,clip.pos)}
uClipDir=clipUniforms.dir;if(uClipDir){gl.uniform3fv(clipUniforms.dir,clip.dir)}}}
if(this._uGammaFactor){gl.uniform1f(this._uGammaFactor,scene.gammaFactor)}};class EmphasisEdgesShaderSource{constructor(mesh){this.vertex=buildVertex$1(mesh);this.fragment=buildFragment$1(mesh)}}
function buildVertex$1(mesh){const scene=mesh.scene;const clipping=scene._clipsState.clips.length>0;const quantizedGeometry=!!mesh._geometry._state.quantized;const billboard=mesh._state.billboard;const stationary=mesh._state.stationary;const src=[];src.push("// Edges drawing vertex shader");src.push("attribute vec3 position;");src.push("uniform mat4 modelMatrix;");src.push("uniform mat4 viewMatrix;");src.push("uniform mat4 projMatrix;");src.push("uniform vec4 edgeColor;");if(quantizedGeometry){src.push("uniform mat4 positionsDecodeMatrix;")}
if(clipping){src.push("varying vec4 vWorldPosition;")}
src.push("varying vec4 vColor;");if(billboard==="spherical"||billboard==="cylindrical"){src.push("void billboard(inout mat4 mat) {");src.push("   mat[0][0] = 1.0;");src.push("   mat[0][1] = 0.0;");src.push("   mat[0][2] = 0.0;");if(billboard==="spherical"){src.push("   mat[1][0] = 0.0;");src.push("   mat[1][1] = 1.0;");src.push("   mat[1][2] = 0.0;")}
src.push("   mat[2][0] = 0.0;");src.push("   mat[2][1] = 0.0;");src.push("   mat[2][2] =1.0;");src.push("}")}
src.push("void main(void) {");src.push("vec4 localPosition = vec4(position, 1.0); ");src.push("vec4 worldPosition;");if(quantizedGeometry){src.push("localPosition = positionsDecodeMatrix * localPosition;")}
src.push("mat4 viewMatrix2 = viewMatrix;");src.push("mat4 modelMatrix2 = modelMatrix;");if(stationary){src.push("viewMatrix2[3][0] = viewMatrix2[3][1] = viewMatrix2[3][2] = 0.0;")}
if(billboard==="spherical"||billboard==="cylindrical"){src.push("mat4 modelViewMatrix = viewMatrix2 * modelMatrix2;");src.push("billboard(modelMatrix2);");src.push("billboard(viewMatrix2);");src.push("billboard(modelViewMatrix);");src.push("worldPosition = modelMatrix2 * localPosition;");src.push("vec4 viewPosition = modelViewMatrix * localPosition;")}else{src.push("worldPosition = modelMatrix2 * localPosition;");src.push("vec4 viewPosition  = viewMatrix2 * worldPosition; ")}
src.push("vColor = edgeColor;");if(clipping){src.push("vWorldPosition = worldPosition;")}
src.push("   gl_Position = projMatrix * viewPosition;");src.push("}");return src}
function buildFragment$1(mesh){const clipsState=mesh.scene._clipsState;const gammaOutput=mesh.scene.gammaOutput;const clipping=clipsState.clips.length>0;let i;let len;const src=[];src.push("// Edges drawing fragment shader");src.push("precision lowp float;");if(gammaOutput){src.push("uniform float gammaFactor;");src.push("vec4 linearToGamma( in vec4 value, in float gammaFactor ) {");src.push("  return vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );");src.push("}")}
if(clipping){src.push("varying vec4 vWorldPosition;");src.push("uniform bool clippable;");for(i=0,len=clipsState.clips.length;i<len;i++){src.push("uniform bool clipActive"+i+";");src.push("uniform vec3 clipPos"+i+";");src.push("uniform vec3 clipDir"+i+";")}}
src.push("varying vec4 vColor;");src.push("void main(void) {");if(clipping){src.push("if (clippable) {");src.push("  float dist = 0.0;");for(i=0,len=clipsState.clips.length;i<len;i++){src.push("if (clipActive"+i+") {");src.push("   dist += clamp(dot(-clipDir"+i+".xyz, vWorldPosition.xyz - clipPos"+i+".xyz), 0.0, 1000.0);");src.push("}")}
src.push("  if (dist > 0.0) { discard; }");src.push("}")}
src.push("gl_FragColor = vColor;");if(gammaOutput){src.push("gl_FragColor = linearToGamma(vColor, gammaFactor);")}else{src.push("gl_FragColor = vColor;")}
src.push("}");return src}
const ids$4=new Map({});const EmphasisEdgesRenderer=function(hash,mesh){this.id=ids$4.addItem({});this._hash=hash;this._scene=mesh.scene;this._useCount=0;this._shaderSource=new EmphasisEdgesShaderSource(mesh);this._allocate(mesh)};const renderers={};EmphasisEdgesRenderer.get=function(mesh){const hash=[mesh.scene.id,mesh.scene.gammaOutput?"go":"",mesh.scene._clipsState.getHash(),mesh._geometry._state.quantized?"cp":"",mesh._state.hash].join(";");let renderer=renderers[hash];if(!renderer){renderer=new EmphasisEdgesRenderer(hash,mesh);renderers[hash]=renderer;stats.memory.programs++}
renderer._useCount++;return renderer};EmphasisEdgesRenderer.prototype.put=function(){if(--this._useCount===0){ids$4.removeItem(this.id);if(this._program){this._program.destroy()}
delete renderers[this._hash];stats.memory.programs--}};EmphasisEdgesRenderer.prototype.webglContextRestored=function(){this._program=null};EmphasisEdgesRenderer.prototype.drawMesh=function(frame,mesh,mode){if(!this._program){this._allocate(mesh)}
const scene=this._scene;const gl=scene.canvas.gl;let materialState;const meshState=mesh._state;const geometry=mesh._geometry;const geometryState=geometry._state;if(frame.lastProgramId!==this._program.id){frame.lastProgramId=this._program.id;this._bindProgram(frame)}
switch(mode){case 0:materialState=mesh._ghostMaterial._state;break;case 1:materialState=mesh._highlightMaterial._state;break;case 2:materialState=mesh._selectedMaterial._state;break;case 3:default:materialState=mesh._edgeMaterial._state;break}
if(materialState.id!==this._lastMaterialId){const backfaces=materialState.backfaces;if(frame.backfaces!==backfaces){if(backfaces){gl.disable(gl.CULL_FACE)}else{gl.enable(gl.CULL_FACE)}
frame.backfaces=backfaces}
if(frame.lineWidth!==materialState.edgeWidth){gl.lineWidth(materialState.edgeWidth);frame.lineWidth=materialState.edgeWidth}
if(this._uEdgeColor){const edgeColor=materialState.edgeColor;const edgeAlpha=materialState.edgeAlpha;gl.uniform4f(this._uEdgeColor,edgeColor[0],edgeColor[1],edgeColor[2],edgeAlpha)}
this._lastMaterialId=materialState.id}
gl.uniformMatrix4fv(this._uModelMatrix,gl.FALSE,mesh.worldMatrix);if(this._uModelNormalMatrix){gl.uniformMatrix4fv(this._uModelNormalMatrix,gl.FALSE,mesh.worldNormalMatrix)}
if(this._uClippable){gl.uniform1i(this._uClippable,meshState.clippable)}
if(geometryState.combined){const vertexBufs=mesh._geometry._getVertexBufs();if(vertexBufs.id!==this._lastVertexBufsId){if(vertexBufs.positionsBuf&&this._aPosition){this._aPosition.bindArrayBuffer(vertexBufs.positionsBuf,vertexBufs.quantized?gl.UNSIGNED_SHORT:gl.FLOAT);frame.bindArray++}
this._lastVertexBufsId=vertexBufs.id}}
let indicesBuf;if(geometryState.primitive===gl.TRIANGLES){indicesBuf=geometry._getEdgesIndices()}else if(geometryState.primitive===gl.LINES){indicesBuf=geometryState.indicesBuf}
if(indicesBuf){if(geometryState.id!==this._lastGeometryId){if(this._uPositionsDecodeMatrix){gl.uniformMatrix4fv(this._uPositionsDecodeMatrix,!1,geometryState.positionsDecodeMatrix)}
if(!geometryState.combined){if(this._aPosition){this._aPosition.bindArrayBuffer(geometryState.positionsBuf,geometryState.quantized?gl.UNSIGNED_SHORT:gl.FLOAT);frame.bindArray++}}
indicesBuf.bind();frame.bindArray++;this._lastGeometryId=geometryState.id}
gl.drawElements(gl.LINES,indicesBuf.numItems,indicesBuf.itemType,0);frame.drawElements++}};EmphasisEdgesRenderer.prototype._allocate=function(mesh){const gl=mesh.scene.canvas.gl;const clipsState=mesh.scene._clipsState;this._program=new Program(gl,this._shaderSource);if(this._program.errors){this.errors=this._program.errors;return}
const program=this._program;this._uPositionsDecodeMatrix=program.getLocation("positionsDecodeMatrix");this._uModelMatrix=program.getLocation("modelMatrix");this._uViewMatrix=program.getLocation("viewMatrix");this._uProjMatrix=program.getLocation("projMatrix");this._uClips=[];for(let i=0,len=clipsState.clips.length;i<len;i++){this._uClips.push({active:program.getLocation("clipActive"+i),pos:program.getLocation("clipPos"+i),dir:program.getLocation("clipDir"+i)})}
this._uEdgeColor=program.getLocation("edgeColor");this._aPosition=program.getAttribute("position");this._uClippable=program.getLocation("clippable");this._uGammaFactor=program.getLocation("gammaFactor");this._lastMaterialId=null;this._lastVertexBufsId=null;this._lastGeometryId=null};EmphasisEdgesRenderer.prototype._bindProgram=function(frame){const program=this._program;const scene=this._scene;const gl=scene.canvas.gl;const clipsState=scene._clipsState;const camera=scene.camera;const cameraState=camera._state;program.bind();frame.useProgram++;this._lastMaterialId=null;this._lastVertexBufsId=null;this._lastGeometryId=null;gl.uniformMatrix4fv(this._uViewMatrix,!1,cameraState.matrix);gl.uniformMatrix4fv(this._uProjMatrix,!1,camera.project._state.matrix);if(clipsState.clips.length>0){const clips=clipsState.clips;let clipUniforms;let uClipActive;let clip;let uClipPos;let uClipDir;for(let i=0,len=this._uClips.length;i<len;i++){clipUniforms=this._uClips[i];uClipActive=clipUniforms.active;clip=clips[i];if(uClipActive){gl.uniform1i(uClipActive,clip.active)}
uClipPos=clipUniforms.pos;if(uClipPos){gl.uniform3fv(clipUniforms.pos,clip.pos)}
uClipDir=clipUniforms.dir;if(uClipDir){gl.uniform3fv(clipUniforms.dir,clip.dir)}}}
if(this._uGammaFactor){gl.uniform1f(this._uGammaFactor,scene.gammaFactor)}};class EmphasisVerticesShaderSource{constructor(mesh){this.vertex=buildVertex$2(mesh);this.fragment=buildFragment$2(mesh)}}
function buildVertex$2(mesh){const scene=mesh.scene;const clipping=scene._clipsState.clips.length>0;const quantizedGeometry=!!mesh._geometry._state.quantized;const billboard=mesh._state.billboard;const stationary=mesh._state.stationary;const src=[];src.push("// Vertices drawing vertex shader");src.push("attribute vec3 position;");src.push("uniform mat4 modelMatrix;");src.push("uniform mat4 viewMatrix;");src.push("uniform mat4 projMatrix;");src.push("uniform vec4 vertexColor;");src.push("uniform float vertexSize;");if(quantizedGeometry){src.push("uniform mat4 positionsDecodeMatrix;")}
if(clipping){src.push("varying vec4 vWorldPosition;")}
src.push("varying vec4 vColor;");if(billboard==="spherical"||billboard==="cylindrical"){src.push("void billboard(inout mat4 mat) {");src.push("   mat[0][0] = 1.0;");src.push("   mat[0][1] = 0.0;");src.push("   mat[0][2] = 0.0;");if(billboard==="spherical"){src.push("   mat[1][0] = 0.0;");src.push("   mat[1][1] = 1.0;");src.push("   mat[1][2] = 0.0;")}
src.push("   mat[2][0] = 0.0;");src.push("   mat[2][1] = 0.0;");src.push("   mat[2][2] =1.0;");src.push("}")}
src.push("void main(void) {");src.push("vec4 localPosition = vec4(position, 1.0); ");src.push("vec4 worldPosition;");if(quantizedGeometry){src.push("localPosition = positionsDecodeMatrix * localPosition;")}
src.push("mat4 viewMatrix2 = viewMatrix;");src.push("mat4 modelMatrix2 = modelMatrix;");if(stationary){src.push("viewMatrix2[3][0] = viewMatrix2[3][1] = viewMatrix2[3][2] = 0.0;")}
if(billboard==="spherical"||billboard==="cylindrical"){src.push("mat4 modelViewMatrix = viewMatrix2 * modelMatrix2;");src.push("billboard(modelMatrix2);");src.push("billboard(viewMatrix2);");src.push("billboard(modelViewMatrix);");src.push("worldPosition = modelMatrix2 * localPosition;");src.push("vec4 viewPosition = modelViewMatrix * localPosition;")}else{src.push("worldPosition = modelMatrix2 * localPosition;");src.push("vec4 viewPosition  = viewMatrix2 * worldPosition; ")}
src.push("vColor = vertexColor;");src.push("gl_PointSize = vertexSize;");if(clipping){src.push("vWorldPosition = worldPosition;")}
src.push("   gl_Position = projMatrix * viewPosition;");src.push("}");return src}
function buildFragment$2(mesh){const clipsState=mesh.scene._clipsState;const gammaOutput=mesh.scene.gammaOutput;const clipping=clipsState.clips.length>0;let i;let len;const src=[];src.push("// Vertices drawing fragment shader");src.push("precision lowp float;");if(gammaOutput){src.push("uniform float gammaFactor;");src.push("vec4 linearToGamma( in vec4 value, in float gammaFactor ) {");src.push("  return vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );");src.push("}")}
if(clipping){src.push("varying vec4 vWorldPosition;");src.push("uniform bool clippable;");for(i=0,len=clipsState.clips.length;i<len;i++){src.push("uniform bool clipActive"+i+";");src.push("uniform vec3 clipPos"+i+";");src.push("uniform vec3 clipDir"+i+";")}}
src.push("varying vec4 vColor;");src.push("void main(void) {");if(clipping){src.push("if (clippable) {");src.push("  float dist = 0.0;");for(i=0,len=clipsState.clips.length;i<len;i++){src.push("if (clipActive"+i+") {");src.push("   dist += clamp(dot(-clipDir"+i+".xyz, vWorldPosition.xyz - clipPos"+i+".xyz), 0.0, 1000.0);");src.push("}")}
src.push("  if (dist > 0.0) { discard; }");src.push("}")}
src.push("vec2 cxy = 2.0 * gl_PointCoord - 1.0;");src.push("float r = dot(cxy, cxy);");src.push("if (r > 1.0) {");src.push("   discard;");src.push("}");src.push("gl_FragColor = vColor;");if(gammaOutput){src.push("gl_FragColor = linearToGamma(vColor, gammaFactor);")}else{src.push("gl_FragColor = vColor;")}
src.push("}");return src}
const ids$5=new Map({});const EmphasisVerticesRenderer=function(hash,mesh){this.id=ids$5.addItem({});this._hash=hash;this._scene=mesh.scene;this._shaderSource=new EmphasisVerticesShaderSource(mesh);this._allocate(mesh)};const renderers$1={};EmphasisVerticesRenderer.get=function(mesh){const hash=[mesh.scene.id,mesh.scene.gammaOutput?"go":"",mesh.scene._clipsState.getHash(),mesh._geometry._state.quantized?"cp":"",mesh._state.hash].join(";");let renderer=renderers$1[hash];if(!renderer){renderer=new EmphasisVerticesRenderer(hash,mesh);renderers$1[hash]=renderer;stats.memory.programs++}
renderer._useCount++;return renderer};EmphasisVerticesRenderer.prototype.put=function(){if(--this._useCount===0){this._scene.off(this._onWebglcontextrestored);ids$5.removeItem(this.id);if(this._program){this._program.destroy()}
delete renderers$1[this._hash];stats.memory.programs--}};EmphasisVerticesRenderer.prototype.webglContextRestored=function(){this._program=null};EmphasisVerticesRenderer.prototype.drawMesh=function(frame,mesh,mode){if(!this._program){this._allocate(mesh)}
const scene=this._scene;const gl=scene.canvas.gl;const materialState=mode===0?mesh._ghostMaterial._state:(mode===1?mesh._highlightMaterial._state:mesh._selectedMaterial._state);const meshState=mesh._state;const geometryState=mesh._geometry._state;if(frame.lastProgramId!==this._program.id){frame.lastProgramId=this._program.id;this._bindProgram(frame,mesh)}
if(materialState.id!==this._lastMaterialId){const backfaces=materialState.backfaces;if(frame.backfaces!==backfaces){if(backfaces){gl.disable(gl.CULL_FACE)}else{gl.enable(gl.CULL_FACE)}
frame.backfaces=backfaces}
if(this._uVertexSize){gl.uniform1f(this._uVertexSize,materialState.vertexSize)}
if(this._uVertexColor){const vertexColor=materialState.vertexColor;const vertexAlpha=materialState.vertexAlpha;gl.uniform4f(this._uVertexColor,vertexColor[0],vertexColor[1],vertexColor[2],vertexAlpha)}
this._lastMaterialId=materialState.id}
gl.uniformMatrix4fv(this._uModelMatrix,gl.FALSE,mesh.worldMatrix);if(this._uModelNormalMatrix){gl.uniformMatrix4fv(this._uModelNormalMatrix,gl.FALSE,mesh.worldNormalMatrix)}
if(this._uClippable){gl.uniform1i(this._uClippable,meshState.clippable)}
if(geometryState.combined){const vertexBufs=mesh._geometry._getVertexBufs();if(vertexBufs.id!==this._lastVertexBufsId){if(vertexBufs.positionsBuf&&this._aPosition){this._aPosition.bindArrayBuffer(vertexBufs.positionsBuf,vertexBufs.quantized?gl.UNSIGNED_SHORT:gl.FLOAT);frame.bindArray++}
this._lastVertexBufsId=vertexBufs.id}}
if(geometryState.id!==this._lastGeometryId){if(this._uPositionsDecodeMatrix){gl.uniformMatrix4fv(this._uPositionsDecodeMatrix,!1,geometryState.positionsDecodeMatrix)}
if(geometryState.combined){if(geometryState.indicesBufCombined){geometryState.indicesBufCombined.bind();frame.bindArray++}}else{if(this._aPosition){this._aPosition.bindArrayBuffer(geometryState.positionsBuf,geometryState.quantized?gl.UNSIGNED_SHORT:gl.FLOAT);frame.bindArray++}
if(geometryState.indicesBuf){geometryState.indicesBuf.bind();frame.bindArray++}else if(geometryState.positions){}}
this._lastGeometryId=geometryState.id}
if(geometryState.combined){if(geometryState.indicesBufCombined){gl.drawElements(gl.POINTS,geometryState.indicesBufCombined.numItems,geometryState.indicesBufCombined.itemType,0);frame.drawElements++}else{}}else{if(geometryState.indicesBuf){gl.drawElements(gl.POINTS,geometryState.indicesBuf.numItems,geometryState.indicesBuf.itemType,0);frame.drawElements++}else if(geometryState.positions){gl.drawArrays(gl.POINTS,0,geometryState.positions.numItems);frame.drawArrays++}}};EmphasisVerticesRenderer.prototype._allocate=function(mesh){const clipsState=mesh.scene._clipsState;const gl=mesh.scene.canvas.gl;this._program=new Program(gl,this._shaderSource);this._useCount=0;if(this._program.errors){this.errors=this._program.errors;return}
const program=this._program;this._uPositionsDecodeMatrix=program.getLocation("positionsDecodeMatrix");this._uModelMatrix=program.getLocation("modelMatrix");this._uViewMatrix=program.getLocation("viewMatrix");this._uProjMatrix=program.getLocation("projMatrix");this._uClips=[];for(let i=0,len=clipsState.clips.length;i<len;i++){this._uClips.push({active:program.getLocation("clipActive"+i),pos:program.getLocation("clipPos"+i),dir:program.getLocation("clipDir"+i)})}
this._uVertexColor=program.getLocation("vertexColor");this._uVertexSize=program.getLocation("vertexSize");this._aPosition=program.getAttribute("position");this._uClippable=program.getLocation("clippable");this._uGammaFactor=program.getLocation("gammaFactor");this._lastMaterialId=null;this._lastVertexBufsId=null;this._lastGeometryId=null};EmphasisVerticesRenderer.prototype._bindProgram=function(frame,mesh){const scene=this._scene;const gl=scene.canvas.gl;const clipsState=scene._clipsState;const program=this._program;const camera=scene.camera;const cameraState=camera._state;program.bind();frame.useProgram++;frame.textureUnit=0;this._lastMaterialId=null;this._lastVertexBufsId=null;this._lastGeometryId=null;gl.uniformMatrix4fv(this._uViewMatrix,!1,cameraState.matrix);gl.uniformMatrix4fv(this._uProjMatrix,!1,camera.project._state.matrix);if(clipsState.clips.length>0){const clips=clipsState.clips;let clipUniforms;let uClipActive;let clip;let uClipPos;let uClipDir;for(let i=0,len=this._uClips.length;i<len;i++){clipUniforms=this._uClips[i];uClipActive=clipUniforms.active;clip=clips[i];if(uClipActive){gl.uniform1i(uClipActive,clip.active)}
uClipPos=clipUniforms.pos;if(uClipPos){gl.uniform3fv(clipUniforms.pos,clip.pos)}
uClipDir=clipUniforms.dir;if(uClipDir){gl.uniform3fv(clipUniforms.dir,clip.dir)}}}
if(this._uGammaFactor){gl.uniform1f(this._uGammaFactor,scene.gammaFactor)}};class OutlineShaderSource{constructor(mesh){this.vertex=buildVertex$4(mesh);this.fragment=buildFragment$4(mesh)}}
function hasNormals$2(mesh){const primitive=mesh._geometry._state.primitiveName;if((mesh._geometry._state.autoVertexNormals||mesh._geometry._state.normals)&&(primitive==="triangles"||primitive==="triangle-strip"||primitive==="triangle-fan")){return!0}
return!1}
function buildVertex$4(mesh){const scene=mesh.scene;const clipping=scene._clipsState.clips.length>0;const quantizedGeometry=!!mesh._geometry._state.quantized;const normals=hasNormals$2(mesh);const billboard=mesh._state.billboard;const stationary=mesh._state.stationary;const src=[];src.push("// Outline effect vertex shader");src.push("attribute vec3 position;");src.push("uniform mat4 modelMatrix;");src.push("uniform mat4 viewMatrix;");src.push("uniform mat4 projMatrix;");src.push("uniform float width;");if(quantizedGeometry){src.push("uniform mat4 positionsDecodeMatrix;")}
if(clipping){src.push("varying vec4 vWorldPosition;")}
if(normals){src.push("attribute vec3 normal;");if(quantizedGeometry){src.push("vec3 octDecode(vec2 oct) {");src.push("    vec3 v = vec3(oct.xy, 1.0 - abs(oct.x) - abs(oct.y));");src.push("    if (v.z < 0.0) {");src.push("        v.xy = (1.0 - abs(v.yx)) * vec2(v.x >= 0.0 ? 1.0 : -1.0, v.y >= 0.0 ? 1.0 : -1.0);");src.push("    }");src.push("    return normalize(v);");src.push("}")}}
if(billboard==="spherical"||billboard==="cylindrical"){src.push("void billboard(inout mat4 mat) {");src.push("   mat[0][0] = 1.0;");src.push("   mat[0][1] = 0.0;");src.push("   mat[0][2] = 0.0;");if(billboard==="spherical"){src.push("   mat[1][0] = 0.0;");src.push("   mat[1][1] = 1.0;");src.push("   mat[1][2] = 0.0;")}
src.push("   mat[2][0] = 0.0;");src.push("   mat[2][1] = 0.0;");src.push("   mat[2][2] =1.0;");src.push("}")}
src.push("void main(void) {");src.push("vec4 localPosition = vec4(position, 1.0); ");src.push("vec4 worldPosition;");if(quantizedGeometry){src.push("localPosition = positionsDecodeMatrix * localPosition;")}
if(normals){if(quantizedGeometry){src.push("vec3 localNormal = octDecode(normal.xy); ")}else{src.push("vec3 localNormal = normal; ")}
src.push("  localPosition.xyz += (normalize(normal) * (width * 0.0005));")}
src.push("mat4 viewMatrix2 = viewMatrix;");src.push("mat4 modelMatrix2 = modelMatrix;");if(stationary){src.push("viewMatrix2[3][0] = viewMatrix2[3][1] = viewMatrix2[3][2] = 0.0;")}
if(billboard==="spherical"||billboard==="cylindrical"){src.push("mat4 modelViewMatrix = viewMatrix2 * modelMatrix2;");src.push("billboard(modelMatrix2);");src.push("billboard(viewMatrix2);");src.push("billboard(modelViewMatrix);");src.push("worldPosition = modelMatrix2 * localPosition;");src.push("vec4 viewPosition = modelViewMatrix * localPosition;")}else{src.push("worldPosition = modelMatrix2 * localPosition;");src.push("vec4 viewPosition  = viewMatrix2 * worldPosition; ")}
if(clipping){src.push("vWorldPosition = worldPosition;")}
src.push("   gl_Position = projMatrix * viewPosition;");src.push("}");return src}
function buildFragment$4(mesh){const scene=mesh.scene;const clipsState=scene._clipsState;const clipping=clipsState.clips.length>0;const src=[];src.push("precision lowp float;");src.push("uniform vec4  color;");if(clipping){src.push("uniform bool clippable;");src.push("varying vec4 vWorldPosition;");for(var i=0;i<clipsState.clips.length;i++){src.push("uniform bool clipActive"+i+";");src.push("uniform vec3 clipPos"+i+";");src.push("uniform vec3 clipDir"+i+";")}}
src.push("void main(void) {");if(clipping){src.push("if (clippable) {");src.push("  float dist = 0.0;");for(var i=0;i<clipsState.clips.length;i++){src.push("if (clipActive"+i+") {");src.push("   dist += clamp(dot(-clipDir"+i+".xyz, vWorldPosition.xyz - clipPos"+i+".xyz), 0.0, 1000.0);");src.push("}")}
src.push("  if (dist > 0.0) { discard; }");src.push("}")}
src.push("   gl_FragColor = color;");src.push("}");return src}
const ids$6=new Map({});const OutlineRenderer=function(hash,mesh){this._init(hash,mesh)};const outlineRenderers={};OutlineRenderer.get=function(mesh){const hash=[mesh.scene.canvas.canvas.id,mesh.scene.gammaOutput?"go":"",mesh.scene._clipsState.getHash(),mesh._geometry._state.hash,mesh._state.hash].join(";");let renderer=outlineRenderers[hash];if(!renderer){renderer=new OutlineRenderer(hash,mesh);outlineRenderers[hash]=renderer;stats.memory.programs++}
renderer._useCount++;return renderer};OutlineRenderer.prototype.put=function(){if(--this._useCount===0){ids$6.removeItem(this.id);this._program.destroy();delete outlineRenderers[this._hash];stats.memory.programs--}};OutlineRenderer.prototype._init=function(hash,mesh){this.id=ids$6.addItem({});this._scene=mesh.scene;this._hash=hash;this._shaderSource=new OutlineShaderSource(mesh);this._program=new Program(mesh.scene.canvas.gl,this._shaderSource);this._useCount=0;if(this._program.errors){this.errors=this._program.errors;return}
const program=this._program;this._uPositionsDecodeMatrix=program.getLocation("positionsDecodeMatrix");this._uModelMatrix=program.getLocation("modelMatrix");this._uViewMatrix=program.getLocation("viewMatrix");this._uProjMatrix=program.getLocation("projMatrix");this._uClips=[];const clips=mesh.scene._clipsState.clips;for(let i=0,len=clips.length;i<len;i++){this._uClips.push({active:program.getLocation("clipActive"+i),pos:program.getLocation("clipPos"+i),dir:program.getLocation("clipDir"+i)})}
this._uColor=program.getLocation("color");this._uWidth=program.getLocation("width");this._aPosition=program.getAttribute("position");this._aNormal=program.getAttribute("normal");this._uClippable=program.getLocation("clippable");this._uGammaFactor=program.getLocation("gammaFactor");this._lastMaterialId=null;this._lastVertexBufsId=null;this._lastGeometryId=null};OutlineRenderer.prototype._bindProgram=function(frame){const scene=this._scene;const gl=scene.canvas.gl;const program=this._program;const clipsState=scene._clipsState;program.bind();frame.useProgram++;this._lastMaterialId=null;this._lastVertexBufsId=null;this._lastGeometryId=null;gl.uniformMatrix4fv(this._uViewMatrix,!1,scene.viewTransform.matrix);gl.uniformMatrix4fv(this._uProjMatrix,!1,scene.projTransform.matrix);if(clipsState.clips.length>0){let clipUniforms;let uClipActive;let clip;let uClipPos;let uClipDir;for(let i=0,len=this._uClips.length;i<len;i++){clipUniforms=this._uClips[i];uClipActive=clipUniforms.active;clip=clipsState.clips[i];if(uClipActive){gl.uniform1i(uClipActive,clip.active)}
uClipPos=clipUniforms.pos;if(uClipPos){gl.uniform3fv(clipUniforms.pos,clip.pos)}
uClipDir=clipUniforms.dir;if(uClipDir){gl.uniform3fv(clipUniforms.dir,clip.dir)}}}
if(this._uGammaFactor){gl.uniform1f(this._uGammaFactor,scene.gammaFactor)}};OutlineRenderer.prototype.drawMesh=function(frame,mesh){const scene=this._scene;const gl=scene.canvas.gl;const materialState=mesh.outlineMaterial;const meshState=mesh._state;const geometryState=mesh._geometry._state;if(frame.lastProgramId!==this._program.id){frame.lastProgramId=this._program.id;this._bindProgram(frame)}
if(materialState.id!==this._lastMaterialId){if(this._uWidth){gl.uniform1f(this._uWidth,materialState.width)}
if(this._uColor){const color=materialState.color;const alpha=materialState.alpha;gl.uniform4f(this._uColor,color[0],color[1],color[2],alpha)}
this._lastMaterialId=materialState.id}
gl.uniformMatrix4fv(this._uModelMatrix,gl.FALSE,mesh.worldMatrix);if(this._uModelNormalMatrix){gl.uniformMatrix4fv(this._uModelNormalMatrix,gl.FALSE,mesh.worldNormalMatrix)}
if(this._uClippable){gl.uniform1i(this._uClippable,meshState.clippable)}
if(geometryState.combined){const vertexBufs=mesh._geometry._getVertexBufs();if(vertexBufs.id!==this._lastVertexBufsId){if(vertexBufs.positionsBuf&&this._aPosition){this._aPosition.bindArrayBuffer(vertexBufs.positionsBuf,vertexBufs.quantized?gl.UNSIGNED_SHORT:gl.FLOAT);frame.bindArray++}
if(vertexBufs.normalsBuf&&this._aNormal){this._aNormal.bindArrayBuffer(vertexBufs.normalsBuf,vertexBufs.quantized?gl.BYTE:gl.FLOAT);frame.bindArray++}
this._lastVertexBufsId=vertexBufs.id}}
if(geometryState.id!==this._lastGeometryId){if(this._uPositionsDecodeMatrix){gl.uniformMatrix4fv(this._uPositionsDecodeMatrix,!1,geometryState.positionsDecodeMatrix)}
if(this._uUVDecodeMatrix){gl.uniformMatrix3fv(this._uUVDecodeMatrix,!1,geometryState.uvDecodeMatrix)}
if(geometryState.combined){if(geometryState.indicesBufCombined){geometryState.indicesBufCombined.bind();frame.bindArray++}}else{if(this._aPosition){this._aPosition.bindArrayBuffer(geometryState.positionsBuf,geometryState.quantized?gl.UNSIGNED_SHORT:gl.FLOAT);frame.bindArray++}
if(this._aNormal){this._aNormal.bindArrayBuffer(geometryState.normalsBuf,geometryState.quantized?gl.BYTE:gl.FLOAT);frame.bindArray++}
if(geometryState.indicesBuf){geometryState.indicesBuf.bind();frame.bindArray++}else if(geometryState.positions){}}
this._lastGeometryId=geometryState.id}
if(geometryState.combined){if(geometryState.indicesBufCombined){gl.drawElements(geometryState.primitive,geometryState.indicesBufCombined.numItems,geometryState.indicesBufCombined.itemType,0);frame.drawElements++}else{}}else{if(geometryState.indicesBuf){gl.drawElements(geometryState.primitive,geometryState.indicesBuf.numItems,geometryState.indicesBuf.itemType,0);frame.drawElements++}else if(geometryState.positions){gl.drawArrays(gl.TRIANGLES,0,geometryState.positions.numItems);frame.drawArrays++}}};class PickMeshShaderSource{constructor(mesh){this.vertex=buildVertex$5(mesh);this.fragment=buildFragment$5(mesh)}}
function buildVertex$5(mesh){const scene=mesh.scene;const clipping=scene._clipsState.clips.length>0;const quantizedGeometry=!!mesh._geometry._state.quantized;const billboard=mesh._state.billboard;const stationary=mesh._state.stationary;const src=[];src.push("// mesh picking vertex shader");src.push("attribute vec3 position;");src.push("uniform mat4 modelMatrix;");src.push("uniform mat4 viewMatrix;");src.push("uniform mat4 viewNormalMatrix;");src.push("uniform mat4 projMatrix;");src.push("varying vec4 vViewPosition;");if(quantizedGeometry){src.push("uniform mat4 positionsDecodeMatrix;")}
if(clipping){src.push("varying vec4 vWorldPosition;")}
if(billboard==="spherical"||billboard==="cylindrical"){src.push("void billboard(inout mat4 mat) {");src.push("   mat[0][0] = 1.0;");src.push("   mat[0][1] = 0.0;");src.push("   mat[0][2] = 0.0;");if(billboard==="spherical"){src.push("   mat[1][0] = 0.0;");src.push("   mat[1][1] = 1.0;");src.push("   mat[1][2] = 0.0;")}
src.push("   mat[2][0] = 0.0;");src.push("   mat[2][1] = 0.0;");src.push("   mat[2][2] =1.0;");src.push("}")}
src.push("void main(void) {");src.push("vec4 localPosition = vec4(position, 1.0); ");if(quantizedGeometry){src.push("localPosition = positionsDecodeMatrix * localPosition;")}
src.push("mat4 viewMatrix2 = viewMatrix;");src.push("mat4 modelMatrix2 = modelMatrix;");if(stationary){src.push("viewMatrix2[3][0] = viewMatrix2[3][1] = viewMatrix2[3][2] = 0.0;")}
if(billboard==="spherical"||billboard==="cylindrical"){src.push("mat4 modelViewMatrix = viewMatrix2 * modelMatrix2;");src.push("billboard(modelMatrix2);");src.push("billboard(viewMatrix2);")}
src.push("   vec4 worldPosition = modelMatrix2 * localPosition;");src.push("   vec4 viewPosition = viewMatrix2 * worldPosition;");if(clipping){src.push("   vWorldPosition = worldPosition;")}
src.push("   gl_Position = projMatrix * viewPosition;");src.push("}");return src}
function buildFragment$5(mesh){const scene=mesh.scene;const clipsState=scene._clipsState;const clipping=clipsState.clips.length>0;const src=[];src.push("// mesh picking fragment shader");src.push("precision lowp float;");src.push("uniform vec4 pickColor;");if(clipping){src.push("uniform bool clippable;");src.push("varying vec4 vWorldPosition;");for(var i=0;i<clipsState.clips.length;i++){src.push("uniform bool clipActive"+i+";");src.push("uniform vec3 clipPos"+i+";");src.push("uniform vec3 clipDir"+i+";")}}
src.push("void main(void) {");if(clipping){src.push("if (clippable) {");src.push("  float dist = 0.0;");for(var i=0;i<clipsState.clips.length;i++){src.push("if (clipActive"+i+") {");src.push("   dist += clamp(dot(-clipDir"+i+".xyz, vWorldPosition.xyz - clipPos"+i+".xyz), 0.0, 1000.0);");src.push("}")}
src.push("  if (dist > 0.0) { discard; }");src.push("}")}
src.push("   gl_FragColor = pickColor; ");src.push("}");return src}
const PickMeshRenderer=function(hash,mesh){this._hash=hash;this._shaderSource=new PickMeshShaderSource(mesh);this._scene=mesh.scene;this._useCount=0;this._allocate(mesh)};const renderers$3={};PickMeshRenderer.get=function(mesh){const hash=[mesh.scene.canvas.canvas.id,mesh.scene._clipsState.getHash(),mesh._geometry._state.hash,mesh._state.hash].join(";");let renderer=renderers$3[hash];if(!renderer){renderer=new PickMeshRenderer(hash,mesh);if(renderer.errors){console.log(renderer.errors.join("\n"));return null}
renderers$3[hash]=renderer;stats.memory.programs++}
renderer._useCount++;return renderer};PickMeshRenderer.prototype.put=function(){if(--this._useCount===0){if(this._program){this._program.destroy()}
delete renderers$3[this._hash];stats.memory.programs--}};PickMeshRenderer.prototype.webglContextRestored=function(){this._program=null};PickMeshRenderer.prototype.drawMesh=function(frame,mesh){if(!this._program){this._allocate(mesh)}
const scene=this._scene;const gl=scene.canvas.gl;const materialState=mesh._material._state;const geometryState=mesh._geometry._state;if(frame.lastProgramId!==this._program.id){frame.lastProgramId=this._program.id;this._bindProgram(frame)}
if(materialState.id!==this._lastMaterialId){const backfaces=materialState.backfaces;if(frame.backfaces!==backfaces){if(backfaces){gl.disable(gl.CULL_FACE)}else{gl.enable(gl.CULL_FACE)}
frame.backfaces=backfaces}
const frontface=materialState.frontface;if(frame.frontface!==frontface){if(frontface){gl.frontFace(gl.CCW)}else{gl.frontFace(gl.CW)}
frame.frontface=frontface}
if(frame.lineWidth!==materialState.lineWidth){gl.lineWidth(materialState.lineWidth);frame.lineWidth=materialState.lineWidth}
if(this._uPointSize){gl.uniform1i(this._uPointSize,materialState.pointSize)}
this._lastMaterialId=materialState.id}
gl.uniformMatrix4fv(this._uModelMatrix,gl.FALSE,mesh.worldMatrix);if(geometryState.combined){const vertexBufs=mesh._geometry._getVertexBufs();if(vertexBufs.id!==this._lastVertexBufsId){if(vertexBufs.positionsBuf&&this._aPosition){this._aPosition.bindArrayBuffer(vertexBufs.positionsBuf,vertexBufs.quantized?gl.UNSIGNED_SHORT:gl.FLOAT);frame.bindArray++}
this._lastVertexBufsId=vertexBufs.id}}
if(this._uClippable){gl.uniform1i(this._uClippable,mesh._state.clippable)}
if(geometryState.id!==this._lastGeometryId){if(this._uPositionsDecodeMatrix){gl.uniformMatrix4fv(this._uPositionsDecodeMatrix,!1,geometryState.positionsDecodeMatrix)}
if(geometryState.combined){if(geometryState.indicesBufCombined){geometryState.indicesBufCombined.bind();frame.bindArray++}}else{if(this._aPosition){this._aPosition.bindArrayBuffer(geometryState.positionsBuf,geometryState.quantized?gl.UNSIGNED_SHORT:gl.FLOAT);frame.bindArray++}
if(geometryState.indicesBuf){geometryState.indicesBuf.bind();frame.bindArray++}}
this._lastGeometryId=geometryState.id}
const a=frame.pickmeshIndex>>24&0xFF;const b=frame.pickmeshIndex>>16&0xFF;const g=frame.pickmeshIndex>>8&0xFF;const r=frame.pickmeshIndex&0xFF;frame.pickmeshIndex++;gl.uniform4f(this._uPickColor,r/255,g/255,b/255,a/255);if(geometryState.combined){if(geometryState.indicesBufCombined){gl.drawElements(geometryState.primitive,geometryState.indicesBufCombined.numItems,geometryState.indicesBufCombined.itemType,0);frame.drawElements++}else{}}else{if(geometryState.indicesBuf){gl.drawElements(geometryState.primitive,geometryState.indicesBuf.numItems,geometryState.indicesBuf.itemType,0);frame.drawElements++}else if(geometryState.positions){gl.drawArrays(gl.TRIANGLES,0,geometryState.positions.numItems)}}};PickMeshRenderer.prototype._allocate=function(mesh){const gl=mesh.scene.canvas.gl;this._program=new Program(gl,this._shaderSource);if(this._program.errors){this.errors=this._program.errors;return}
const program=this._program;this._uPositionsDecodeMatrix=program.getLocation("positionsDecodeMatrix");this._uModelMatrix=program.getLocation("modelMatrix");this._uViewMatrix=program.getLocation("viewMatrix");this._uProjMatrix=program.getLocation("projMatrix");this._uClips=[];const clips=mesh.scene._clipsState.clips;for(let i=0,len=clips.length;i<len;i++){this._uClips.push({active:program.getLocation("clipActive"+i),pos:program.getLocation("clipPos"+i),dir:program.getLocation("clipDir"+i)})}
this._aPosition=program.getAttribute("position");this._uClippable=program.getLocation("clippable");this._uPickColor=program.getLocation("pickColor");this._lastMaterialId=null;this._lastVertexBufsId=null;this._lastGeometryId=null};PickMeshRenderer.prototype._bindProgram=function(frame){if(!this._program){this._allocate(mesh)}
const scene=this._scene;const gl=scene.canvas.gl;const clipsState=scene._clipsState;const camera=scene.camera;const cameraState=camera._state;this._program.bind();frame.useProgram++;this._lastMaterialId=null;this._lastVertexBufsId=null;this._lastGeometryId=null;gl.uniformMatrix4fv(this._uViewMatrix,!1,frame.pickViewMatrix||cameraState.matrix);gl.uniformMatrix4fv(this._uProjMatrix,!1,frame.pickProjMatrix||camera.project._state.matrix);if(clipsState.clips.length>0){let clipUniforms;let uClipActive;let clip;let uClipPos;let uClipDir;for(let i=0,len=this._uClips.length;i<len;i++){clipUniforms=this._uClips[i];uClipActive=clipUniforms.active;clip=clipsState.clips[i];if(uClipActive){gl.uniform1i(uClipActive,clip.active)}
uClipPos=clipUniforms.pos;if(uClipPos){gl.uniform3fv(clipUniforms.pos,clip.pos)}
uClipDir=clipUniforms.dir;if(uClipDir){gl.uniform3fv(clipUniforms.dir,clip.dir)}}}};class PickVertexShaderSource{constructor(mesh){this.vertex=buildVertex$6(mesh);this.fragment=buildFragment$6(mesh)}}
function buildVertex$6(mesh){const scene=mesh.scene;const clipping=scene._clipsState.clips.length>0;const quantizedGeometry=!!mesh._geometry._state.quantized;const billboard=mesh._state.billboard;const stationary=mesh._state.stationary;const src=[];src.push("// Surface picking vertex shader");src.push("attribute vec3 position;");src.push("attribute vec4 color;");src.push("uniform mat4 modelMatrix;");src.push("uniform mat4 viewMatrix;");src.push("uniform mat4 projMatrix;");if(clipping){src.push("uniform bool clippable;");src.push("varying vec4 vWorldPosition;")}
src.push("varying vec4 vColor;");if(quantizedGeometry){src.push("uniform mat4 positionsDecodeMatrix;")}
src.push("void main(void) {");src.push("vec4 localPosition = vec4(position, 1.0); ");if(quantizedGeometry){src.push("localPosition = positionsDecodeMatrix * localPosition;")}
src.push("   vec4 worldPosition = modelMatrix * localPosition; ");src.push("   vec4 viewPosition = viewMatrix * worldPosition;");if(clipping){src.push("   vWorldPosition = worldPosition;")}
src.push("   vColor = color;");src.push("   gl_Position = projMatrix * viewPosition;");src.push("}");return src}
function buildFragment$6(mesh){const scene=mesh.scene;const clipsState=scene._clipsState;const clipping=clipsState.clips.length>0;const src=[];src.push("// Surface picking fragment shader");src.push("precision lowp float;");src.push("varying vec4 vColor;");if(clipping){src.push("uniform bool clippable;");src.push("varying vec4 vWorldPosition;");for(var i=0;i<clipsState.clips.length;i++){src.push("uniform bool clipActive"+i+";");src.push("uniform vec3 clipPos"+i+";");src.push("uniform vec3 clipDir"+i+";")}}
src.push("void main(void) {");if(clipping){src.push("if (clippable) {");src.push("  float dist = 0.0;");for(var i=0;i<clipsState.clips.length;i++){src.push("if (clipActive"+i+") {");src.push("   dist += clamp(dot(-clipDir"+i+".xyz, vWorldPosition.xyz - clipPos"+i+".xyz), 0.0, 1000.0);");src.push("}")}
src.push("  if (dist > 0.0) { discard; }");src.push("}")}
src.push("   gl_FragColor = vColor;");src.push("}");return src}
const PickVertexRenderer=function(hash,mesh){const gl=mesh.scene.canvas.gl;this._hash=hash;this._shaderSource=new PickVertexShaderSource(mesh);this._program=new Program(gl,this._shaderSource);this._scene=mesh.scene;this._useCount=0;if(this._program.errors){this.errors=this._program.errors;return}
const program=this._program;this._uPositionsDecodeMatrix=program.getLocation("positionsDecodeMatrix");this._uModelMatrix=program.getLocation("modelMatrix");this._uViewMatrix=program.getLocation("viewMatrix");this._uProjMatrix=program.getLocation("projMatrix");this._uClips=[];const clips=mesh.scene._clipsState.clips;for(let i=0,len=clips.length;i<len;i++){this._uClips.push({active:program.getLocation("clipActive"+i),pos:program.getLocation("clipPos"+i),dir:program.getLocation("clipDir"+i)})}
this._aPosition=program.getAttribute("position");this._aColor=program.getAttribute("color");this._uClippable=program.getLocation("clippable")};const renderers$4={};PickVertexRenderer.get=function(scene,mesh){const hash=[mesh.scene.canvas.canvas.id,mesh.scene._clipsState.getHash(),mesh._geometry._state.quantized?"cp":"",mesh._state.hash].join(";");let renderer=renderers$4[hash];if(!renderer){renderer=new PickVertexRenderer(hash,mesh);if(renderer.errors){console.log(renderer.errors.join("\n"));return null}
renderers$4[hash]=renderer;stats.memory.programs++}
renderer._useCount++;return renderer};PickVertexRenderer.prototype.put=function(){if(--this._useCount===0){if(this._program){this._program.destroy()}
delete renderers$4[this._hash];stats.memory.programs--}};PickVertexRenderer.prototype.webglContextRestored=function(){this._program=null};PickVertexRenderer.prototype._bindProgram=function(frame){const scene=this._scene;const gl=scene.canvas.gl;const clipsState=scene._clipsState;const camera=scene.camera;const cameraState=camera._state;this._program.bind();frame.useProgram++;this._lastVertexBufsId=null;this._lastGeometryId=null;gl.uniformMatrix4fv(this._uViewMatrix,!1,cameraState.matrix);gl.uniformMatrix4fv(this._uProjMatrix,!1,camera.project._state.matrix);if(clipsState.clips.length>0){const clips=clipsState.clips;let clipUniforms;let uClipActive;let clip;let uClipPos;let uClipDir;for(let i=0,len=this._uClips.length;i<len;i++){clipUniforms=this._uClips[i];uClipActive=clipUniforms.active;clip=clips[i];if(uClipActive){gl.uniform1i(uClipActive,clip.active)}
uClipPos=clipUniforms.pos;if(uClipPos){gl.uniform3fv(clipUniforms.pos,clip.pos)}
uClipDir=clipUniforms.dir;if(uClipDir){gl.uniform3fv(clipUniforms.dir,clip.dir)}}}};PickVertexRenderer.prototype.drawMesh=function(frame,mesh){const scene=this._scene;const gl=scene.canvas.gl;const geometryState=mesh._geometry._state;if(frame.lastProgramId!==this._program.id){frame.lastProgramId=this._program.id;this._bindProgram(frame)}
gl.uniformMatrix4fv(this._uModelMatrix,gl.FALSE,mesh.worldMatrix);if(this._uClippable){gl.uniform1i(this._uClippable,mesh._state.clippable)}
if(geometryState.id!==this._lastGeometryId){const pickPositionsBuf=geometryState.getVertexPickPositions();if(this._uPositionsDecodeMatrix){gl.uniformMatrix4fv(this._uPositionsDecodeMatrix,!1,geometryState.positionsDecodeMatrix);this._aPosition.bindArrayBuffer(pickPositionsBuf,geometryState.quantized?gl.UNSIGNED_SHORT:gl.FLOAT)}else{this._aPosition.bindArrayBuffer(pickPositionsBuf)}
const pickColorsBuf=geometryState.getVertexPickColors();pickColorsBuf.bind();gl.enableVertexAttribArray(this._aColor.location);this._gl.vertexAttribPointer(this._aColor.location,pickColorsBuf.itemSize,pickColorsBuf.itemType,!0,0,0);this._lastGeometryId=geometryState.id}
gl.drawArrays(geometryState.primitive,0,positions.numItems/3)};class PickTriangleShaderSource{constructor(mesh){this.vertex=buildVertex$7(mesh);this.fragment=buildFragment$7(mesh)}}
function buildVertex$7(mesh){const scene=mesh.scene;const clipping=scene._clipsState.clips.length>0;const quantizedGeometry=!!mesh._geometry._state.quantized;const billboard=mesh._state.billboard;const stationary=mesh._state.stationary;const src=[];src.push("// Surface picking vertex shader");src.push("attribute vec3 position;");src.push("attribute vec4 color;");src.push("uniform mat4 modelMatrix;");src.push("uniform mat4 viewMatrix;");src.push("uniform mat4 projMatrix;");if(clipping){src.push("uniform bool clippable;");src.push("varying vec4 vWorldPosition;")}
src.push("varying vec4 vColor;");if(quantizedGeometry){src.push("uniform mat4 positionsDecodeMatrix;")}
src.push("void main(void) {");src.push("vec4 localPosition = vec4(position, 1.0); ");if(quantizedGeometry){src.push("localPosition = positionsDecodeMatrix * localPosition;")}
src.push("   vec4 worldPosition = modelMatrix * localPosition; ");src.push("   vec4 viewPosition = viewMatrix * worldPosition;");if(clipping){src.push("   vWorldPosition = worldPosition;")}
src.push("   vColor = color;");src.push("   gl_Position = projMatrix * viewPosition;");src.push("}");return src}
function buildFragment$7(mesh){const scene=mesh.scene;const clipsState=scene._clipsState;const clipping=clipsState.clips.length>0;const src=[];src.push("// Surface picking fragment shader");src.push("precision lowp float;");src.push("varying vec4 vColor;");if(clipping){src.push("uniform bool clippable;");src.push("varying vec4 vWorldPosition;");for(var i=0;i<clipsState.clips.length;i++){src.push("uniform bool clipActive"+i+";");src.push("uniform vec3 clipPos"+i+";");src.push("uniform vec3 clipDir"+i+";")}}
src.push("void main(void) {");if(clipping){src.push("if (clippable) {");src.push("  float dist = 0.0;");for(var i=0;i<clipsState.clips.length;i++){src.push("if (clipActive"+i+") {");src.push("   dist += clamp(dot(-clipDir"+i+".xyz, vWorldPosition.xyz - clipPos"+i+".xyz), 0.0, 1000.0);");src.push("}")}
src.push("  if (dist > 0.0) { discard; }");src.push("}")}
src.push("   gl_FragColor = vColor;");src.push("}");return src}
const PickTriangleRenderer=function(hash,mesh){this._hash=hash;this._scene=mesh.scene;this._useCount=0;this._shaderSource=new PickTriangleShaderSource(mesh);this._allocate(mesh)};const renderers$5={};PickTriangleRenderer.get=function(mesh){const hash=[mesh.scene.canvas.canvas.id,mesh.scene._clipsState.getHash(),mesh._geometry._state.quantized?"cp":"",mesh._state.hash].join(";");let renderer=renderers$5[hash];if(!renderer){renderer=new PickTriangleRenderer(hash,mesh);if(renderer.errors){console.log(renderer.errors.join("\n"));return null}
renderers$5[hash]=renderer;stats.memory.programs++}
renderer._useCount++;return renderer};PickTriangleRenderer.prototype.put=function(){if(--this._useCount===0){if(this._program){this._program.destroy()}
delete renderers$5[this._hash];stats.memory.programs--}};PickTriangleRenderer.prototype.webglContextRestored=function(){this._program=null};PickTriangleRenderer.prototype.drawMesh=function(frame,mesh){if(!this._program){this._allocate(mesh)}
const scene=this._scene;const gl=scene.canvas.gl;const clipsState=scene._clipsState;const materialState=mesh._material._state;const meshState=mesh._state;const geometry=mesh._geometry;const geometryState=mesh._geometry._state;const backfaces=materialState.backfaces;const frontface=materialState.frontface;const positionsBuf=geometry._getPickTrianglePositions();const pickColorsBuf=geometry._getPickTriangleColors();const camera=scene.camera;const cameraState=camera._state;this._program.bind();frame.useProgram++;gl.uniformMatrix4fv(this._uViewMatrix,!1,frame.pickViewMatrix||cameraState.matrix);gl.uniformMatrix4fv(this._uProjMatrix,!1,frame.pickProjMatrix||camera.project._state.matrix);if(clipsState.clips.length>0){const clips=clipsState.clips;let clipUniforms;let uClipActive;let clip;let uClipPos;let uClipDir;for(let i=0,len=this._uClips.length;i<len;i++){clipUniforms=this._uClips[i];uClipActive=clipUniforms.active;clip=clips[i];if(uClipActive){gl.uniform1i(uClipActive,clip.active)}
uClipPos=clipUniforms.pos;if(uClipPos){gl.uniform3fv(clipUniforms.pos,clip.pos)}
uClipDir=clipUniforms.dir;if(uClipDir){gl.uniform3fv(clipUniforms.dir,clip.dir)}}}
if(frame.backfaces!==backfaces){if(backfaces){gl.disable(gl.CULL_FACE)}else{gl.enable(gl.CULL_FACE)}
frame.backfaces=backfaces}
if(frame.frontface!==frontface){if(frontface){gl.frontFace(gl.CCW)}else{gl.frontFace(gl.CW)}
frame.frontface=frontface}
this._lastMaterialId=materialState.id;gl.uniformMatrix4fv(this._uModelMatrix,gl.FALSE,mesh.worldMatrix);if(this._uClippable){gl.uniform1i(this._uClippable,mesh._state.clippable)}
if(this._uPositionsDecodeMatrix){gl.uniformMatrix4fv(this._uPositionsDecodeMatrix,!1,geometryState.positionsDecodeMatrix);this._aPosition.bindArrayBuffer(positionsBuf,geometryState.quantized?gl.UNSIGNED_SHORT:gl.FLOAT)}else{this._aPosition.bindArrayBuffer(positionsBuf)}
pickColorsBuf.bind();gl.enableVertexAttribArray(this._aColor.location);gl.vertexAttribPointer(this._aColor.location,pickColorsBuf.itemSize,pickColorsBuf.itemType,!0,0,0);gl.drawArrays(geometryState.primitive,0,positionsBuf.numItems/3)};PickTriangleRenderer.prototype._allocate=function(mesh){const gl=mesh.scene.canvas.gl;this._program=new Program(gl,this._shaderSource);this._useCount=0;if(this._program.errors){this.errors=this._program.errors;return}
const program=this._program;this._uPositionsDecodeMatrix=program.getLocation("positionsDecodeMatrix");this._uModelMatrix=program.getLocation("modelMatrix");this._uViewMatrix=program.getLocation("viewMatrix");this._uProjMatrix=program.getLocation("projMatrix");this._uClips=[];const clips=mesh.scene._clipsState.clips;for(let i=0,len=clips.length;i<len;i++){this._uClips.push({active:program.getLocation("clipActive"+i),pos:program.getLocation("clipPos"+i),dir:program.getLocation("clipDir"+i)})}
this._aPosition=program.getAttribute("position");this._aColor=program.getAttribute("color");this._uClippable=program.getLocation("clippable")};const obb=math.OBB3();const type$8="xeogl.Mesh";class Mesh extends xeoglObject{get type(){return type$8}
static _compareState(a,b){return(a._state.layer-b._state.layer)||(a._drawRenderer.id-b._drawRenderer.id)||(a._material._state.id-b._material._state.id)||(a._vertexBufs.id-b._vertexBufs.id)||(a._geometry._state.id-b._geometry._state.id)}
init(cfg){this._state=new State({visible:!0,culled:!1,pickable:null,clippable:null,colorize:null,collidable:null,castShadow:null,receiveShadow:null,outlined:null,ghosted:!1,highlighted:!1,selected:!1,edges:!1,layer:null,billboard:this._checkBillboard(cfg.billboard),stationary:!!cfg.stationary,hash:""});this._drawRenderer=null;this._shadowRenderer=null;this._emphasisFillRenderer=null;this._emphasisEdgesRenderer=null;this._emphasisVerticesRenderer=null;this._pickMeshRenderer=null;this._pickTriangleRenderer=null;this._worldPositions=null;this._worldPositionsDirty=!0;this._geometry=cfg.geometry?this._checkComponent("xeogl.Geometry",cfg.geometry):this.scene.geometry;this._vertexBufs=this._geometry._getVertexBufs();this._material=cfg.material?this._checkComponent("xeogl.Material",cfg.material):this.scene.material;this._ghostMaterial=cfg.ghostMaterial?this._checkComponent("xeogl.EmphasisMaterial",cfg.ghostMaterial):this.scene.ghostMaterial;this._outlineMaterial=cfg.outlineMaterial?this._checkComponent("xeogl.EmphasisMaterial",cfg.outlineMaterial):this.scene.outlineMaterial;this._highlightMaterial=cfg.highlightMaterial?this._checkComponent("xeogl.EmphasisMaterial",cfg.highlightMaterial):this.scene.highlightMaterial;this._selectedMaterial=cfg.selectedMaterial?this._checkComponent("xeogl.EmphasisMaterial",cfg.selectedMaterial):this.scene.selectedMaterial;this._edgeMaterial=cfg.edgeMaterial?this._checkComponent("xeogl.EdgeMaterial",cfg.edgeMaterial):this.scene.edgeMaterial;this._compile();super.init(cfg);this.scene._meshCreated(this)}
_checkBillboard(value){value=value||"none";if(value!=="spherical"&&value!=="cylindrical"&&value!=="none"){this.error("Unsupported value for 'billboard': "+value+" - accepted values are "+"'spherical', 'cylindrical' and 'none' - defaulting to 'none'.");value="none"}
return value}
_compile(){this._putRenderers();this._makeHash();this._drawRenderer=DrawRenderer.get(this);this._emphasisFillRenderer=EmphasisFillRenderer.get(this);this._emphasisEdgesRenderer=EmphasisEdgesRenderer.get(this);this._emphasisVerticesRenderer=EmphasisVerticesRenderer.get(this);this._pickMeshRenderer=PickMeshRenderer.get(this);this._renderer.meshListDirty()}
_webglContextRestored(){if(this._drawRenderer){this._drawRenderer.webglContextRestored()}
if(this._shadowRenderer){this._shadowRenderer.webglContextRestored()}
if(this._emphasisFillRenderer){this._emphasisFillRenderer.webglContextRestored()}
if(this._emphasisEdgesRenderer){this._emphasisEdgesRenderer.webglContextRestored()}
if(this._emphasisVerticesRenderer){this._emphasisVerticesRenderer.webglContextRestored()}
if(this._pickMeshRenderer){this._pickMeshRenderer.webglContextRestored()}
if(this._pickTriangleRenderer){this._pickMeshRenderer.webglContextRestored()}}
_makeHash(){const hash=[];const state=this._state;if(state.stationary){hash.push("/s")}
if(state.billboard==="none"){hash.push("/n")}else if(state.billboard==="spherical"){hash.push("/s")}else if(state.billboard==="cylindrical"){hash.push("/c")}
if(state.receiveShadow){hash.push("/rs")}
hash.push(";");this._state.hash=hash.join("")}
_buildMeshAABB(worldMatrix,aabb){math.transformOBB3(worldMatrix,this._geometry.obb,obb);math.OBB3ToAABB3(obb,aabb)}
_getSceneHash(){return(this.scene.gammaInput?"gi;":";")+(this.scene.gammaOutput?"go":"")}
_draw(frame){if(this._drawRenderer||(this._drawRenderer=DrawRenderer.get(this))){this._drawRenderer.drawMesh(frame,this)}}
_drawGhostFill(frame){if(this._emphasisFillRenderer||(this._emphasisFillRenderer=EmphasisFillRenderer.get(this))){this._emphasisFillRenderer.drawMesh(frame,this,0)}}
_drawGhostEdges(frame){if(this._emphasisEdgesRenderer||(this._emphasisEdgesRenderer=EmphasisEdgesRenderer.get(this))){this._emphasisEdgesRenderer.drawMesh(frame,this,0)}}
_drawGhostVertices(frame){if(this._emphasisVerticesRenderer||(this._emphasisVerticesRenderer=EmphasisVerticesRenderer.get(this))){this._emphasisVerticesRenderer.drawMesh(frame,this,0)}}
_drawHighlightFill(frame){if(this._emphasisFillRenderer||(this._emphasisFillRenderer=EmphasisFillRenderer.get(this))){this._emphasisFillRenderer.drawMesh(frame,this,1)}}
_drawHighlightEdges(frame){if(this._emphasisEdgesRenderer||(this._emphasisEdgesRenderer=EmphasisEdgesRenderer.get(this))){this._emphasisEdgesRenderer.drawMesh(frame,this,1)}}
_drawHighlightVertices(frame){if(this._emphasisVerticesRenderer||(this._emphasisVerticesRenderer=EmphasisVerticesRenderer.get(this))){this._emphasisVerticesRenderer.drawMesh(frame,this,1)}}
_drawSelectedFill(frame){if(this._emphasisFillRenderer||(this._emphasisFillRenderer=EmphasisFillRenderer.get(this))){this._emphasisFillRenderer.drawMesh(frame,this,2)}}
_drawSelectedEdges(frame){if(this._emphasisEdgesRenderer||(this._emphasisEdgesRenderer=EmphasisEdgesRenderer.get(this))){this._emphasisEdgesRenderer.drawMesh(frame,this,2)}}
_drawSelectedVertices(frame){if(this._emphasisVerticesRenderer||(this._emphasisVerticesRenderer=EmphasisVerticesRenderer.get(this))){this._emphasisVerticesRenderer.drawMesh(frame,this,2)}}
_drawEdges(frame){if(this._emphasisEdgesRenderer||(this._emphasisEdgesRenderer=EmphasisEdgesRenderer.get(this))){this._emphasisEdgesRenderer.drawMesh(frame,this,3)}}
_drawShadow(frame,light){}
_drawOutline(frame){if(this._shadowRenderer||(this._outlineRenderer=OutlineRenderer.get(this))){this._outlineRenderer.drawMesh(frame,this)}}
_pickMesh(frame){if(this._pickMeshRenderer||(this._pickMeshRenderer=PickMeshRenderer.get(this))){this._pickMeshRenderer.drawMesh(frame,this)}}
_pickTriangle(frame){if(this._pickTriangleRenderer||(this._pickTriangleRenderer=PickTriangleRenderer.get(this))){this._pickTriangleRenderer.drawMesh(frame,this)}}
_pickVertex(frame){if(this._pickVertexRenderer||(this._pickVertexRenderer=PickVertexRenderer.get(this))){this._pickVertexRenderer.drawMesh(frame,this)}}
_getOutlineRenderer(){this._outlineRenderer=OutlineRenderer.get(this);if(this._outlineRenderer.errors){this.errors=(this.errors||[]).concat(this._outlineRenderer.errors);this.error(this._outlineRenderer.errors.join("\n"));return!1}
return!0}
_putRenderers(){if(this._drawRenderer){this._drawRenderer.put();this._drawRenderer=null}
if(this._shadowRenderer){this._shadowRenderer.put();this._shadowRenderer=null}
if(this._emphasisFillRenderer){this._emphasisFillRenderer.put();this._emphasisFillRenderer=null}
if(this._emphasisEdgesRenderer){this._emphasisEdgesRenderer.put();this._emphasisEdgesRenderer=null}
if(this._emphasisVerticesRenderer){this._emphasisVerticesRenderer.put();this._emphasisVerticesRenderer=null}
if(this._outlineRenderer){this._outlineRenderer.put();this._outlineRenderer=null}
if(this._pickMeshRenderer){this._pickMeshRenderer.put();this._pickMeshRenderer=null}
if(this._pickTriangleRenderer){this._pickTriangleRenderer.put();this._pickTriangleRenderer=null}
if(this._pickVertexRenderer){this._pickVertexRenderer.put();this._pickVertexRenderer=null}}
get worldPositions(){if(this._worldPositionsDirty){const positions=this._geometry.positions;if(!this._worldPositions){this._worldPositions=new Float32Array(positions.length)}
math.transformPositions3(this.worldMatrix,positions,this._worldPositions);this._worldPositionsDirty=!1}
return this._worldPositions}
set worldPositions(value){if(value=undefined||value===null){this._worldPositions=null;this._worldPositionsDirty=!0}}
get geometry(){return this._geometry}
get material(){return this._material}
get ghostMaterial(){return this._ghostMaterial}
get highlightMaterial(){return this._highlightMaterial}
get selectedMaterial(){return this._selectedMaterial}
get edgeMaterial(){return this._edgeMaterial}
get outlineMaterial(){return this._outlineMaterial}
set visible(visible){visible=visible!==!1;this._state.visible=visible;if(this._entityType){this.scene._entityVisibilityUpdated(this,visible)}
this._renderer.imageDirty();if(this._state.castShadow){this._renderer.shadowsDirty()}}
get visible(){return this._state.visible}
set ghosted(ghosted){ghosted=!!ghosted;if(this._state.ghosted===ghosted){return}
this._state.ghosted=ghosted;if(this._entityType){this.scene._entityGhostedUpdated(this,ghosted)}
this._renderer.imageDirty()}
get ghosted(){return this._state.ghosted}
set highlighted(highlighted){highlighted=!!highlighted;if(highlighted===this._state.highlighted){return}
this._state.highlighted=highlighted;if(this._entityType){this.scene._entityHighlightedUpdated(this,highlighted)}
this._renderer.imageDirty()}
get highlighted(){return this._state.highlighted}
set selected(selected){selected=!!selected;if(selected===this._state.selected){return}
this._state.selected=selected;if(this._entityType){this.scene._entitySelectedUpdated(this,selected)}
this._renderer.imageDirty()}
get selected(){return this._state.selected}
set edges(edges){edges=!!edges;if(edges===this._state.edges){return}
this._state.edges=edges;this._renderer.imageDirty()}
get edges(){return this._state.edges}
set culled(value){this._state.culled=!!value;this._renderer.imageDirty()}
get culled(){return this._state.culled}
set pickable(value){value=value!==!1;if(this._state.pickable===value){return}
this._state.pickable=value}
get pickable(){return this._state.pickable}
set clippable(value){value=value!==!1;if(this._state.clippable===value){return}
this._state.clippable=value;this._renderer.imageDirty();if(this._state.castShadow){this._renderer.shadowsDirty()}}
get clippable(){return this._state.clippable}
set collidable(value){value=value!==!1;if(value===this._state.collidable){return}
this._state.collidable=value}
get collidable(){return this._state.collidable}
set castShadow(value){value=value!==!1;if(value===this._state.castShadow){return}
this._state.castShadow=value;this._renderer.shadowsDirty()}
get castShadow(){return this._state.castShadow}
set receiveShadow(value){this._state.receiveShadow=!1}
get receiveShadow(){return this._state.receiveShadow}
set outlined(value){value=!!value;if(value===this._state.outlined){return}
this._state.outlined=value;this._renderer.imageDirty()}
get outlined(){return this._state.outlined}
set colorize(value){let colorize=this._state.colorize;if(!colorize){colorize=this._state.colorize=new Float32Array(4);colorize[3]=1}
if(value){colorize[0]=value[0];colorize[1]=value[1];colorize[2]=value[2]}else{colorize[0]=1;colorize[1]=1;colorize[2]=1}
this._renderer.imageDirty()}
get colorize(){return this._state.colorize}
set opacity(opacity){let colorize=this._state.colorize;if(!colorize){colorize=this._state.colorize=new Float32Array(4);colorize[0]=1;colorize[1]=1;colorize[2]=1}
colorize[3]=opacity!==null&&opacity!==undefined?opacity:1.0;this._renderer.imageDirty()}
get opacity(){return this._state.colorize[3]}
set layer(value){value=value||0;value=Math.round(value);if(value===this._state.layer){return}
this._state.layer=value;this._renderer.needStateSort()}
get layer(){return this._state.layer}
get stationary(){return this._state.stationary}
get billboard(){return this._state.billboard}
destroy(){super.destroy();this._putRenderers();this._renderer.meshListDirty();this.scene._meshDestroyed(this);if(this._state.castShadow){this._renderer.shadowsDirty()}}}
componentClasses[type$8]=Mesh;const Renderer=function(scene,options){options=options||{};const frame=new Frame();const canvas=scene.canvas.canvas;const gl=scene.canvas.gl;const canvasTransparent=options.transparent===!0;const meshList=[];let meshListLen=0;const meshPickList=[];let meshPickListLen=0;let meshListDirty=!0;let stateSortDirty=!0;let imageDirty=!0;this.imageForceDirty=!0;let blendOneMinusSrcAlpha=!0;let pickBuf=null;let readPixelBuf=null;const bindOutputFrameBuffer=null;const unbindOutputFrameBuffer=null;this.meshListDirty=function(){meshListDirty=!0;stateSortDirty=!0};this.needStateSort=function(){stateSortDirty=!0};this.shadowsDirty=function(){};this.imageDirty=function(){imageDirty=!0};this.setImageForceDirty=function(){this.imageForceDirty=!0};this.setBlendOneMinusSrcAlpha=function(value){blendOneMinusSrcAlpha=value};this.webglContextLost=function(){};this.webglContextRestored=function(gl){if(pickBuf){pickBuf.webglContextRestored(gl)}
if(readPixelBuf){readPixelBuf.webglContextRestored(gl)}
imageDirty=!0};this.clear=function(params){params=params||{};const boundary=scene.viewport.boundary;gl.viewport(boundary[0],boundary[1],boundary[2],boundary[3]);if(canvasTransparent){gl.clearColor(0,0,0,0)}else{const color=params.ambientColor||this.lights.getAmbientColor();gl.clearColor(color[0],color[1],color[2],1.0)}
if(bindOutputFrameBuffer){bindOutputFrameBuffer(params.pass)}
gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT|gl.STENCIL_BUFFER_BIT);if(unbindOutputFrameBuffer){unbindOutputFrameBuffer(params.pass)}};this.render=function(params){params=params||{};update();if(imageDirty||this.imageForceDirty||params.force){drawMeshes(params);stats.frame.frameCount++;imageDirty=!1;this.imageForceDirty=!1}};function update(){if(meshListDirty){buildMeshList();meshListDirty=!1;stateSortDirty=!0}
if(stateSortDirty){meshList.sort(Mesh._compareState);stateSortDirty=!1;imageDirty=!0}}
function buildMeshList(){meshListLen=0;for(const meshId in scene.meshes){if(scene.meshes.hasOwnProperty(meshId)){meshList[meshListLen++]=scene.meshes[meshId]}}
for(let i=meshListLen,len=meshList.length;i<len;i++){meshList[i]=null}
meshList.length=meshListLen}
var drawMeshes=(function(){const opaqueGhostFillMeshes=[];const opaqueGhostVerticesMeshes=[];const opaqueGhostEdgesMeshes=[];const transparentGhostFillMeshes=[];const transparentGhostVerticesMeshes=[];const transparentGhostEdgesMeshes=[];const opaqueHighlightFillMeshes=[];const opaqueHighlightVerticesMeshes=[];const opaqueHighlightEdgesMeshes=[];const transparentHighlightFillMeshes=[];const transparentHighlightVerticesMeshes=[];const transparentHighlightEdgesMeshes=[];const opaqueSelectedFillMeshes=[];const opaqueSelectedVerticesMeshes=[];const opaqueSelectedEdgesMeshes=[];const transparentSelectedFillMeshes=[];const transparentSelectedVerticesMeshes=[];const transparentSelectedEdgesMeshes=[];const opaqueEdgesMeshes=[];const transparentEdgesMeshes=[];const outlinedMeshes=[];const highlightMeshes=[];const selectedMeshes=[];const transparentMeshes=[];let numTransparentMeshes=0;return function(params){var opaqueOnly=!!params.opaqueOnly;if(WEBGL_INFO.SUPPORTED_EXTENSIONS.OES_element_index_uint){gl.getExtension("OES_element_index_uint")}
if(WEBGL_INFO.SUPPORTED_EXTENSIONS.OES_standard_derivatives){gl.getExtension("OES_standard_derivatives")}
const ambientColor=scene._lightsState.getAmbientColor();frame.reset();frame.pass=params.pass;const boundary=scene.viewport.boundary;gl.viewport(boundary[0],boundary[1],boundary[2],boundary[3]);if(canvasTransparent){gl.clearColor(0,0,0,0)}else{gl.clearColor(ambientColor[0],ambientColor[1],ambientColor[2],1.0)}
gl.enable(gl.DEPTH_TEST);gl.frontFace(gl.CCW);gl.enable(gl.CULL_FACE);gl.depthMask(!0);let i;let len;let mesh;let meshState;let materialState;let transparent;const startTime=Date.now();if(bindOutputFrameBuffer){bindOutputFrameBuffer(params.pass)}
if(params.clear!==!1){gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT|gl.STENCIL_BUFFER_BIT)}
let numOpaqueGhostFillMeshes=0;let numOpaqueGhostVerticesMeshes=0;let numOpaqueGhostEdgesMeshes=0;let numTransparentGhostFillMeshes=0;let numTransparentGhostVerticesMeshes=0;let numTransparentGhostEdgesMeshes=0;let numOutlinedMeshes=0;let numHighlightMeshes=0;let numSelectedMeshes=0;let numOpaqueHighlightFillMeshes=0;let numOpaqueHighlightVerticesMeshes=0;let numOpaqueHighlightEdgesMeshes=0;let numTransparentHighlightFillMeshes=0;let numTransparentHighlightVerticesMeshes=0;let numTransparentHighlightEdgesMeshes=0;let numOpaqueSelectedFillMeshes=0;let numOpaqueSelectedVerticesMeshes=0;let numOpaqueSelectedEdgesMeshes=0;let numTransparentSelectedFillMeshes=0;let numTransparentSelectedVerticesMeshes=0;let numTransparentSelectedEdgesMeshes=0;let numOpaqueEdgesMeshes=0;let numTransparentEdgesMeshes=0;numTransparentMeshes=0;for(i=0,len=meshListLen;i<len;i++){mesh=meshList[i];meshState=mesh._state;materialState=mesh._material._state;if(meshState.culled===!0||meshState.visible===!1){continue}
if(materialState.alpha===0){continue}
if(meshState.ghosted){const ghostMaterialState=mesh._ghostMaterial._state;if(ghostMaterialState.edges){if(ghostMaterialState.edgeAlpha<1.0){if(!opaqueOnly){transparentGhostEdgesMeshes[numTransparentGhostEdgesMeshes++]=mesh}}else{opaqueGhostEdgesMeshes[numOpaqueGhostEdgesMeshes++]=mesh}}
if(ghostMaterialState.vertices){if(ghostMaterialState.vertexAlpha<1.0){if(!opaqueOnly){transparentGhostVerticesMeshes[numTransparentGhostVerticesMeshes++]=mesh}}else{opaqueGhostVerticesMeshes[numOpaqueGhostVerticesMeshes++]=mesh}}
if(ghostMaterialState.fill){if(ghostMaterialState.fillAlpha<1.0){if(!opaqueOnly){transparentGhostFillMeshes[numTransparentGhostFillMeshes++]=mesh}}else{opaqueGhostFillMeshes[numOpaqueGhostFillMeshes++]=mesh}}}else{transparent=materialState.alphaMode===2||meshState.xray||meshState.colorize[3]<1;if(transparent){if(!opaqueOnly){transparentMeshes[numTransparentMeshes++]=mesh}}else{if(meshState.outlined){outlinedMeshes[numOutlinedMeshes++]=mesh}else{mesh._draw(frame)}}}
if(meshState.selected){const selectedMaterialState=mesh._selectedMaterial._state;if(selectedMaterialState.edges){if(selectedMaterialState.edgeAlpha<1.0){if(!opaqueOnly){transparentSelectedEdgesMeshes[numTransparentSelectedEdgesMeshes++]=mesh}}else{opaqueSelectedEdgesMeshes[numOpaqueSelectedEdgesMeshes++]=mesh}}
if(selectedMaterialState.vertices){if(selectedMaterialState.vertexAlpha<1.0){if(!opaqueOnly){transparentSelectedVerticesMeshes[numTransparentSelectedVerticesMeshes++]=mesh}}else{opaqueSelectedVerticesMeshes[numOpaqueSelectedVerticesMeshes++]=mesh}}
if(selectedMaterialState.fill){if(selectedMaterialState.fillAlpha<1.0){if(!opaqueOnly){transparentSelectedFillMeshes[numTransparentSelectedFillMeshes++]=mesh}}else{opaqueSelectedFillMeshes[numOpaqueSelectedFillMeshes++]=mesh}}
if(meshState.selected){selectedMeshes[numSelectedMeshes++]=mesh}}
if(meshState.highlighted){const highlightMaterialState=mesh._highlightMaterial._state;if(highlightMaterialState.edges){if(highlightMaterialState.edgeAlpha<1.0){if(!opaqueOnly){transparentHighlightEdgesMeshes[numTransparentHighlightEdgesMeshes++]=mesh}}else{opaqueHighlightEdgesMeshes[numOpaqueHighlightEdgesMeshes++]=mesh}}
if(highlightMaterialState.vertices){if(highlightMaterialState.vertexAlpha<1.0){transparentHighlightVerticesMeshes[numTransparentHighlightVerticesMeshes++]=mesh}else{opaqueHighlightVerticesMeshes[numOpaqueHighlightVerticesMeshes++]=mesh}}
if(highlightMaterialState.fill){if(highlightMaterialState.fillAlpha<1.0){transparentHighlightFillMeshes[numTransparentHighlightFillMeshes++]=mesh}else{opaqueHighlightFillMeshes[numOpaqueHighlightFillMeshes++]=mesh}}
if(meshState.highlighted){highlightMeshes[numHighlightMeshes++]=mesh}}
if(meshState.edges){const edgeMaterial=mesh._edgeMaterial._state;if(edgeMaterial.edgeAlpha<1.0){if(!opaqueOnly){transparentEdgesMeshes[numTransparentEdgesMeshes++]=mesh}}else{opaqueEdgesMeshes[numOpaqueEdgesMeshes++]=mesh}}}
if(numOutlinedMeshes>0){gl.enable(gl.STENCIL_TEST);gl.stencilFunc(gl.ALWAYS,1,1);gl.stencilOp(gl.KEEP,gl.KEEP,gl.REPLACE);gl.stencilMask(1);gl.clearStencil(0);gl.clear(gl.STENCIL_BUFFER_BIT);for(i=0;i<numOutlinedMeshes;i++){outlinedMeshes[i]._draw(frame)}
gl.stencilFunc(gl.EQUAL,0,1);gl.stencilOp(gl.KEEP,gl.KEEP,gl.KEEP);gl.stencilMask(0x00);gl.disable(gl.CULL_FACE);for(i=0;i<numOutlinedMeshes;i++){outlinedMeshes[i]._drawOutline(frame)}
gl.disable(gl.STENCIL_TEST)}
if(numOpaqueEdgesMeshes>0){for(i=0;i<numOpaqueEdgesMeshes;i++){opaqueEdgesMeshes[i]._drawEdges(frame)}}
if(numOpaqueGhostFillMeshes>0){for(i=0;i<numOpaqueGhostFillMeshes;i++){opaqueGhostFillMeshes[i]._drawGhostFill(frame)}}
if(numOpaqueGhostEdgesMeshes>0){for(i=0;i<numOpaqueGhostEdgesMeshes;i++){opaqueGhostEdgesMeshes[i]._drawGhostEdges(frame)}}
if(numOpaqueGhostVerticesMeshes>0){for(i=0;i<numOpaqueGhostVerticesMeshes;i++){opaqueGhostVerticesMeshes[i]._drawGhostVertices(frame)}}
const transparentDepthMask=!0;if(numTransparentGhostFillMeshes>0||numTransparentGhostEdgesMeshes>0||numTransparentGhostVerticesMeshes>0||numTransparentMeshes>0){gl.enable(gl.CULL_FACE);gl.enable(gl.BLEND);if(blendOneMinusSrcAlpha){gl.blendFunc(gl.SRC_ALPHA,gl.ONE_MINUS_SRC_ALPHA)}else{gl.blendEquation(gl.FUNC_ADD);gl.blendFuncSeparate(gl.SRC_ALPHA,gl.ONE_MINUS_SRC_ALPHA,gl.ONE,gl.ONE_MINUS_SRC_ALPHA)}
frame.backfaces=!1;if(!transparentDepthMask){gl.depthMask(!1)}
if(numTransparentGhostVerticesMeshes>0){for(i=0;i<numTransparentGhostVerticesMeshes;i++){transparentGhostVerticesMeshes[i]._drawGhostVertices(frame)}}
if(numTransparentGhostEdgesMeshes>0){for(i=0;i<numTransparentGhostEdgesMeshes;i++){transparentGhostEdgesMeshes[i]._drawGhostEdges(frame)}}
if(numTransparentGhostFillMeshes>0){for(i=0;i<numTransparentGhostFillMeshes;i++){transparentGhostFillMeshes[i]._drawGhostFill(frame)}}
numOutlinedMeshes=0;for(i=0;i<numTransparentMeshes;i++){mesh=transparentMeshes[i];if(mesh._state.outlined){outlinedMeshes[numOutlinedMeshes++]=mesh;continue}
mesh._draw(frame)}
gl.disable(gl.BLEND)}
if(numOpaqueHighlightFillMeshes>0||numOpaqueHighlightEdgesMeshes>0||numOpaqueHighlightVerticesMeshes>0){frame.lastProgramId=null;gl.clear(gl.DEPTH_BUFFER_BIT);if(numOpaqueHighlightVerticesMeshes>0){for(i=0;i<numOpaqueHighlightVerticesMeshes;i++){opaqueHighlightVerticesMeshes[i]._drawHighlightVertices(frame)}}
if(numOpaqueHighlightEdgesMeshes>0){for(i=0;i<numOpaqueHighlightEdgesMeshes;i++){opaqueHighlightEdgesMeshes[i]._drawHighlightEdges(frame)}}
if(numOpaqueHighlightFillMeshes>0){for(i=0;i<numOpaqueHighlightFillMeshes;i++){opaqueHighlightFillMeshes[i]._drawHighlightFill(frame)}}}
if(numTransparentHighlightFillMeshes>0||numTransparentHighlightEdgesMeshes>0||numTransparentHighlightVerticesMeshes>0){frame.lastProgramId=null;gl.clear(gl.DEPTH_BUFFER_BIT);gl.enable(gl.CULL_FACE);gl.enable(gl.BLEND);gl.blendFunc(gl.SRC_ALPHA,gl.ONE_MINUS_SRC_ALPHA);if(numTransparentHighlightVerticesMeshes>0){for(i=0;i<numTransparentHighlightVerticesMeshes;i++){transparentHighlightVerticesMeshes[i]._drawHighlightVertices(frame)}}
if(numTransparentHighlightEdgesMeshes>0){for(i=0;i<numTransparentHighlightEdgesMeshes;i++){transparentHighlightEdgesMeshes[i]._drawHighlightEdges(frame)}}
if(numTransparentHighlightFillMeshes>0){for(i=0;i<numTransparentHighlightFillMeshes;i++){transparentHighlightFillMeshes[i]._drawHighlightFill(frame)}}
gl.disable(gl.BLEND)}
if(numOpaqueSelectedFillMeshes>0||numOpaqueSelectedEdgesMeshes>0||numOpaqueSelectedVerticesMeshes>0){frame.lastProgramId=null;gl.clear(gl.DEPTH_BUFFER_BIT);if(numOpaqueSelectedVerticesMeshes>0){for(i=0;i<numOpaqueSelectedVerticesMeshes;i++){opaqueSelectedVerticesMeshes[i]._drawSelectedVertices(frame)}}
if(numOpaqueSelectedEdgesMeshes>0){for(i=0;i<numOpaqueSelectedEdgesMeshes;i++){opaqueSelectedEdgesMeshes[i]._drawSelectedEdges(frame)}}
if(numOpaqueSelectedFillMeshes>0){for(i=0;i<numOpaqueSelectedFillMeshes;i++){opaqueSelectedFillMeshes[i]._drawSelectedFill(frame)}}}
if(numTransparentSelectedFillMeshes>0||numTransparentSelectedEdgesMeshes>0||numTransparentSelectedVerticesMeshes>0){frame.lastProgramId=null;gl.clear(gl.DEPTH_BUFFER_BIT);gl.enable(gl.CULL_FACE);gl.enable(gl.BLEND);gl.blendFunc(gl.SRC_ALPHA,gl.ONE_MINUS_SRC_ALPHA);if(numTransparentSelectedVerticesMeshes>0){for(i=0;i<numTransparentSelectedVerticesMeshes;i++){transparentSelectedVerticesMeshes[i]._drawSelectedVertices(frame)}}
if(numTransparentSelectedEdgesMeshes>0){for(i=0;i<numTransparentSelectedEdgesMeshes;i++){transparentSelectedEdgesMeshes[i]._drawSelectedEdges(frame)}}
if(numTransparentSelectedFillMeshes>0){for(i=0;i<numTransparentSelectedFillMeshes;i++){transparentSelectedFillMeshes[i]._drawSelectedFill(frame)}}
gl.disable(gl.BLEND)}
const endTime=Date.now();const frameStats=stats.frame;frameStats.renderTime=(endTime-startTime)/1000.0;frameStats.drawElements=frame.drawElements;frameStats.drawElements=frame.drawElements;frameStats.useProgram=frame.useProgram;frameStats.bindTexture=frame.bindTexture;frameStats.bindArray=frame.bindArray;const numTextureUnits=WEBGL_INFO.MAX_TEXTURE_UNITS;for(let ii=0;ii<numTextureUnits;ii++){gl.activeTexture(gl.TEXTURE0+ii)}
gl.bindTexture(gl.TEXTURE_CUBE_MAP,null);gl.bindTexture(gl.TEXTURE_2D,null);if(unbindOutputFrameBuffer){unbindOutputFrameBuffer(params.pass)}}})();this.pick=(function(){const tempVec3a=math.vec3();const tempMat4a=math.mat4();const up=math.vec3([0,1,0]);const pickFrustumMatrix=math.frustumMat4(-1,1,-1,1,0.1,10000);return function(params){update();if(WEBGL_INFO.SUPPORTED_EXTENSIONS.OES_element_index_uint){gl.getExtension("OES_element_index_uint")}
let canvasX;let canvasY;let origin;let direction;let look;let pickViewMatrix=null;let pickProjMatrix=null;if(params.canvasPos){canvasX=params.canvasPos[0];canvasY=params.canvasPos[1]}else{origin=params.origin||math.vec3([0,0,0]);direction=params.direction||math.vec3([0,0,1]);look=math.addVec3(origin,direction,tempVec3a);pickViewMatrix=math.lookAtMat4v(origin,look,up,tempMat4a);pickProjMatrix=pickFrustumMatrix;canvasX=canvas.clientWidth*0.5;canvasY=canvas.clientHeight*0.5}
pickBuf=pickBuf||new RenderBuffer(canvas,gl);pickBuf.bind();const mesh=pickMesh(canvasX,canvasY,pickViewMatrix,pickProjMatrix,params);if(!mesh){pickBuf.unbind();return null}
const hit={mesh:mesh};if(params.pickSurface){hit.primIndex=pickTriangle(mesh,canvasX,canvasY,pickViewMatrix,pickProjMatrix)}
if(pickViewMatrix){hit.origin=origin;hit.direction=direction}
pickBuf.unbind();return hit}})();function pickMesh(canvasX,canvasY,pickViewMatrix,pickProjMatrix,params){frame.reset();frame.backfaces=!0;frame.frontface=!0;frame.pickViewMatrix=pickViewMatrix;frame.pickProjMatrix=pickProjMatrix;frame.pickMeshIndex=1;const boundary=scene.viewport.boundary;gl.viewport(boundary[0],boundary[1],boundary[2],boundary[3]);gl.clearColor(0,0,0,0);gl.enable(gl.DEPTH_TEST);gl.disable(gl.CULL_FACE);gl.disable(gl.BLEND);gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT);meshPickListLen=0;let i;let len;let mesh;const includeMeshIds=params.includeMeshIds;const excludeMeshIds=params.excludeMeshIds;for(i=0,len=meshListLen;i<len;i++){mesh=meshList[i];if(mesh._state.culled===!0||mesh._state.visible===!1||mesh._state.pickable===!1){continue}
if(includeMeshIds&&!includeMeshIds[mesh.id]){continue}
if(excludeMeshIds&&excludeMeshIds[mesh.id]){continue}
meshPickList[meshPickListLen++]=mesh;mesh._pickMesh(frame)}
const pix=pickBuf.read(Math.round(canvasX),Math.round(canvasY));let pickedMeshIndex=pix[0]+(pix[1]*256)+(pix[2]*256*256)+(pix[3]*256*256*256);pickedMeshIndex--;return pickedMeshIndex>=0?meshPickList[pickedMeshIndex]:null}
function pickTriangle(mesh,canvasX,canvasY,pickViewMatrix,pickProjMatrix){frame.reset();frame.backfaces=!0;frame.frontface=!0;frame.pickViewMatrix=pickViewMatrix;frame.pickProjMatrix=pickProjMatrix;const boundary=scene.viewport.boundary;gl.viewport(boundary[0],boundary[1],boundary[2],boundary[3]);gl.clearColor(0,0,0,0);gl.enable(gl.DEPTH_TEST);gl.disable(gl.CULL_FACE);gl.disable(gl.BLEND);gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT);mesh._pickTriangle(frame);const pix=pickBuf.read(canvasX,canvasY);let primIndex=pix[0]+(pix[1]*256)+(pix[2]*256*256)+(pix[3]*256*256*256);primIndex*=3;return primIndex}
this.readPixels=function(pixels,colors,len,opaqueOnly){readPixelBuf=readPixelBuf||(readPixelBuf=new RenderBuffer(canvas,gl));readPixelBuf.bind();readPixelBuf.clear();this.render({force:!0,opaqueOnly:opaqueOnly});let color;let i;let j;let k;for(i=0;i<len;i++){j=i*2;k=i*4;color=readPixelBuf.read(pixels[j],pixels[j+1]);colors[k]=color[0];colors[k+1]=color[1];colors[k+2]=color[2];colors[k+3]=color[3]}
readPixelBuf.unbind();imageDirty=!0};this.destroy=function(){if(pickBuf){pickBuf.destroy()}
if(readPixelBuf){readPixelBuf.destroy()}}};const type$9="xeogl.Input";class Input extends Component{get type(){return type$9}
init(cfg){super.init(cfg);const self=this;this.KEY_BACKSPACE=8;this.KEY_TAB=9;this.KEY_ENTER=13;this.KEY_SHIFT=16;this.KEY_CTRL=17;this.KEY_ALT=18;this.KEY_PAUSE_BREAK=19;this.KEY_CAPS_LOCK=20;this.KEY_ESCAPE=27;this.KEY_PAGE_UP=33;this.KEY_PAGE_DOWN=34;this.KEY_END=35;this.KEY_HOME=36;this.KEY_LEFT_ARROW=37;this.KEY_UP_ARROW=38;this.KEY_RIGHT_ARROW=39;this.KEY_DOWN_ARROW=40;this.KEY_INSERT=45;this.KEY_DELETE=46;this.KEY_NUM_0=48;this.KEY_NUM_1=49;this.KEY_NUM_2=50;this.KEY_NUM_3=51;this.KEY_NUM_4=52;this.KEY_NUM_5=53;this.KEY_NUM_6=54;this.KEY_NUM_7=55;this.KEY_NUM_8=56;this.KEY_NUM_9=57;this.KEY_A=65;this.KEY_B=66;this.KEY_C=67;this.KEY_D=68;this.KEY_E=69;this.KEY_F=70;this.KEY_G=71;this.KEY_H=72;this.KEY_I=73;this.KEY_J=74;this.KEY_K=75;this.KEY_L=76;this.KEY_M=77;this.KEY_N=78;this.KEY_O=79;this.KEY_P=80;this.KEY_Q=81;this.KEY_R=82;this.KEY_S=83;this.KEY_T=84;this.KEY_U=85;this.KEY_V=86;this.KEY_W=87;this.KEY_X=88;this.KEY_Y=89;this.KEY_Z=90;this.KEY_LEFT_WINDOW=91;this.KEY_RIGHT_WINDOW=92;this.KEY_SELECT_KEY=93;this.KEY_NUMPAD_0=96;this.KEY_NUMPAD_1=97;this.KEY_NUMPAD_2=98;this.KEY_NUMPAD_3=99;this.KEY_NUMPAD_4=100;this.KEY_NUMPAD_5=101;this.KEY_NUMPAD_6=102;this.KEY_NUMPAD_7=103;this.KEY_NUMPAD_8=104;this.KEY_NUMPAD_9=105;this.KEY_MULTIPLY=106;this.KEY_ADD=107;this.KEY_SUBTRACT=109;this.KEY_DECIMAL_POINT=110;this.KEY_DIVIDE=111;this.KEY_F1=112;this.KEY_F2=113;this.KEY_F3=114;this.KEY_F4=115;this.KEY_F5=116;this.KEY_F6=117;this.KEY_F7=118;this.KEY_F8=119;this.KEY_F9=120;this.KEY_F10=121;this.KEY_F11=122;this.KEY_F12=123;this.KEY_NUM_LOCK=144;this.KEY_SCROLL_LOCK=145;this.KEY_SEMI_COLON=186;this.KEY_EQUAL_SIGN=187;this.KEY_COMMA=188;this.KEY_DASH=189;this.KEY_PERIOD=190;this.KEY_FORWARD_SLASH=191;this.KEY_GRAVE_ACCENT=192;this.KEY_OPEN_BRACKET=219;this.KEY_BACK_SLASH=220;this.KEY_CLOSE_BRACKET=221;this.KEY_SINGLE_QUOTE=222;this.KEY_SPACE=32;this.KEY_BACKSPACE=8;this.KEY_TAB=9;this.KEY_ENTER=13;this.KEY_SHIFT=16;this.KEY_CTRL=17;this.KEY_ALT=18;this.KEY_PAUSE_BREAK=19;this.KEY_CAPS_LOCK=20;this.KEY_ESCAPE=27;this.KEY_PAGE_UP=33;this.KEY_PAGE_DOWN=34;this.KEY_END=35;this.KEY_HOME=36;this.KEY_LEFT_ARROW=37;this.KEY_UP_ARROW=38;this.KEY_RIGHT_ARROW=39;this.KEY_DOWN_ARROW=40;this.KEY_INSERT=45;this.KEY_DELETE=46;this.KEY_NUM_0=48;this.KEY_NUM_1=49;this.KEY_NUM_2=50;this.KEY_NUM_3=51;this.KEY_NUM_4=52;this.KEY_NUM_5=53;this.KEY_NUM_6=54;this.KEY_NUM_7=55;this.KEY_NUM_8=56;this.KEY_NUM_9=57;this.KEY_A=65;this.KEY_B=66;this.KEY_C=67;this.KEY_D=68;this.KEY_E=69;this.KEY_F=70;this.KEY_G=71;this.KEY_H=72;this.KEY_I=73;this.KEY_J=74;this.KEY_K=75;this.KEY_L=76;this.KEY_M=77;this.KEY_N=78;this.KEY_O=79;this.KEY_P=80;this.KEY_Q=81;this.KEY_R=82;this.KEY_S=83;this.KEY_T=84;this.KEY_U=85;this.KEY_V=86;this.KEY_W=87;this.KEY_X=88;this.KEY_Y=89;this.KEY_Z=90;this.KEY_LEFT_WINDOW=91;this.KEY_RIGHT_WINDOW=92;this.KEY_SELECT_KEY=93;this.KEY_NUMPAD_0=96;this.KEY_NUMPAD_1=97;this.KEY_NUMPAD_2=98;this.KEY_NUMPAD_3=99;this.KEY_NUMPAD_4=100;this.KEY_NUMPAD_5=101;this.KEY_NUMPAD_6=102;this.KEY_NUMPAD_7=103;this.KEY_NUMPAD_8=104;this.KEY_NUMPAD_9=105;this.KEY_MULTIPLY=106;this.KEY_ADD=107;this.KEY_SUBTRACT=109;this.KEY_DECIMAL_POINT=110;this.KEY_DIVIDE=111;this.KEY_F1=112;this.KEY_F2=113;this.KEY_F3=114;this.KEY_F4=115;this.KEY_F5=116;this.KEY_F6=117;this.KEY_F7=118;this.KEY_F8=119;this.KEY_F9=120;this.KEY_F10=121;this.KEY_F11=122;this.KEY_F12=123;this.KEY_NUM_LOCK=144;this.KEY_SCROLL_LOCK=145;this.KEY_SEMI_COLON=186;this.KEY_EQUAL_SIGN=187;this.KEY_COMMA=188;this.KEY_DASH=189;this.KEY_PERIOD=190;this.KEY_FORWARD_SLASH=191;this.KEY_GRAVE_ACCENT=192;this.KEY_OPEN_BRACKET=219;this.KEY_BACK_SLASH=220;this.KEY_CLOSE_BRACKET=221;this.KEY_SINGLE_QUOTE=222;this.KEY_SPACE=32;this._element=cfg.element;this.altDown=!1;this.ctrlDown=!1;this.mouseDownLeft=!1;this.mouseDownMiddle=!1;this.mouseDownRight=!1;this.keyDown=[];this.enabled=!0;this.mouseover=!1;document.addEventListener("keydown",this._keyDownListener=function(e){if(!self.enabled){return}
if(e.target.tagName!=="INPUT"&&e.target.tagName!=="TEXTAREA"){if(e.ctrlKey){self.ctrlDown=!0}else if(e.altKey){self.altDown=!0}else{self.keyDown[e.keyCode]=!0;self.fire("keydown",e.keyCode,!0)}}
if(self.mouseover){e.preventDefault()}},!0);document.addEventListener("keyup",this._keyUpListener=function(e){if(!self.enabled){return}
if(e.target.tagName!=="INPUT"&&e.target.tagName!=="TEXTAREA"){if(e.ctrlKey){self.ctrlDown=!1}else if(e.altKey){self.altDown=!1}else{self.keyDown[e.keyCode]=!1;self.fire("keyup",e.keyCode,!0)}}});cfg.element.addEventListener("mouseenter",this._mouseEnterListener=function(e){if(!self.enabled){return}
self.mouseover=!0;const coords=self._getClickCoordsWithinElement(e);self.fire("mouseenter",coords,!0)});cfg.element.addEventListener("mouseleave",this._mouseLeaveListener=function(e){if(!self.enabled){return}
self.mouseover=!1;const coords=self._getClickCoordsWithinElement(e);self.fire("mouseleave",coords,!0)});cfg.element.addEventListener("mousedown",this._mouseDownListener=function(e){if(!self.enabled){return}
switch(e.which){case 1:self.mouseDownLeft=!0;break;case 2:self.mouseDownMiddle=!0;break;case 3:self.mouseDownRight=!0;break;default:break}
const coords=self._getClickCoordsWithinElement(e);cfg.element.focus();self.fire("mousedown",coords,!0);if(self.mouseover){e.preventDefault()}});document.addEventListener("mouseup",this._mouseUpListener=function(e){if(!self.enabled){return}
switch(e.which){case 1:self.mouseDownLeft=!1;break;case 2:self.mouseDownMiddle=!1;break;case 3:self.mouseDownRight=!1;break;default:break}
const coords=self._getClickCoordsWithinElement(e);self.fire("mouseup",coords,!0);if(self.mouseover){e.preventDefault()}},!0);document.addEventListener("dblclick",this._dblClickListener=function(e){if(!self.enabled){return}
switch(e.which){case 1:self.mouseDownLeft=!1;self.mouseDownRight=!1;break;case 2:self.mouseDownMiddle=!1;break;case 3:self.mouseDownLeft=!1;self.mouseDownRight=!1;break;default:break}
const coords=self._getClickCoordsWithinElement(e);self.fire("dblclick",coords,!0);if(self.mouseover){e.preventDefault()}});cfg.element.addEventListener("mousemove",this._mouseMoveListener=function(e){if(!self.enabled){return}
const coords=self._getClickCoordsWithinElement(e);self.fire("mousemove",coords,!0);if(self.mouseover){e.preventDefault()}});cfg.element.addEventListener("wheel",this._mouseWheelListener=function(e,d){if(!self.enabled){return}
const delta=Math.max(-1,Math.min(1,-e.deltaY*40));self.fire("mousewheel",delta,!0)},{passive:!0});(function(){let downX;let downY;const tolerance=2;self.on("mousedown",function(params){downX=params[0];downY=params[1]});self.on("mouseup",function(params){if(downX>=(params[0]-tolerance)&&downX<=(params[0]+tolerance)&&downY>=(params[1]-tolerance)&&downY<=(params[1]+tolerance)){self.fire("mouseclicked",params,!0)}})})();(function(){const orientationAngleLookup={'landscape-primary':90,'landscape-secondary':-90,'portrait-secondary':180,'portrait-primary':0};let orientation;let orientationAngle;const acceleration=math.vec3();const accelerationIncludingGravity=math.vec3();const orientationChangeEvent={orientation:null,orientationAngle:0};const deviceMotionEvent={orientationAngle:0,acceleration:null,accelerationIncludingGravity:accelerationIncludingGravity,rotationRate:math.vec3(),interval:0};const deviceOrientationEvent={alpha:0,beta:0,gamma:0,absolute:!1};if(window.OrientationChangeEvent){window.addEventListener('orientationchange',self._orientationchangedListener=function(){orientation=window.screen.orientation||window.screen.mozOrientation||window.msOrientation||null;orientationAngle=orientation?(orientationAngleLookup[orientation]||0):0;orientationChangeEvent.orientation=orientation;orientationChangeEvent.orientationAngle=orientationAngle;self.fire("orientationchange",orientationChangeEvent)},!1)}
if(window.DeviceMotionEvent){window.addEventListener('devicemotion',self._deviceMotionListener=function(e){deviceMotionEvent.interval=e.interval;deviceMotionEvent.orientationAngle=orientationAngle;const accel=e.acceleration;if(accel){acceleration[0]=accel.x;acceleration[1]=accel.y;acceleration[2]=accel.z;deviceMotionEvent.acceleration=acceleration}else{deviceMotionEvent.acceleration=null}
const accelGrav=e.accelerationIncludingGravity;if(accelGrav){accelerationIncludingGravity[0]=accelGrav.x;accelerationIncludingGravity[1]=accelGrav.y;accelerationIncludingGravity[2]=accelGrav.z;deviceMotionEvent.accelerationIncludingGravity=accelerationIncludingGravity}else{deviceMotionEvent.accelerationIncludingGravity=null}
deviceMotionEvent.rotationRate=e.rotationRate;self.fire("devicemotion",deviceMotionEvent)},!1)}
if(window.DeviceOrientationEvent){window.addEventListener("deviceorientation",self._deviceOrientListener=function(e){deviceOrientationEvent.gamma=e.gamma;deviceOrientationEvent.beta=e.beta;deviceOrientationEvent.alpha=e.alpha;deviceOrientationEvent.absolute=e.absolute;self.fire("deviceorientation",deviceOrientationEvent)},!1)}})()}
_getClickCoordsWithinElement(event){const coords=[0,0];if(!event){event=window.event;coords.x=event.x;coords.y=event.y}
else{let element=event.target;let totalOffsetLeft=0;let totalOffsetTop=0;while(element.offsetParent){totalOffsetLeft+=element.offsetLeft;totalOffsetTop+=element.offsetTop;element=element.offsetParent}
coords[0]=event.pageX-totalOffsetLeft;coords[1]=event.pageY-totalOffsetTop}
return coords}
setEnabled(enable){if(this.enabled!==enable){this.fire("enabled",this.enabled=enable)}}
destroy(){super.destroy();document.removeEventListener("keydown",this._keyDownListener);document.removeEventListener("keyup",this._keyUpListener);this._element.removeEventListener("mouseenter",this._mouseEnterListener);this._element.removeEventListener("mouseleave",this._mouseLeaveListener);this._element.removeEventListener("mousedown",this._mouseDownListener);document.removeEventListener("mouseup",this._mouseDownListener);document.removeEventListener("dblclick",this._dblClickListener);this._element.removeEventListener("mousemove",this._mouseMoveListener);this._element.removeEventListener("wheel",this._mouseWheelListener);if(window.OrientationChangeEvent){window.removeEventListener('orientationchange',this._orientationchangedListener)}
if(window.DeviceMotionEvent){window.removeEventListener('devicemotion',this._deviceMotionListener)}
if(window.DeviceOrientationEvent){window.addEventListener("deviceorientation",this._deviceOrientListener)}}}
const type$10="xeogl.Viewport";class Viewport extends Component{get type(){return type$10}
init(cfg){super.init(cfg);this._state=new State({boundary:[0,0,100,100]});this.boundary=cfg.boundary;this.autoBoundary=cfg.autoBoundary}
set boundary(value){if(this._autoBoundary){return}
if(!value){const canvasBoundary=this.scene.canvas.boundary;const width=canvasBoundary[2];const height=canvasBoundary[3];value=[0,0,width,height]}
this._state.boundary=value;this._renderer.imageDirty();this.fire("boundary",this._state.boundary)}
get boundary(){return this._state.boundary}
set autoBoundary(value){value=!!value;if(value===this._autoBoundary){return}
this._autoBoundary=value;if(this._autoBoundary){this._onCanvasSize=this.scene.canvas.on("boundary",function(boundary){const width=boundary[2];const height=boundary[3];this._state.boundary=[0,0,width,height];this._renderer.imageDirty();this.fire("boundary",this._state.boundary)},this)}else if(this._onCanvasSize){this.scene.canvas.off(this._onCanvasSize);this._onCanvasSize=null}
this.fire("autoBoundary",this._autoBoundary)}
get autoBoundary(){return this._autoBoundary}
_getState(){return this._state}
destroy(){super.destroy();this._state.destroy()}}
componentClasses[type$10]=Viewport;const type$11="xeogl.Perspective";class Perspective extends Component{get type(){return type$11}
init(cfg){super.init(cfg);this._state=new State({matrix:math.mat4()});this._dirty=!1;this._fov=60.0;this._near=0.1;this._far=10000.0;this._canvasResized=this.scene.canvas.on("boundary",this._needUpdate,this);this.fov=cfg.fov;this.fovAxis=cfg.fovAxis;this.near=cfg.near;this.far=cfg.far}
_update(){const WIDTH_INDEX=2;const HEIGHT_INDEX=3;const boundary=this.scene.viewport.boundary;const aspect=boundary[WIDTH_INDEX]/boundary[HEIGHT_INDEX];let fov=this._fov;const fovAxis=this._fovAxis;if(fovAxis=="x"||(fovAxis=="min"&&aspect<1)||(fovAxis=="max"&&aspect>1)){fov=fov/aspect}
fov=Math.min(fov,120);math.perspectiveMat4(fov*(Math.PI/180.0),aspect,this._near,this._far,this._state.matrix);this._renderer.imageDirty();this.fire("matrix",this._state.matrix)}
set fov(value){this._fov=(value!==undefined&&value!==null)?value:60.0;this._needUpdate(0);this.fire("fov",this._fov)}
get fov(){return this._fov}
set fovAxis(value){value=value||"min";if(this._fovAxis===value){return}
if(value!=="x"&&value!=="y"&&value!=="min"){this.error("Unsupported value for 'fovAxis': "+value+" - defaulting to 'min'");value="min"}
this._fovAxis=value;this._needUpdate(0);this.fire("fovAxis",this._fovAxis)}
get fovAxis(){return this._fovAxis}
set near(value){this._near=(value!==undefined&&value!==null)?value:0.1;this._needUpdate(0);this.fire("near",this._near)}
get near(){return this._near}
set far(value){this._far=(value!==undefined&&value!==null)?value:10000;this._needUpdate(0);this.fire("far",this._far)}
get far(){return this._far}
get matrix(){if(this._updateScheduled){this._doUpdate()}
return this._state.matrix}
destroy(){super.destroy();this._state.destroy();super.destroy();this.scene.canvas.off(this._canvasResized)}}
componentClasses[type$11]=Perspective;const type$12="xeogl.Ortho";class Ortho extends Component{get type(){return type$12}
init(cfg){super.init(cfg);this._state=new State({matrix:math.mat4()});this.scale=cfg.scale;this.near=cfg.near;this.far=cfg.far;this._onCanvasBoundary=this.scene.canvas.on("boundary",this._needUpdate,this)}
_update(){const WIDTH_INDEX=2;const HEIGHT_INDEX=3;const scene=this.scene;const scale=this._scale;const halfSize=0.5*scale;const boundary=scene.viewport.boundary;const boundaryWidth=boundary[WIDTH_INDEX];const boundaryHeight=boundary[HEIGHT_INDEX];const aspect=boundaryWidth/boundaryHeight;let left;let right;let top;let bottom;if(boundaryWidth>boundaryHeight){left=-halfSize;right=halfSize;top=halfSize/aspect;bottom=-halfSize/aspect}else{left=-halfSize*aspect;right=halfSize*aspect;top=halfSize;bottom=-halfSize}
math.orthoMat4c(left,right,bottom,top,this._near,this._far,this._state.matrix);this._renderer.imageDirty();this.fire("matrix",this._state.matrix)}
set scale(value){if(value===undefined||value===null){value=1.0}
if(value<=0){value=0.01}
this._scale=value;this._needUpdate();this.fire("scale",this._scale)}
get scale(){return this._scale}
set near(value){this._near=(value!==undefined&&value!==null)?value:0.1;this._needUpdate();this.fire("near",this._near)}
get near(){return this._near}
set far(value){this._far=(value!==undefined&&value!==null)?value:10000.0;this._needUpdate();this.fire("far",this._far)}
get far(){return this._far}
get matrix(){if(this._updateScheduled){this._doUpdate()}
return this._state.matrix}
destroy(){super.destroy();this._state.destroy();this.scene.canvas.off(this._onCanvasBoundary)}}
componentClasses[type$12]=Ortho;const type$13="xeogl.Frustum";class Frustum extends Component{get type(){return type$13}
init(cfg){super.init(cfg);this._state=new State({matrix:math.mat4()});this._left=-1.0;this._right=1.0;this._bottom=-1.0;this._top=1.0;this._near=0.1;this._far=5000.0;this.left=cfg.left;this.right=cfg.right;this.bottom=cfg.bottom;this.top=cfg.top;this.near=cfg.near;this.far=cfg.far}
_update(){math.frustumMat4(this._left,this._right,this._bottom,this._top,this._near,this._far,this._state.matrix);this._renderer.imageDirty();this.fire("matrix",this._state.matrix)}
set left(value){this._left=(value!==undefined&&value!==null)?value:-1.0;this._needUpdate();this.fire("left",this._left)}
get left(){return this._left}
set right(value){this._right=(value!==undefined&&value!==null)?value:1.0;this._needUpdate();this.fire("right",this._right)}
get right(){return this._right}
set top(value){this._top=(value!==undefined&&value!==null)?value:1.0;this._needUpdate();this.fire("top",this._top)}
get top(){return this._top}
set bottom(value){this._bottom=(value!==undefined&&value!==null)?value:-1.0;this._needUpdate();this.fire("bottom",this._bottom)}
get bottom(){return this._bottom}
set near(value){this._near=(value!==undefined&&value!==null)?value:0.1;this._needUpdate();this.fire("near",this._near)}
get near(){return this._near}
set far(value){this._far=(value!==undefined&&value!==null)?value:10000.0;this._needUpdate();this.fire("far",this._far)}
get far(){return this._far}
get matrix(){if(this._updateScheduled){this._doUpdate()}
return this._state.matrix}
destroy(){super.destroy();this._state.destroy();super.destroy()}}
componentClasses[type$13]=Frustum;const type$14="xeogl.CustomProjection";class CustomProjection extends Component{get type(){return type$14}
init(cfg){super.init(cfg);this._state=new State({matrix:math.mat4()});this.matrix=cfg.matrix}
set matrix(matrix){this._state.matrix.set(matrix||[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]);this.fire("far",this._state.matrix)}
get matrix(){return this._state.matrix}
destroy(){super.destroy();this._state.destroy()}}
componentClasses[type$14]=CustomProjection;const tempVec3=math.vec3();const tempVec3b=math.vec3();const tempVec3c=math.vec3();const tempVec3d=math.vec3();const tempVec3e=math.vec3();const tempVec3f=math.vec3();const tempMat=math.mat4();const tempMatb=math.mat4();const eyeLookVec=math.vec3();const eyeLookVecNorm=math.vec3();const eyeLookOffset=math.vec3();const offsetEye=math.vec3();const type$15="xeogl.Camera";class Camera extends Component{get type(){return type$15}
init(cfg){super.init(cfg);this._state=new State({deviceMatrix:math.mat4(),hasDeviceMatrix:!1,matrix:math.mat4(),normalMatrix:math.mat4()});this._perspective=new Perspective(this);this._ortho=new Ortho(this);this._frustum=new Frustum(this);this._customProjection=new CustomProjection(this);this._project=this._perspective;this._eye=math.vec3([0,0,10.0]);this._look=math.vec3([0,0,0]);this._up=math.vec3([0,1,0]);this._worldUp=math.vec3([0,1,0]);this._worldRight=math.vec3([1,0,0]);this._worldForward=math.vec3([0,0,-1]);this.deviceMatrix=cfg.deviceMatrix;this.eye=cfg.eye;this.look=cfg.look;this.up=cfg.up;this.worldAxis=cfg.worldAxis;this.gimbalLock=cfg.gimbalLock;this.constrainPitch=cfg.constrainPitch;this.projection=cfg.projection;this._perspective.on("matrix",()=>{if(this._projectionType==="perspective"){this.fire("projMatrix",this._perspective.matrix)}});this._ortho.on("matrix",()=>{if(this._projectionType==="ortho"){this.fire("projMatrix",this._ortho.matrix)}});this._frustum.on("matrix",()=>{if(this._projectionType==="frustum"){this.fire("projMatrix",this._frustum.matrix)}});this._customProjection.on("matrix",()=>{if(this._projectionType==="customProjection"){this.fire("projMatrix",this._customProjection.matrix)}})}
_update(){const state=this._state;let eye;if(this.projection==="ortho"){math.subVec3(this._eye,this._look,eyeLookVec);math.normalizeVec3(eyeLookVec,eyeLookVecNorm);math.mulVec3Scalar(eyeLookVecNorm,1000.0,eyeLookOffset);math.addVec3(this._look,eyeLookOffset,offsetEye);eye=offsetEye}else{eye=this._eye}
if(state.hasDeviceMatrix){math.lookAtMat4v(eye,this._look,this._up,tempMatb);math.mulMat4(state.deviceMatrix,tempMatb,state.matrix)}else{math.lookAtMat4v(eye,this._look,this._up,state.matrix)}
math.inverseMat4(this._state.matrix,this._state.normalMatrix);math.transposeMat4(this._state.normalMatrix);this._renderer.imageDirty();this.fire("matrix",this._state.matrix);this.fire("viewMatrix",this._state.matrix)}
orbitYaw(angle){let lookEyeVec=math.subVec3(this._eye,this._look,tempVec3);math.rotationMat4v(angle*0.0174532925,this._gimbalLock?this._worldUp:this._up,tempMat);lookEyeVec=math.transformPoint3(tempMat,lookEyeVec,tempVec3b);this.eye=math.addVec3(this._look,lookEyeVec,tempVec3c);this.up=math.transformPoint3(tempMat,this._up,tempVec3d)}
orbitPitch(angle){let eye2=math.subVec3(this._eye,this._look,tempVec3);const left=math.cross3Vec3(math.normalizeVec3(eye2,tempVec3b),math.normalizeVec3(this._up,tempVec3c));math.rotationMat4v(angle*0.0174532925,left,tempMat);eye2=math.transformPoint3(tempMat,eye2,tempVec3d);const up=math.transformPoint3(tempMat,this._up,tempVec3e);if(this._constrainPitch){var angle=math.dotVec3(up,this._worldUp)/math.DEGTORAD;if(angle<1){return}}
this.up=up;this.eye=math.addVec3(eye2,this._look,tempVec3f)}
yaw(angle){let look2=math.subVec3(this._look,this._eye,tempVec3);math.rotationMat4v(angle*0.0174532925,this._gimbalLock?this._worldUp:this._up,tempMat);look2=math.transformPoint3(tempMat,look2,tempVec3b);this.look=math.addVec3(look2,this._eye,tempVec3c);if(this._gimbalLock){this.up=math.transformPoint3(tempMat,this._up,tempVec3d)}}
pitch(angle){let look2=math.subVec3(this._look,this._eye,tempVec3);const left=math.cross3Vec3(math.normalizeVec3(look2,tempVec3b),math.normalizeVec3(this._up,tempVec3c));math.rotationMat4v(angle*0.0174532925,left,tempMat);const up=math.transformPoint3(tempMat,this._up,tempVec3f);if(this._constrainPitch){var angle=math.dotVec3(up,this._worldUp)/math.DEGTORAD;if(angle<1){return}}
this.up=up;look2=math.transformPoint3(tempMat,look2,tempVec3d);this.look=math.addVec3(look2,this._eye,tempVec3e)}
pan(pan){const eye2=math.subVec3(this._eye,this._look,tempVec3);const vec=[0,0,0];let v;if(pan[0]!==0){const left=math.cross3Vec3(math.normalizeVec3(eye2,[]),math.normalizeVec3(this._up,tempVec3b));v=math.mulVec3Scalar(left,pan[0]);vec[0]+=v[0];vec[1]+=v[1];vec[2]+=v[2]}
if(pan[1]!==0){v=math.mulVec3Scalar(math.normalizeVec3(this._up,tempVec3c),pan[1]);vec[0]+=v[0];vec[1]+=v[1];vec[2]+=v[2]}
if(pan[2]!==0){v=math.mulVec3Scalar(math.normalizeVec3(eye2,tempVec3d),pan[2]);vec[0]+=v[0];vec[1]+=v[1];vec[2]+=v[2]}
this.eye=math.addVec3(this._eye,vec,tempVec3e);this.look=math.addVec3(this._look,vec,tempVec3f)}
zoom(delta){const vec=math.subVec3(this._eye,this._look,tempVec3);const lenLook=Math.abs(math.lenVec3(vec,tempVec3b));const newLenLook=Math.abs(lenLook+delta);if(newLenLook<0.5){return}
const dir=math.normalizeVec3(vec,tempVec3c);this.eye=math.addVec3(this._look,math.mulVec3Scalar(dir,newLenLook),tempVec3d)}
set eye(value){this._eye.set(value||[0,0,10]);this._needUpdate(0);this.fire("eye",this._eye)}
get eye(){return this._eye}
set look(value){this._look.set(value||[0,0,0]);this._needUpdate(0);this.fire("look",this._look)}
get look(){return this._look}
set up(value){this._up.set(value||[0,1,0]);this._needUpdate(0);this.fire("up",this._up)}
get up(){return this._up}
set deviceMatrix(matrix){this._state.deviceMatrix.set(matrix||[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]);this._state.hasDeviceMatrix=!!matrix;this._needUpdate(0);this.fire("deviceMatrix",this._state.deviceMatrix)}
get deviceMatrix(){return this._state.deviceMatrix}
set worldAxis(value){value=value||[1,0,0,0,1,0,0,0,1];if(!this._worldAxis){this._worldAxis=new Float32Array(value)}else{this._worldAxis.set(value)}
this._worldRight[0]=this._worldAxis[0];this._worldRight[1]=this._worldAxis[1];this._worldRight[2]=this._worldAxis[2];this._worldUp[0]=this._worldAxis[3];this._worldUp[1]=this._worldAxis[4];this._worldUp[2]=this._worldAxis[5];this._worldForward[0]=this._worldAxis[6];this._worldForward[1]=this._worldAxis[7];this._worldForward[2]=this._worldAxis[8];this.fire("worldAxis",this._worldAxis)}
get worldAxis(){return this._worldAxis}
get worldUp(){return this._worldUp}
get worldRight(){return this._worldRight}
get worldForward(){return this._worldForward}
set gimbalLock(value){this._gimbalLock=value!==!1;this.fire("gimbalLock",this._gimbalLock)}
get gimbalLock(){return this._gimbalLock}
set constrainPitch(value){this._constrainPitch=!!value;this.fire("constrainPitch",this._constrainPitch)}
get constrainPitch(){return this._constrainPitch}
get eyeLookDist(){return math.lenVec3(math.subVec3(this._look,this._eye,tempVec3))}
get matrix(){if(this._updateScheduled){this._doUpdate()}
return this._state.matrix}
get viewMatrix(){if(this._updateScheduled){this._doUpdate()}
return this._state.matrix}
get normalMatrix(){if(this._updateScheduled){this._doUpdate()}
return this._state.normalMatrix}
get viewNormalMatrix(){if(this._updateScheduled){this._doUpdate()}
return this._state.normalMatrix}
get projMatrix(){return this[this.projection].matrix}
get perspective(){return this._perspective}
get ortho(){return this._ortho}
get frustum(){return this._frustum}
get customProjection(){return this._customProjection}
set projection(value){value=value||"perspective";if(this._projectionType===value){return}
if(value==="perspective"){this._project=this._perspective}else if(value==="ortho"){this._project=this._ortho}else if(value==="frustum"){this._project=this._frustum}else if(value==="customProjection"){this._project=this._customProjection}else{this.error("Unsupported value for 'projection': "+value+" defaulting to 'perspective'");this._project=this._perspective;value="perspective"}
this._projectionType=value;this._renderer.imageDirty();this._update();this.fire("dirty")}
get projection(){return this._projectionType}
get project(){return this._project}
get view(){return this}
destroy(){super.destroy();this._state.destroy()}}
componentClasses[type$15]=Camera;const type$16="xeogl.DirLight";class DirLight extends Component{get type(){return type$16}
init(cfg){super.init(cfg);const self=this;this._shadowRenderBuf=null;this._shadowViewMatrix=null;this._shadowProjMatrix=null;this._shadowViewMatrixDirty=!0;this._shadowProjMatrixDirty=!0;this._state=new State({type:"dir",dir:math.vec3([1.0,1.0,1.0]),color:math.vec3([0.7,0.7,0.8]),intensity:1.0,space:cfg.space||"view",shadow:!1,shadowDirty:!0,getShadowViewMatrix:(function(){const look=math.vec3();const up=math.vec3([0,1,0]);return function(){if(self._shadowViewMatrixDirty){if(!self._shadowViewMatrix){self._shadowViewMatrix=math.identityMat4()}
const dir=self._state.dir;math.lookAtMat4v([-dir[0],-dir[1],-dir[2]],[0,0,0],up,self._shadowViewMatrix);self._shadowViewMatrixDirty=!1}
return self._shadowViewMatrix}})(),getShadowProjMatrix:function(){if(self._shadowProjMatrixDirty){if(!self._shadowProjMatrix){self._shadowProjMatrix=math.identityMat4()}
math.orthoMat4c(-10,10,-10,10,0,500.0,self._shadowProjMatrix);self._shadowProjMatrixDirty=!1}
return self._shadowProjMatrix},getShadowRenderBuf:function(){if(!self._shadowRenderBuf){self._shadowRenderBuf=new RenderBuffer(self.scene.canvas.canvas,self.scene.canvas.gl,{size:[1024,1024]})}
return self._shadowRenderBuf}});this.dir=cfg.dir;this.color=cfg.color;this.intensity=cfg.intensity;this.shadow=cfg.shadow;this.scene._lightCreated(this)}
set dir(value){this._state.dir.set(value||[1.0,1.0,1.0]);this._shadowViewMatrixDirty=!0;this._renderer.shadowsDirty()}
get dir(){return this._state.dir}
set color(value){this._state.color.set(value||[0.7,0.7,0.8]);this._renderer.imageDirty()}
get color(){return this._state.color}
set intensity(value){value=value!==undefined?value:1.0;this._state.intensity=value;this._renderer.imageDirty()}
get intensity(){return this._state.intensity}
set shadow(value){value=!!value;if(this._state.shadow===value){return}
this._state.shadow=value;this._shadowViewMatrixDirty=!0;this._renderer.shadowsDirty()}
get shadow(){return this._state.shadow}
destroy(){super.destroy();this._state.destroy();if(this._shadowRenderBuf){this._shadowRenderBuf.destroy()}
this.scene._lightDestroyed(this);this._renderer.shadowsDirty()}}
componentClasses[type$16]=DirLight;const type$17="xeogl.BoxGeometry";class BoxGeometry extends Geometry{get type(){return type$17}
init(cfg){let xSize=cfg.xSize||1;if(xSize<0){this.error("negative xSize not allowed - will invert");xSize*=-1}
let ySize=cfg.ySize||1;if(ySize<0){this.error("negative ySize not allowed - will invert");ySize*=-1}
let zSize=cfg.zSize||1;if(zSize<0){this.error("negative zSize not allowed - will invert");zSize*=-1}
const center=cfg.center;const centerX=center?center[0]:0;const centerY=center?center[1]:0;const centerZ=center?center[2]:0;const xmin=-xSize+centerX;const ymin=-ySize+centerY;const zmin=-zSize+centerZ;const xmax=xSize+centerX;const ymax=ySize+centerY;const zmax=zSize+centerZ;super.init(utils.apply(cfg,{positions:[xmax,ymax,zmax,xmin,ymax,zmax,xmin,ymin,zmax,xmax,ymin,zmax,xmax,ymax,zmax,xmax,ymin,zmax,xmax,ymin,zmin,xmax,ymax,zmin,xmax,ymax,zmax,xmax,ymax,zmin,xmin,ymax,zmin,xmin,ymax,zmax,xmin,ymax,zmax,xmin,ymax,zmin,xmin,ymin,zmin,xmin,ymin,zmax,xmin,ymin,zmin,xmax,ymin,zmin,xmax,ymin,zmax,xmin,ymin,zmax,xmax,ymin,zmin,xmin,ymin,zmin,xmin,ymax,zmin,xmax,ymax,zmin],normals:[0,0,1,0,0,1,0,0,1,0,0,1,1,0,0,1,0,0,1,0,0,1,0,0,0,1,0,0,1,0,0,1,0,0,1,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,0,-1,0,0,-1,0,0,-1,0,0,-1],uv:[1,0,0,0,0,1,1,1,0,0,0,1,1,1,1,0,1,1,1,0,0,0,0,1,1,0,0,0,0,1,1,1,0,1,1,1,1,0,0,0,0,1,1,1,1,0,0,0],indices:[0,1,2,0,2,3,4,5,6,4,6,7,8,9,10,8,10,11,12,13,14,12,14,15,16,17,18,16,18,19,20,21,22,20,22,23],tangents:null}));this.box=!0}}
componentClasses[type$17]=BoxGeometry;const PRESETS={"default":{edges:!0,edgeColor:[0.2,0.2,0.2],edgeAlpha:0.5,edgeWidth:1,vertices:!1,vertexColor:[0.4,0.4,0.4],vertexAlpha:0.7,vertexSize:4.0,fill:!0,fillColor:[0.4,0.4,0.4],fillAlpha:0.2},"defaultWhiteBG":{edgeColor:[0.2,0.2,0.2],edgeAlpha:1.0,edgeWidth:1,vertices:!1,vertexColor:[0.4,0.4,0.4],vertexAlpha:0.7,vertexSize:4.0,fill:!0,fillColor:[1,1,1],fillAlpha:0.6},"defaultLightBG":{edges:!0,edgeColor:[0.2,0.2,0.2],edgeAlpha:0.5,edgeWidth:1,vertices:!1,vertexColor:[0.4,0.4,0.4],vertexAlpha:0.7,vertexSize:4.0,fill:!0,fillColor:[0.4,0.4,0.4],fillAlpha:0.2},"defaultDarkBG":{edges:!0,edgeColor:[0.5,0.5,0.5],edgeAlpha:0.5,edgeWidth:1,vertices:!1,vertexColor:[0.4,0.4,0.4],vertexAlpha:0.7,vertexSize:4.0,fill:!0,fillColor:[0.4,0.4,0.4],fillAlpha:0.2},"phosphorous":{edges:!0,edgeColor:[0.9,0.9,0.9],edgeAlpha:0.5,edgeWidth:2,vertices:!1,vertexColor:[0.4,0.4,0.4],vertexAlpha:0.7,vertexSize:1.0,fill:!0,fillColor:[0.0,0.0,0.0],fillAlpha:0.4},"sunset":{edges:!0,edgeColor:[0.9,0.9,0.9],edgeAlpha:0.5,edgeWidth:1,vertices:!1,vertexColor:[0.4,0.4,0.4],vertexAlpha:0.7,vertexSize:1.0,fill:!0,fillColor:[0.9,0.9,0.6],fillAlpha:0.2},"vectorscope":{edges:!0,edgeColor:[0.2,1.0,0.2],edgeAlpha:1,edgeWidth:2,vertices:!0,vertexColor:[0.7,1.0,0.7],vertexAlpha:0.9,vertexSize:8.0,fill:!0,fillColor:[0.0,0.0,0.0],fillAlpha:0.7},"battlezone":{edges:!0,edgeColor:[0.2,1.0,0.2],edgeAlpha:1,edgeWidth:3,vertices:!1,vertexColor:[0.8,1.0,0.8],vertexAlpha:0.9,vertexSize:8.0,fill:!0,fillColor:[0.0,0.0,0.0],fillAlpha:1.0},"sepia":{edges:!0,edgeColor:[0.529411792755127,0.4577854573726654,0.4100345969200134],edgeAlpha:1.0,edgeWidth:1,vertices:!1,vertexColor:[0.7,1.0,0.7],vertexAlpha:0.9,vertexSize:4.0,fill:!0,fillColor:[0.970588207244873,0.7965892553329468,0.6660899519920349],fillAlpha:0.4},"yellowHighlight":{edges:!0,edgeColor:[0.529411792755127,0.4577854573726654,0.4100345969200134],edgeAlpha:1.0,edgeWidth:1,vertices:!1,vertexColor:[0.7,1.0,0.7],vertexAlpha:0.9,vertexSize:4.0,fill:!0,fillColor:[1.0,1.0,0.0],fillAlpha:0.5},"greenSelected":{edges:!0,edgeColor:[0.4577854573726654,0.529411792755127,0.4100345969200134],edgeAlpha:1.0,edgeWidth:1,vertices:!1,vertexColor:[0.7,1.0,0.7],vertexAlpha:0.9,vertexSize:4.0,fill:!0,fillColor:[0.0,1.0,0.0],fillAlpha:0.5},"gamegrid":{edges:!0,edgeColor:[0.4,0.4,1.6],edgeAlpha:0.8,edgeWidth:3,vertices:!1,vertexColor:[0.7,1.0,0.7],vertexAlpha:0.9,vertexSize:4.0,fill:!0,fillColor:[0.2,0.2,0.7],fillAlpha:0.9}};const type$18="xeogl.EmphasisMaterial";class EmphasisMaterial extends Material{static get presets(){return PRESETS};get type(){return type$18}
init(cfg){super.init(cfg);this._state=new State({type:"EmphasisMaterial",edges:null,edgeColor:null,edgeAlpha:null,edgeWidth:null,vertices:null,vertexColor:null,vertexAlpha:null,vertexSize:null,fill:null,fillColor:null,fillAlpha:null,backfaces:!0});this._preset="default";if(cfg.preset){this.preset=cfg.preset;if(cfg.edges!==undefined){this.edges=cfg.edges}
if(cfg.edgeColor){this.edgeColor=cfg.edgeColor}
if(cfg.edgeAlpha!==undefined){this.edgeAlpha=cfg.edgeAlpha}
if(cfg.edgeWidth!==undefined){this.edgeWidth=cfg.edgeWidth}
if(cfg.vertices!==undefined){this.vertices=cfg.vertices}
if(cfg.vertexColor){this.vertexColor=cfg.vertexColor}
if(cfg.vertexAlpha!==undefined){this.vertexAlpha=cfg.vertexAlpha}
if(cfg.vertexSize){this.vertexSize=cfg.vertexSize}
if(cfg.fill!==undefined){this.fill=cfg.fill}
if(cfg.fillColor){this.fillColor=cfg.fillColor}
if(cfg.fillAlpha!==undefined){this.fillAlpha=cfg.fillAlpha}
if(cfg.backfaces!==undefined){this.backfaces=cfg.backfaces}}else{this.edges=cfg.edges;this.edgeColor=cfg.edgeColor;this.edgeAlpha=cfg.edgeAlpha;this.edgeWidth=cfg.edgeWidth;this.vertices=cfg.vertices;this.vertexColor=cfg.vertexColor;this.vertexAlpha=cfg.vertexAlpha;this.vertexSize=cfg.vertexSize;this.fill=cfg.fill;this.fillColor=cfg.fillColor;this.fillAlpha=cfg.fillAlpha;this.backfaces=cfg.backfaces}}
set edges(value){value=value!==!1;if(this._state.edges===value){return}
this._state.edges=value;this._renderer.imageDirty()}
get edges(){return this._state.edges}
set edgeColor(value){let edgeColor=this._state.edgeColor;if(!edgeColor){edgeColor=this._state.edgeColor=new Float32Array(3)}else if(value&&edgeColor[0]===value[0]&&edgeColor[1]===value[1]&&edgeColor[2]===value[2]){return}
if(value){edgeColor[0]=value[0];edgeColor[1]=value[1];edgeColor[2]=value[2]}else{edgeColor[0]=0.2;edgeColor[1]=0.2;edgeColor[2]=0.2}
this._renderer.imageDirty()}
get edgeColor(){return this._state.edgeColor}
set edgeAlpha(value){value=(value!==undefined&&value!==null)?value:0.5;if(this._state.edgeAlpha===value){return}
this._state.edgeAlpha=value;this._renderer.imageDirty()}
get edgeAlpha(){return this._state.edgeAlpha}
set edgeWidth(value){this._state.edgeWidth=value||1.0;this._renderer.imageDirty()}
get edgeWidth(){return this._state.edgeWidth}
set vertices(value){value=!!value;if(this._state.vertices===value){return}
this._state.vertices=value;this._renderer.imageDirty()}
get vertices(){return this._state.vertices}
set vertexColor(value){let vertexColor=this._state.vertexColor;if(!vertexColor){vertexColor=this._state.vertexColor=new Float32Array(3)}else if(value&&vertexColor[0]===value[0]&&vertexColor[1]===value[1]&&vertexColor[2]===value[2]){return}
if(value){vertexColor[0]=value[0];vertexColor[1]=value[1];vertexColor[2]=value[2]}else{vertexColor[0]=0.4;vertexColor[1]=0.4;vertexColor[2]=0.4}
this._renderer.imageDirty()}
get vertexColor(){return this._state.vertexColor}
set vertexAlpha(value){value=(value!==undefined&&value!==null)?value:0.7;if(this._state.vertexAlpha===value){return}
this._state.vertexAlpha=value;this._renderer.imageDirty()}
get vertexAlpha(){return this._state.vertexAlpha}
set vertexSize(value){this._state.vertexSize=value||4.0;this._renderer.imageDirty()}
get vertexSize(){return this._state.vertexSize}
set fill(value){value=value!==!1;if(this._state.fill===value){return}
this._state.fill=value;this._renderer.imageDirty()}
get fill(){return this._state.fill}
set fillColor(value){let fillColor=this._state.fillColor;if(!fillColor){fillColor=this._state.fillColor=new Float32Array(3)}else if(value&&fillColor[0]===value[0]&&fillColor[1]===value[1]&&fillColor[2]===value[2]){return}
if(value){fillColor[0]=value[0];fillColor[1]=value[1];fillColor[2]=value[2]}else{fillColor[0]=0.4;fillColor[1]=0.4;fillColor[2]=0.4}
this._renderer.imageDirty()}
get fillColor(){return this._state.fillColor}
set fillAlpha(value){value=(value!==undefined&&value!==null)?value:0.2;if(this._state.fillAlpha===value){return}
this._state.fillAlpha=value;this._renderer.imageDirty()}
get fillAlpha(){return this._state.fillAlpha}
set backfaces(value){value=!!value;if(this._state.backfaces===value){return}
this._state.backfaces=value;this._renderer.imageDirty()}
get backfaces(){return this._state.backfaces}
set preset(value){value=value||"default";if(this._preset===value){return}
const preset=PRESETS[value];if(!preset){this.error("unsupported preset: '"+value+"' - supported values are "+Object.keys(PRESETS).join(", "));return}
this.edges=preset.edges;this.edgeColor=preset.edgeColor;this.edgeAlpha=preset.edgeAlpha;this.edgeWidth=preset.edgeWidth;this.vertices=preset.vertices;this.vertexColor=preset.vertexColor;this.vertexAlpha=preset.vertexAlpha;this.vertexSize=preset.vertexSize;this.fill=preset.fill;this.fillColor=preset.fillColor;this.fillAlpha=preset.fillAlpha;this._preset=value}
get preset(){return this._preset}
destroy(){super.destroy();this._state.destroy()}}
componentClasses[type$18]=EmphasisMaterial;const PRESETS$1={"default":{edgeColor:[0.0,0.0,0.0],edgeAlpha:1.0,edgeWidth:1},"defaultWhiteBG":{edgeColor:[0.2,0.2,0.2],edgeAlpha:1.0,edgeWidth:1},"defaultLightBG":{edgeColor:[0.2,0.2,0.2],edgeAlpha:1.0,edgeWidth:1},"defaultDarkBG":{edgeColor:[0.5,0.5,0.5],edgeAlpha:1.0,edgeWidth:1}};const type$19="xeogl.EdgeMaterial";class EdgeMaterial extends Material{static get presets(){return PRESETS$1};get type(){return type$19}
init(cfg){super.init(cfg);this._state=new State({type:"EdgeMaterial",edgeColor:null,edgeAlpha:null,edgeWidth:null});this._preset="default";if(cfg.preset){this.preset=cfg.preset;if(cfg.edgeColor){this.edgeColor=cfg.edgeColor}
if(cfg.edgeAlpha!==undefined){this.edgeAlpha=cfg.edgeAlpha}
if(cfg.edgeWidth!==undefined){this.edgeWidth=cfg.edgeWidth}}else{this.edgeColor=cfg.edgeColor;this.edgeAlpha=cfg.edgeAlpha;this.edgeWidth=cfg.edgeWidth}}
set edgeColor(value){let edgeColor=this._state.edgeColor;if(!edgeColor){edgeColor=this._state.edgeColor=new Float32Array(3)}else if(value&&edgeColor[0]===value[0]&&edgeColor[1]===value[1]&&edgeColor[2]===value[2]){return}
if(value){edgeColor[0]=value[0];edgeColor[1]=value[1];edgeColor[2]=value[2]}else{edgeColor[0]=0.2;edgeColor[1]=0.2;edgeColor[2]=0.2}
this._renderer.imageDirty()}
get edgeColor(){return this._state.edgeColor}
set edgeAlpha(value){value=(value!==undefined&&value!==null)?value:1.0;if(this._state.edgeAlpha===value){return}
this._state.edgeAlpha=value;this._renderer.imageDirty()}
get edgeAlpha(){return this._state.edgeAlpha}
set edgeWidth(value){this._state.edgeWidth=value||1.0;this._renderer.imageDirty()}
get edgeWidth(){return this._state.edgeWidth}
set preset(value){value=value||"default";if(this._preset===value){return}
const preset=PRESETS$1[value];if(!preset){this.error("unsupported preset: '"+value+"' - supported values are "+Object.keys(PRESETS$1).join(", "));return}
this.edgeColor=preset.edgeColor;this.edgeAlpha=preset.edgeAlpha;this.edgeWidth=preset.edgeWidth;this._preset=value}
get preset(){return this._preset}
destroy(){super.destroy();this._state.destroy()}}
componentClasses[type$19]=EdgeMaterial;const type$20="xeogl.OutlineMaterial";class OutlineMaterial extends Material{get type(){return type$20}
init(cfg){super.init(cfg);this._state=new State({type:"OutlineMaterial",color:null,alpha:null,width:null});this.color=cfg.color;this.alpha=cfg.alpha;this.width=cfg.width}
set color(value){let color=this._state.color;if(!color){color=this._state.color=new Float32Array(3)}else if(value&&color[0]===value[0]&&color[1]===value[1]&&color[2]===value[2]){return}
if(value){color[0]=value[0];color[1]=value[1];color[2]=value[2]}else{color[0]=1.0;color[1]=0.2;color[2]=0.2}
this._renderer.imageDirty()}
get color(){return this._state.color}
set alpha(value){value=(value!==undefined&&value!==null)?value:1.0;if(this._state.alpha===value){return}
this._state.alpha=value;this._renderer.imageDirty()}
get alpha(){return this._state.alpha}
set width(value){this._state.width=value||4.0;this._renderer.imageDirty()}
get width(){return this._state.width}
destroy(){super.destroy();this._state.destroy()}}
componentClasses[type$20]=OutlineMaterial;const type$21="xeogl.Scene";const localRayOrigin=math.vec3();const localRayDir=math.vec3();const positionA=math.vec3();const positionB=math.vec3();const positionC=math.vec3();const triangleVertices=math.vec3();const position=math.vec4();const worldPos=math.vec3();const viewPos=math.vec3();const bary=math.vec3();const normalA=math.vec3();const normalB=math.vec3();const normalC=math.vec3();const uva=math.vec3();const uvb=math.vec3();const uvc=math.vec3();const tempVec4a=math.vec4();const tempVec4b=math.vec4();const tempVec4c=math.vec4();const tempVec3$1=math.vec3();const tempVec3b$1=math.vec3();const tempVec3c$1=math.vec3();const tempVec3d$1=math.vec3();const tempVec3e$1=math.vec3();const tempVec3f$1=math.vec3();const tempVec3g=math.vec3();const tempVec3h=math.vec3();const tempVec3i=math.vec3();const tempVec3j=math.vec3();const tempVec3k=math.vec3();function getMeshIDMap(scene,meshIds){const map={};let meshId;let mesh;for(let i=0,len=meshIds.length;i<len;i++){meshId=meshIds[i];mesh=scene.meshes[meshId];if(!mesh){scene.warn("pick(): Mesh not found: "+meshId);continue}
map[meshId]=!0}
return map}
class Scene extends Component{get type(){return type$21}
init(cfg){super.init(cfg);const self=this;const transparent=!!cfg.transparent;this.loading=0;this.startTime=(new Date()).getTime();this.models={};this.objects={};this.guidObjects={};this.entityTypes={};this.entities={};this.visibleEntities={};this.ghostedEntities={};this.highlightedEntities={};this.selectedEntities={};this._objectGUIDs=null;this._entityIds=null;this._visibleEntityIds=null;this._ghostedEntityIds=null;this._highlightedEntityIds=null;this._selectedEntityIds=null;this.meshes={};this._needRecompileMeshes=!1;this.types={};this.components={};this.rootObjects={};this.clips={};this.lights={};this.lightMaps={};this.reflectionMaps={};this.canvas=new Canvas(this,{dontClear:!0,canvas:cfg.canvas,transparent:transparent,backgroundColor:cfg.backgroundColor,backgroundImage:cfg.backgroundImage,webgl2:cfg.webgl2!==!1,contextAttr:cfg.contextAttr||{},simulateWebGLContextLost:cfg.simulateWebGLContextLost});this.canvas.on("boundary",function(){self._renderer.imageDirty()});this.canvas.on("webglContextFailed",function(){alert("xeogl failed to find WebGL!")});this._renderer=new Renderer(this,{transparent:transparent});this._clipsState=new(function(){this.clips=[];let hash=null;this.getHash=function(){if(hash){return hash}
const clips=this.clips;if(clips.length===0){return this.hash=";"}
let clip;const hashParts=[];for(let i=0,len=clips.length;i<len;i++){clip=clips[i];hashParts.push("cp")}
hashParts.push(";");hash=hashParts.join("");return hash};this.addClip=function(clip){this.clips.push(clip);hash=null};this.removeClip=function(clip){for(let i=0,len=this.clips.length;i<len;i++){if(this.clips[i].id===clip.id){this.clips.splice(i,1);hash=null;return}}}})();this._lightsState=new(function(){const DEFAULT_AMBIENT=math.vec3([0,0,0]);const ambientColor=math.vec3();this.lights=[];this.reflectionMaps=[];this.lightMaps=[];let hash=null;let ambientLight=null;this.getHash=function(){if(hash){return hash}
const hashParts=[];const lights=this.lights;let light;for(let i=0,len=lights.length;i<len;i++){light=lights[i];hashParts.push("/");hashParts.push(light.type);hashParts.push((light.space==="world")?"w":"v");if(light.shadow){hashParts.push("sh")}}
if(this.lightMaps.length>0){hashParts.push("/lm")}
if(this.reflectionMaps.length>0){hashParts.push("/rm")}
hashParts.push(";");hash=hashParts.join("");return hash};this.addLight=function(state){this.lights.push(state);ambientLight=null;hash=null};this.removeLight=function(state){for(let i=0,len=this.lights.length;i<len;i++){const light=this.lights[i];if(light.id===state.id){this.lights.splice(i,1);if(ambientLight&&ambientLight.id===state.id){ambientLight=null}
hash=null;return}}};this.addReflectionMap=function(state){this.reflectionMaps.push(state);hash=null};this.removeReflectionMap=function(state){for(let i=0,len=this.reflectionMaps.length;i<len;i++){if(this.reflectionMaps[i].id===state.id){this.reflectionMaps.splice(i,1);hash=null;return}}};this.addLightMap=function(state){this.lightMaps.push(state);hash=null};this.removeLightMap=function(state){for(let i=0,len=this.lightMaps.length;i<len;i++){if(this.lightMaps[i].id===state.id){this.lightMaps.splice(i,1);hash=null;return}}};this.getAmbientColor=function(){if(!ambientLight){for(let i=0,len=this.lights.length;i<len;i++){const light=this.lights[i];if(light.type==="ambient"){ambientLight=light;break}}}
if(ambientLight){const color=ambientLight.color;const intensity=ambientLight.intensity;ambientColor[0]=color[0]*intensity;ambientColor[1]=color[1]*intensity;ambientColor[2]=color[2]*intensity;return ambientColor}else{return DEFAULT_AMBIENT}}})();this.input=new Input(this,{dontClear:!0,element:this.canvas.canvas});core._addScene(this);const componentJSONs=cfg.components;if(componentJSONs){let componentJSON;let type;let constr;for(let i=0,len=componentJSONs.length;i<len;i++){componentJSON=componentJSONs[i];type=componentJSON.type;if(type){constr=window[type];if(constr){new constr(this,componentJSON)}}}}
this._initDefaults();this._viewport=new Viewport(this,{id:"default.viewport",autoBoundary:!0,dontClear:!0});this._camera=new Camera(this,{id:"default.camera",dontClear:!0});new DirLight(this,{dir:[0.8,-0.6,-0.8],color:[1.0,1.0,1.0],intensity:1.0,space:"view"});new DirLight(this,{dir:[-0.8,-0.4,-0.4],color:[1.0,1.0,1.0],intensity:1.0,space:"view"});new DirLight(this,{dir:[0.2,-0.8,0.8],color:[0.6,0.6,0.6],intensity:1.0,space:"view"});const viewport=this._viewport;const renderer=this._renderer;const camera=this._camera;camera.on("dirty",function(){renderer.imageDirty()});this.ticksPerRender=cfg.ticksPerRender;this.passes=cfg.passes;this.clearEachPass=cfg.clearEachPass;this.gammaInput=cfg.gammaInput;this.gammaOutput=cfg.gammaOutput;this.gammaFactor=cfg.gammaFactor}
_initDefaults(){let dummy;dummy=this.geometry;dummy=this.material;dummy=this.ghostMaterial;dummy=this.outlineMaterial}
_addComponent(component){if(component.id){if(this.components[component.id]){this.error("Component "+utils.inQuotes(component.id)+" already exists in Scene - ignoring ID, will randomly-generate instead");component.id=null}}
if(!component.id){if(window.nextID===undefined){window.nextID=0}
component.id="_"+window.nextID++;while(this.components[component.id]){component.id=math.createUUID()}}
this.components[component.id]=component;const type=component.type;let types=this.types[component.type];if(!types){types=this.types[type]={}}
types[component.id]=component}
_removeComponent(component){delete this.components[component.id];const types=this.types[component.type];if(types){delete types[component.id];if(utils.isEmptyObject(types)){delete this.types[component.type]}}}
_clipCreated(clip){this.clips[clip.id]=clip;this.scene._clipsState.addClip(clip._state);this._needRecompileMeshes=!0}
_lightCreated(light){this.lights[light.id]=light;this.scene._lightsState.addLight(light._state);this._needRecompileMeshes=!0}
_lightMapCreated(lightMap){this.lightMaps[lightMap.id]=lightMap;this.scene._lightsState.addLightMap(lightMap._state);this._needRecompileMeshes=!0}
_reflectionMapCreated(reflectionMap){this.reflectionMaps[reflectionMap.id]=reflectionMap;this.scene._lightsState.addReflectionMap(reflectionMap._state);this._needRecompileMeshes=!0}
_objectCreated(object){this.objects[object.id]=object;if(object.guid){this.guidObjects[object.id]=object;this._objectGUIDs=null}
if(!object.parent){this.rootObjects[object.id]=object}
stats.components.objects++}
_meshCreated(mesh){this.meshes[mesh.id]=mesh;stats.components.meshes++}
_modelCreated(model){this.models[model.id]=model;stats.components.models++}
_clipDestroyed(clip){delete this.clips[clip.id];this.scene._clipsState.removeClip(clip._state);this._needRecompileMeshes=!0}
_lightDestroyed(light){delete this.lights[light.id];this.scene._lightsState.removeLight(light._state);this._needRecompileMeshes=!0}
_lightMapDestroyed(lightMap){delete this.lightMaps[lightMap.id];this.scene._lightsState.removeLightMap(lightMap._state);this._needRecompileMeshes=!0}
_reflectionMapDestroyed(reflectionMap){delete this.reflectionMaps[reflectionMap.id];this.scene._lightsState.removeReflectionMap(reflectionMap._state);this._needRecompileMeshes=!0}
_objectDestroyed(object){delete this.objects[object.id];if(object.guid){delete this.guidObjects[object.guid];this._objectGUIDs=null}
if(!object.parent){delete this.rootObjects[object.id]}
stats.components.objects--}
_meshDestroyed(mesh){stats.components.meshes--;delete this.meshes[mesh.id];stats.components.meshes--}
_modelDestroyed(model){this.models[model.id]=model;stats.components.models++}
_entityTypeAssigned(object,newEntityType){this.entities[object.id]=object;let objectsOfType=this.entityTypes[newEntityType];if(!objectsOfType){objectsOfType={};this.entityTypes[newEntityType]=objectsOfType}
objectsOfType[object.id]=object;this._entityIds=null;this._entityTypeIds=null}
_entityTypeRemoved(object,oldEntityType){delete this.entities[object.id];const objectsOfType=this.entityTypes[oldEntityType];if(objectsOfType){delete objectsOfType[object.id]}
this._entityIds=null;this._entityTypeIds=null}
_entityVisibilityUpdated(object,visible){if(visible){this.visibleEntities[object.id]=object}else{delete this.visibleEntities[object.id]}
this._visibleEntityIds=null}
_entityGhostedUpdated(object,ghosted){if(ghosted){this.ghostedEntities[object.id]=object}else{delete this.ghostedEntities[object.id]}
this._ghostedEntityIds=null}
_entityHighlightedUpdated(object,highlighted){if(highlighted){this.highlightedEntities[object.id]=object}else{delete this.highlightedEntities[object.id]}
this._highlightedEntityIds=null}
_entitySelectedUpdated(object,selected){if(selected){this.selectedEntities[object.id]=object}else{delete this.selectedEntities[object.id]}
this._selectedEntityIds=null}
_webglContextLost(){this.canvas.spinner.processes++;for(const id in this.components){if(this.components.hasOwnProperty(id)){const component=this.components[id];if(component._webglContextLost){component._webglContextLost()}}}
this._renderer.webglContextLost()}
_webglContextRestored(){const gl=this.canvas.gl;for(const id in this.components){if(this.components.hasOwnProperty(id)){const component=this.components[id];if(component._webglContextRestored){component._webglContextRestored(gl)}}}
this._renderer.webglContextRestored(gl);this.canvas.spinner.processes--}
render(forceRender){const renderEvent={sceneId:null,pass:0};if(this._needRecompileMeshes){this._recompileMeshes();this._needRecompileMeshes=!1}
if(this.loading>0||this.canvas.spinner.processes>0){this.canvas.canvas.style.opacity=0.0;return}
let opacity=Number.parseFloat(this.canvas.canvas.style.opacity);if(opacity<1.0){opacity+=0.1;this.canvas.canvas.style.opacity=opacity}
renderEvent.sceneId=this.id;const passes=this._passes;const clearEachPass=this._clearEachPass;let pass;let clear;for(pass=0;pass<passes;pass++){renderEvent.pass=pass;this.fire("rendering",renderEvent,!0);clear=clearEachPass||(pass===0);this._renderer.render({pass:pass,clear:clear,force:forceRender});this.fire("rendered",renderEvent,!0)}
this._saveAmbientColor()}
_recompileMeshes(){for(const id in this.meshes){if(this.meshes.hasOwnProperty(id)){this.meshes[id]._compile()}}}
_saveAmbientColor(){const canvas=this.canvas;if(!canvas.transparent&&!canvas.backgroundImage&&!canvas.backgroundColor){const ambientColor=this._lightsState.getAmbientColor();if(!this._lastAmbientColor||this._lastAmbientColor[0]!==ambientColor[0]||this._lastAmbientColor[1]!==ambientColor[1]||this._lastAmbientColor[2]!==ambientColor[2]||this._lastAmbientColor[3]!==ambientColor[3]){canvas.backgroundColor=ambientColor;if(!this._lastAmbientColor){this._lastAmbientColor=math.vec4([0,0,0,1])}
this._lastAmbientColor.set(ambientColor)}}else{this._lastAmbientColor=null}}
get objectGUIDs(){if(!this._objectGUIDs){this._objectGUIDs=Object.keys(this.guidObjects)}
return this._objectGUIDs}
get entityTypeIds(){if(!this._entityTypeIds){this._entityTypeIds=Object.keys(this.entityTypes)}
return this._entityTypeIds}
get entityIds(){if(!this._entityIds){this._entityIds=Object.keys(this.entities)}
return this._entityIds}
get visibleEntityIds(){if(!this._visibleEntityIds){this._visibleEntityIds=Object.keys(this.visibleEntities)}
return this._visibleEntityIds}
get ghostedEntityIds(){if(!this._ghostedEntityIds){this._ghostedEntityIds=Object.keys(this.ghostedEntities)}
return this._ghostedEntityIds}
get highlightedEntityIds(){if(!this._highlightedEntityIds){this._highlightedEntityIds=Object.keys(this.highlightedEntities)}
return this._highlightedEntityIds}
get selectedEntityIds(){if(!this._selectedEntityIds){this._selectedEntityIds=Object.keys(this.selectedEntities)}
return this._selectedEntityIds}
set ticksPerRender(value){if(value===undefined||value===null){value=1}else if(!utils.isNumeric(value)||value<=0){this.error("Unsupported value for 'ticksPerRender': '"+value+"' - should be an integer greater than zero.");value=1}
if(value===this._ticksPerRender){return}
this._ticksPerRender=value}
get ticksPerRender(){return this._ticksPerRender}
set passes(value){if(value===undefined||value===null){value=1}else if(!utils.isNumeric(value)||value<=0){this.error("Unsupported value for 'passes': '"+value+"' - should be an integer greater than zero.");value=1}
if(value===this._passes){return}
this._passes=value;this._renderer.imageDirty()}
get passes(){return this._passes}
set clearEachPass(value){value=!!value;if(value===this._clearEachPass){return}
this._clearEachPass=value;this._renderer.imageDirty()}
get clearEachPass(){return this._clearEachPass}
set gammaInput(value){value=value!==!1;if(value===this._renderer.gammaInput){return}
this._renderer.gammaInput=value;this._needRecompileMeshes=!0}
get gammaInput(){return this._renderer.gammaInput}
set gammaOutput(value){value=value!==!1;if(value===this._renderer.gammaOutput){return}
this._renderer.gammaOutput=value;this._needRecompileMeshes=!0}
get gammaOutput(){return this._renderer.gammaOutput}
set gammaFactor(value){value=(value===undefined||value===null)?2.2:value;if(value===this._renderer.gammaFactor){return}
this._renderer.gammaFactor=value;this._renderer.imageDirty()}
get gammaFactor(){return this._renderer.gammaFactor}
get geometry(){return this.components["default.geometry"]||new BoxGeometry(this,{id:"default.geometry",dontClear:!0})}
get material(){return this.components["default.material"]||new PhongMaterial(this,{id:"default.material",emissive:[0.4,0.4,0.4],dontClear:!0})}
get ghostMaterial(){return this.components["default.ghostMaterial"]||new EmphasisMaterial(this,{id:"default.ghostMaterial",preset:"sepia",dontClear:!0})}
get highlightMaterial(){return this.components["default.highlightMaterial"]||new EmphasisMaterial(this,{id:"default.highlightMaterial",preset:"yellowHighlight",dontClear:!0})}
get selectedMaterial(){return this.components["default.selectedMaterial"]||new EmphasisMaterial(this,{id:"default.selectedMaterial",preset:"greenSelected",dontClear:!0})}
get edgeMaterial(){return this.components["default.edgeMaterial"]||new EdgeMaterial(this,{id:"default.edgeMaterial",preset:"default",edgeColor:[0.0,0.0,0.0],edgeAlpha:1.0,edgeWidth:1,dontClear:!0})}
get outlineMaterial(){return this.components["default.outlineMaterial"]||new OutlineMaterial(this,{id:"default.outlineMaterial",dontClear:!0})}
get viewport(){return this._viewport}
get camera(){return this._camera}
get center(){if(this._aabbDirty||!this._center){if(!this._center||!this._center){this._center=math.vec3()}
const aabb=this.aabb;this._center[0]=(aabb[0]+aabb[3])/2;this._center[1]=(aabb[1]+aabb[4])/2;this._center[2]=(aabb[2]+aabb[5])/2}
return this._center}
get aabb(){if(this._aabbDirty){if(!this._aabb){this._aabb=math.AABB3()}
let xmin=math.MAX_DOUBLE;let ymin=math.MAX_DOUBLE;let zmin=math.MAX_DOUBLE;let xmax=-math.MAX_DOUBLE;let ymax=-math.MAX_DOUBLE;let zmax=-math.MAX_DOUBLE;let aabb;const meshes=this.meshes;let mesh;for(const meshId in meshes){if(meshes.hasOwnProperty(meshId)){mesh=meshes[meshId];if(!mesh.collidable){continue}
aabb=mesh.aabb;if(aabb[0]<xmin){xmin=aabb[0]}
if(aabb[1]<ymin){ymin=aabb[1]}
if(aabb[2]<zmin){zmin=aabb[2]}
if(aabb[3]>xmax){xmax=aabb[3]}
if(aabb[4]>ymax){ymax=aabb[4]}
if(aabb[5]>zmax){zmax=aabb[5]}}}
this._aabb[0]=xmin;this._aabb[1]=ymin;this._aabb[2]=zmin;this._aabb[3]=xmax;this._aabb[4]=ymax;this._aabb[5]=zmax;this._aabbDirty=!1}
return this._aabb}
_setBoundaryDirty(){this._aabbDirty=!0;this.fire("boundary")}
pick(params){if(this.canvas.boundary[2]===0||this.canvas.boundary[3]===0){this.error("Picking not allowed while canvas has zero width or height");return null}
params=params||{};params.pickSurface=params.pickSurface||params.rayPick;if(!params.canvasPos&&(!params.origin||!params.direction)){this.warn("picking without canvasPos or ray origin and direction")}
const includeMeshes=params.includeMeshes||params.include;if(includeMeshes){params.includeMeshIds=getMeshIDMap(this,includeMeshes)}
const excludeMeshes=params.excludeMeshes||params.exclude;if(excludeMeshes){params.excludeMeshIds=getMeshIDMap(this,excludeMeshes)}
const hit=this._renderer.pick(params);if(hit){hit.object=hit.mesh;if(params.pickSurface){if(hit.primIndex!==undefined&&hit.primIndex>-1){const geometry=hit.mesh.geometry._state;if(geometry.primitiveName==="triangles"){hit.primitive="triangle";const i=hit.primIndex;const indices=geometry.indices;const positions=geometry.positions;let ia3;let ib3;let ic3;if(indices){var ia=indices[i+0];var ib=indices[i+1];var ic=indices[i+2];triangleVertices[0]=ia;triangleVertices[1]=ib;triangleVertices[2]=ic;hit.indices=triangleVertices;ia3=ia*3;ib3=ib*3;ic3=ic*3}else{ia3=i*3;ib3=ia3+3;ic3=ib3+3}
positionA[0]=positions[ia3+0];positionA[1]=positions[ia3+1];positionA[2]=positions[ia3+2];positionB[0]=positions[ib3+0];positionB[1]=positions[ib3+1];positionB[2]=positions[ib3+2];positionC[0]=positions[ic3+0];positionC[1]=positions[ic3+1];positionC[2]=positions[ic3+2];if(geometry.quantized){const positionsDecodeMatrix=geometry.positionsDecodeMatrix;if(positionsDecodeMatrix){math.decompressPosition(positionA,positionsDecodeMatrix,positionA);math.decompressPosition(positionB,positionsDecodeMatrix,positionB);math.decompressPosition(positionC,positionsDecodeMatrix,positionC)}}
let canvasPos;if(params.canvasPos){canvasPos=params.canvasPos;hit.canvasPos=params.canvasPos;math.canvasPosToLocalRay(this.camera,hit.mesh,canvasPos,localRayOrigin,localRayDir)}else if(params.origin&&params.direction){math.worldRayToLocalRay(hit.mesh,params.origin,params.direction,localRayOrigin,localRayDir)}
math.normalizeVec3(localRayDir);math.rayPlaneIntersect(localRayOrigin,localRayDir,positionA,positionB,positionC,position);hit.localPos=position;hit.position=position;tempVec4a[0]=position[0];tempVec4a[1]=position[1];tempVec4a[2]=position[2];tempVec4a[3]=1;math.transformVec4(hit.mesh.worldMatrix,tempVec4a,tempVec4b);worldPos[0]=tempVec4b[0];worldPos[1]=tempVec4b[1];worldPos[2]=tempVec4b[2];hit.worldPos=worldPos;math.transformVec4(hit.mesh.scene.camera.matrix,tempVec4b,tempVec4c);viewPos[0]=tempVec4c[0];viewPos[1]=tempVec4c[1];viewPos[2]=tempVec4c[2];hit.viewPos=viewPos;math.cartesianToBarycentric(position,positionA,positionB,positionC,bary);hit.bary=bary;const normals=geometry.normals;if(normals){if(geometry.quantized){const ia2=ia*2;const ib2=ib*2;const ic2=ic*2;math.octDecodeVec2(normals.subarray(ia2,ia2+2),normalA);math.octDecodeVec2(normals.subarray(ib2,ib2+2),normalB);math.octDecodeVec2(normals.subarray(ic2,ic2+2),normalC)}else{normalA[0]=normals[ia3];normalA[1]=normals[ia3+1];normalA[2]=normals[ia3+2];normalB[0]=normals[ib3];normalB[1]=normals[ib3+1];normalB[2]=normals[ib3+2];normalC[0]=normals[ic3];normalC[1]=normals[ic3+1];normalC[2]=normals[ic3+2]}
const normal=math.addVec3(math.addVec3(math.mulVec3Scalar(normalA,bary[0],tempVec3$1),math.mulVec3Scalar(normalB,bary[1],tempVec3b$1),tempVec3c$1),math.mulVec3Scalar(normalC,bary[2],tempVec3d$1),tempVec3e$1);hit.normal=math.transformVec3(hit.mesh.worldNormalMatrix,normal,tempVec3f$1)}
const uvs=geometry.uv;if(uvs){uva[0]=uvs[(ia*2)];uva[1]=uvs[(ia*2)+1];uvb[0]=uvs[(ib*2)];uvb[1]=uvs[(ib*2)+1];uvc[0]=uvs[(ic*2)];uvc[1]=uvs[(ic*2)+1];if(geometry.quantized){const uvDecodeMatrix=geometry.uvDecodeMatrix;if(uvDecodeMatrix){math.decompressUV(uva,uvDecodeMatrix,uva);math.decompressUV(uvb,uvDecodeMatrix,uvb);math.decompressUV(uvc,uvDecodeMatrix,uvc)}}
hit.uv=math.addVec3(math.addVec3(math.mulVec2Scalar(uva,bary[0],tempVec3g),math.mulVec2Scalar(uvb,bary[1],tempVec3h),tempVec3i),math.mulVec2Scalar(uvc,bary[2],tempVec3j),tempVec3k)}}}}
hit.mesh.fire("picked",hit);return hit}}
getAABB(target){if(target===undefined){return this.aabb}
if(utils.isString(target)){const object=this.objects[target];if(object){return object.aabb}
target=[target]}
if(target.length===0){return this.aabb}
let xmin=100000;let ymin=100000;let zmin=100000;let xmax=-100000;let ymax=-100000;let zmax=-100000;let valid;this.withObjects(target,object=>{const aabb=object.aabb;if(aabb[0]<xmin){xmin=aabb[0]}
if(aabb[1]<ymin){ymin=aabb[1]}
if(aabb[2]<zmin){zmin=aabb[2]}
if(aabb[3]>xmax){xmax=aabb[3]}
if(aabb[4]>ymax){ymax=aabb[4]}
if(aabb[5]>zmax){zmax=aabb[5]}
valid=!0});if(valid){const aabb2=math.AABB3();aabb2[0]=xmin;aabb2[1]=ymin;aabb2[2]=zmin;aabb2[3]=xmax;aabb2[4]=ymax;aabb2[5]=zmax;return aabb2}else{return this.aabb}}
clear(){var component;for(const id in this.components){if(this.components.hasOwnProperty(id)){component=this.components[id];if(!component._dontClear){component.destroy()}}}}
clearLights(){const ids=Object.keys(this.lights);for(let i=0,len=ids.length;i<len;i++){this.lights[ids[i]].destroy()}}
clearClips(){const ids=Object.keys(this.clips);for(let i=0,len=ids.length;i<len;i++){this.clips[ids[i]].destroy()}}
setVisible(ids,visible){return this.withObjects(ids,object=>{const changed=(object.visible!==visible);object.visible=visible;return changed})}
setCulled(ids,culled){return this.withObjects(ids,object=>{const changed=(object.culled!==culled);object.culled=culled;return changed})}
setSelected(ids,selected){return this.withObjects(ids,object=>{const changed=(object.selected!==selected);object.selected=selected;return changed})}
setHighlighted(ids,highlighted){return this.withObjects(ids,object=>{const changed=(object.highlighted!==highlighted);object.highlighted=highlighted;return changed})}
setGhosted(ids,ghosted){return this.withObjects(ids,object=>{const changed=(object.ghosted!==ghosted);object.ghosted=ghosted;return changed})}
setEdges(ids,edges){return this.withObjects(ids,object=>{const changed=(object.edges!==edges);object.edges=edges;return changed})}
setOutlined(ids,outlined){return this.withObjects(ids,object=>{const changed=(object.outlined!==outlined);object.outlined=outlined;return changed})}
setColorize(ids,colorize){return this.withObjects(ids,object=>{object.colorize=colorize})}
setOpacity(ids,opacity){return this.withObjects(ids,object=>{object.opacity=opacity})}
setPickable(ids,pickable){return this.withObjects(ids,object=>{const changed=(object.pickable!==pickable);object.pickable=pickable;return changed})}
withObjects(ids,callback){if(utils.isString(ids)){ids=[ids]}
let changed=!1;for(let i=0,len=ids.length;i<len;i++){const id=ids[i];let object=this.objects[id];if(object){changed=callback(object)||changed}else{object=this.guidObjects[id];if(object){changed=callback(object)||changed}else{const objects=this.entityTypes[id];if(objects){for(const objectId in objects){if(objects.hasOwnProperty(objectId)){changed=callback(objects[objectId])||changed}}}}}}
return changed}
destroy(){super.destroy();for(const id in this.components){if(this.components.hasOwnProperty(id)){this.components[id].destroy()}}
this.canvas.gl=null;this.models=null;this.objects=null;this.guidObjects=null;this.entityTypes=null;this.entities=null;this.visibleEntities=null;this.ghostedEntities=null;this.highlightedEntities=null;this.selectedEntities=null;this.clips=null;this.lights=null;this.lightMaps=null;this.reflectionMaps=null;this._objectGUIDs=null;this._entityIds=null;this._visibleEntityIds=null;this._ghostedEntityIds=null;this._highlightedEntityIds=null;this._selectedEntityIds=null;this.meshes=null;this.types=null;this.components=null;this.rootObjects=null;this.canvas=null;this._renderer=null;this.input=null;this._viewport=null;this._camera=null}}
componentClasses[type$21]=Scene;const scenesRenderInfo={};const sceneIDMap=new Map();let defaultScene=null;const core={version:null,scenes:{},_superTypes:{},getDefaultScene(){if(!defaultScene){defaultScene=new Scene({id:"default.scene"})}
return defaultScene},setDefaultScene(scene){defaultScene=scene;return defaultScene},_addScene(scene){if(scene.id){if(core.scenes[scene.id]){console.error(`[ERROR] Scene ${utils.inQuotes(scene.id)} already exists`);return}}else{scene.id=sceneIDMap.addItem({})}
core.scenes[scene.id]=scene;const ticksPerRender=scene.ticksPerRender;scenesRenderInfo[scene.id]={ticksPerRender,renderCountdown:ticksPerRender};stats.components.scenes++;scene.on("destroyed",()=>{sceneIDMap.removeItem(scene.id);delete core.scenes[scene.id];delete scenesRenderInfo[scene.id];stats.components.scenes--})},clear(){let scene;for(const id in core.scenes){if(core.scenes.hasOwnProperty(id)){scene=core.scenes[id];if(id==="default.scene"){scene.clear()}else{scene.destroy();delete core.scenes[scene.id]}}}},isComponentType:function(type,superType="xeogl.Component"){if(type===superType){return!0}
var clas=componentClasses[type];if(!clas){return!1}
var superClas=componentClasses[superType];if(!superClas){return!1}
let result=subclasses(clas,superClas);return result}};function subclasses(ChildClass,ParentClass){var c=ChildClass.prototype;while(c!==null){if(c===ParentClass.prototype){return!0}
c=c.__proto__}
return!1}
const scenesRenderInfo$1={};const tickEvent={sceneId:null,time:null,startTime:null,prevTime:null,deltaTime:null};const taskBudget=10;const fpsSamples=[];const numFPSSamples=30;let lastTime=0;let elapsedTime;let totalFPS=0;const frame=function(){let time=Date.now();if(lastTime>0){elapsedTime=time-lastTime;var newFPS=1000/elapsedTime;totalFPS+=newFPS;fpsSamples.push(newFPS);if(fpsSamples.length>=numFPSSamples){totalFPS-=fpsSamples.shift()}
stats.frame.fps=Math.round(totalFPS/fpsSamples.length)}
runTasks(time);fireTickEvents(time);renderScenes();lastTime=time;window.requestAnimationFrame(frame)};function runTasks(time){const tasksRun=tasks.runTasks(time+taskBudget);const tasksScheduled=tasks.getNumTasks();stats.frame.tasksRun=tasksRun;stats.frame.tasksScheduled=tasksScheduled;stats.frame.tasksBudget=taskBudget}
function fireTickEvents(time){tickEvent.time=time;for(var id in core.scenes){if(core.scenes.hasOwnProperty(id)){var scene=core.scenes[id];tickEvent.sceneId=id;tickEvent.startTime=scene.startTime;tickEvent.deltaTime=tickEvent.prevTime!=null?tickEvent.time-tickEvent.prevTime:0;scene.fire("tick",tickEvent,!0)}}
tickEvent.prevTime=time}
function renderScenes(){const scenes=core.scenes;const forceRender=!1;let scene;let renderInfo;let ticksPerRender;let id;for(id in scenes){if(scenes.hasOwnProperty(id)){scene=scenes[id];renderInfo=scenesRenderInfo$1[id];if(!renderInfo){renderInfo=scenesRenderInfo$1[id]={}}
ticksPerRender=scene.ticksPerRender;if(renderInfo.ticksPerRender!==ticksPerRender){renderInfo.ticksPerRender=ticksPerRender;renderInfo.renderCountdown=ticksPerRender}
if(--renderInfo.renderCountdown===0){scene.render(forceRender);renderInfo.renderCountdown=ticksPerRender}}}}
window.requestAnimationFrame(frame);const type$22="xeogl.CameraFlightAnimation";const tempVec3$2=math.vec3();const newLook=math.vec3();const newEye=math.vec3();const newUp=math.vec3();const newLookEyeVec=math.vec3();const lookEyeVec=math.vec3();class CameraFlightAnimation extends Component{get type(){return type$22}
init(cfg){super.init(cfg);this._aabbHelper=new Mesh(this,{geometry:new AABBGeometry(this),material:new PhongMaterial(this,{diffuse:[0,0,0],ambient:[0,0,0],specular:[0,0,0],emissive:[0.5,1.0,0.5],lineWidth:2}),visible:!1,collidable:!1});this._look1=math.vec3();this._eye1=math.vec3();this._up1=math.vec3();this._look2=math.vec3();this._eye2=math.vec3();this._up2=math.vec3();this._orthoScale1=1;this._orthoScale2=1;this._flying=!1;this._flyEyeLookUp=!1;this._flyingEye=!1;this._flyingLook=!1;this._callback=null;this._callbackScope=null;this._time1=null;this._time2=null;this.easing=cfg.easing!==!1;this.duration=cfg.duration;this.fit=cfg.fit;this.fitFOV=cfg.fitFOV;this.trail=cfg.trail}
flyTo(params,callback,scope){params=params||this.scene;if(this._flying){this.stop()}
this._flying=!1;this._callback=callback;this._callbackScope=scope;const camera=this.scene.camera;this._eye1[0]=camera.eye[0];this._eye1[1]=camera.eye[1];this._eye1[2]=camera.eye[2];this._look1[0]=camera.look[0];this._look1[1]=camera.look[1];this._look1[2]=camera.look[2];this._up1[0]=camera.up[0];this._up1[1]=camera.up[1];this._up1[2]=camera.up[2];this._orthoScale1=camera.ortho.scale;this._orthoScale2=params.orthoScale||this._orthoScale1;let aabb;let eye;let look;let up;let componentId;if(params.aabb){aabb=params.aabb}else if(params.length===6){aabb=params}else if((params.eye&&params.look)||params.up){eye=params.eye;look=params.look;up=params.up}else if(params.eye){eye=params.eye}else if(params.look){look=params.look}else{let component=params;if(utils.isNumeric(component)||utils.isString(component)){componentId=component;component=this.scene.components[componentId];if(!component){this.error("Component not found: "+utils.inQuotes(componentId));if(callback){if(scope){callback.call(scope)}else{callback()}}
return}}
aabb=component.aabb||this.scene.aabb}
const poi=params.poi;if(aabb){if(aabb[3]<aabb[0]||aabb[4]<aabb[1]||aabb[5]<aabb[2]){return}
if(aabb[3]===aabb[0]&&aabb[4]===aabb[1]&&aabb[5]===aabb[2]){return}
if(params.showAABB!==!1){this._aabbHelper.geometry.targetAABB=aabb}
aabb=aabb.slice();const aabbCenter=math.getAABB3Center(aabb);this._look2=poi||aabbCenter;const eyeLookVec=math.subVec3(this._eye1,this._look1,tempVec3$2);const eyeLookVecNorm=math.normalizeVec3(eyeLookVec);const diag=poi?math.getAABB3DiagPoint(aabb,poi):math.getAABB3Diag(aabb);const fitFOV=params.fitFOV||this._fitFOV;const sca=Math.abs(diag/Math.tan(fitFOV*math.DEGTORAD));this._orthoScale2=diag*1.1;this._eye2[0]=this._look2[0]+(eyeLookVecNorm[0]*sca);this._eye2[1]=this._look2[1]+(eyeLookVecNorm[1]*sca);this._eye2[2]=this._look2[2]+(eyeLookVecNorm[2]*sca);this._up2[0]=this._up1[0];this._up2[1]=this._up1[1];this._up2[2]=this._up1[2];this._flyEyeLookUp=!1}else if(eye||look||up){this._flyEyeLookUp=!!eye&&!!look&&!!up;this._flyingEye=!!eye&&!look;this._flyingLook=!!look&&!eye;if(look){this._look2[0]=look[0];this._look2[1]=look[1];this._look2[2]=look[2]}
if(eye){this._eye2[0]=eye[0];this._eye2[1]=eye[1];this._eye2[2]=eye[2]}
if(up){this._up2[0]=up[0];this._up2[1]=up[1];this._up2[2]=up[2]}}
this.fire("started",params,!0);this._time1=Date.now();this._time2=this._time1+(params.duration?params.duration*1000:this._duration);this._flying=!0;tasks.scheduleTask(this._update,this)}
jumpTo(params){this._jumpTo(params)}
_jumpTo(params){if(this._flying){this.stop()}
const camera=this.scene.camera;var aabb;var componentId;var newEye;var newLook;var newUp;if(params.aabb){aabb=params.aabb}else if(params.length===6){aabb=params}else if(params.eye||params.look||params.up){newEye=params.eye;newLook=params.look;newUp=params.up}else{let component=params;if(utils.isNumeric(component)||utils.isString(component)){componentId=component;component=this.scene.components[componentId];if(!component){this.error("Component not found: "+utils.inQuotes(componentId));return}}
aabb=component.aabb||this.scene.aabb}
const poi=params.poi;if(aabb){if(aabb[3]<=aabb[0]||aabb[4]<=aabb[1]||aabb[5]<=aabb[2]){return}
var diag=poi?math.getAABB3DiagPoint(aabb,poi):math.getAABB3Diag(aabb);newLook=poi||math.getAABB3Center(aabb,newLook);if(this._trail){math.subVec3(camera.look,newLook,newLookEyeVec)}else{math.subVec3(camera.eye,camera.look,newLookEyeVec)}
math.normalizeVec3(newLookEyeVec);let dist;const fit=(params.fit!==undefined)?params.fit:this._fit;if(fit){dist=Math.abs((diag)/Math.tan((params.fitFOV||this._fitFOV)*math.DEGTORAD))}else{dist=math.lenVec3(math.subVec3(camera.eye,camera.look,tempVec3$2))}
math.mulVec3Scalar(newLookEyeVec,dist);camera.eye=math.addVec3(newLook,newLookEyeVec,tempVec3$2);camera.look=newLook}else if(newEye||newLook||newUp){if(newEye){camera.eye=newEye}
if(newLook){camera.look=newLook}
if(newUp){camera.up=newUp}}}
_update(){if(!this._flying){return}
const time=Date.now();let t=(time-this._time1)/(this._time2-this._time1);const stopping=(t>=1);if(t>1){t=1}
t=this.easing?this._ease(t,0,1,1):t;const camera=this.scene.camera;if(this._flyingEye||this._flyingLook){if(this._flyingEye){math.subVec3(camera.eye,camera.look,newLookEyeVec);camera.eye=math.lerpVec3(t,0,1,this._eye1,this._eye2,newEye);camera.look=math.subVec3(newEye,newLookEyeVec,newLook)}else if(this._flyingLook){camera.look=math.lerpVec3(t,0,1,this._look1,this._look2,newLook);camera.up=math.lerpVec3(t,0,1,this._up1,this._up2,newUp)}}else if(this._flyEyeLookUp){camera.eye=math.lerpVec3(t,0,1,this._eye1,this._eye2,newEye);camera.look=math.lerpVec3(t,0,1,this._look1,this._look2,newLook);camera.up=math.lerpVec3(t,0,1,this._up1,this._up2,newUp)}else{math.lerpVec3(t,0,1,this._look1,this._look2,newLook);let dist;if(this._trail){math.subVec3(newLook,camera.look,newLookEyeVec)}else{math.subVec3(camera.eye,camera.look,newLookEyeVec)}
math.normalizeVec3(newLookEyeVec);math.lerpVec3(t,0,1,this._eye1,this._eye2,newEye);math.subVec3(newEye,newLook,lookEyeVec);dist=math.lenVec3(lookEyeVec);math.mulVec3Scalar(newLookEyeVec,dist);camera.eye=math.addVec3(newLook,newLookEyeVec,newEye);camera.look=newLook}
this.scene.camera.ortho.scale=this._orthoScale1+(t*(this._orthoScale2-this._orthoScale1));if(stopping){this.stop();return}
tasks.scheduleTask(this._update,this)}
_ease(t,b,c,d){t/=d;return-c*t*(t-2)+b}
stop(){if(!this._flying){return}
this._aabbHelper.visible=!1;this._flying=!1;this._time1=null;this._time2=null;const callback=this._callback;if(callback){this._callback=null;if(this._callbackScope){callback.call(this._callbackScope)}else{callback()}}
this.fire("stopped",!0,!0)}
cancel(){if(!this._flying){return}
this._aabbHelper.visible=!1;this._flying=!1;this._time1=null;this._time2=null;if(this._callback){this._callback=null}
this.fire("canceled",!0,!0)}
set duration(value){this._duration=value?(value*1000.0):500;this.stop()}
get duration(){return this._duration/1000.0}
set fit(value){this._fit=value!==!1}
get fit(){return this._fit}
set fitFOV(value){this._fitFOV=value||45}
get fitFOV(){return this._fitFOV}
set trail(value){this._trail=!!value}
get trail(){return this._trail}}
componentClasses[type$22]=CameraFlightAnimation;const type$23="xeogl.Clip";class Clip extends Component{get type(){return type$23}
init(cfg){super.init(cfg);this._state=new State({active:!0,pos:new Float32Array(3),dir:new Float32Array(3)});this.active=cfg.active;this.pos=cfg.pos;this.dir=cfg.dir;this.scene._clipCreated(this)}
set active(value){this._state.active=value!==!1;this._renderer.imageDirty();this.fire("active",this._state.active)}
get active(){return this._state.active}
set pos(value){this._state.pos.set(value||[0,0,0]);this._renderer.imageDirty();this.fire("pos",this._state.pos)}
get pos(){return this._state.pos}
set dir(value){this._state.dir.set(value||[0,0,-1]);this._renderer.imageDirty();this.fire("dir",this._state.dir)}
get dir(){return this._state.dir}
destroy(){this._state.destroy();this.scene._clipDestroyed(this);super.destroy()}}
componentClasses[type$23]=Clip;const type$24="xeogl.CameraControl";class CameraControl extends Component{get type(){return type$24}
init(cfg){super.init(cfg);const self=this;this._boundaryHelper=new Mesh(this,{geometry:new AABBGeometry(this),material:new PhongMaterial(this,{diffuse:[0,0,0],ambient:[0,0,0],specular:[0,0,0],emissive:[1.0,1.0,0.6],lineWidth:4}),visible:!1,collidable:!1});this._pivoter=new(function(){const scene=self.scene;const camera=scene.camera;const canvas=scene.canvas;const pivotPoint=new Float32Array(3);let cameraOffset;let azimuth=0;let polar=0;let radius=0;let pivoting=!1;const spot=document.createElement("div");spot.innerText=" ";spot.style.color="#ffffff";spot.style.position="absolute";spot.style.width="25px";spot.style.height="25px";spot.style.left="0px";spot.style.top="0px";spot.style["border-radius"]="15px";spot.style.border="2px solid #ffffff";spot.style.background="black";spot.style.visibility="hidden";spot.style["box-shadow"]="5px 5px 15px 1px #000000";spot.style["z-index"]=0;spot.style["pointer-events"]="none";document.body.appendChild(spot);(function(){const viewPos=math.vec4();const projPos=math.vec4();const canvasPos=math.vec2();let distDirty=!0;camera.on("viewMatrix",function(){distDirty=!0});camera.on("projMatrix",function(){distDirty=!0});scene.on("tick",function(){if(pivoting&&distDirty){math.transformPoint3(camera.viewMatrix,pivotPoint,viewPos);viewPos[3]=1;math.transformPoint4(camera.projMatrix,viewPos,projPos);const aabb=canvas.boundary;canvasPos[0]=Math.floor((1+projPos[0]/projPos[3])*aabb[2]/2);canvasPos[1]=Math.floor((1-projPos[1]/projPos[3])*aabb[3]/2);const canvasElem=canvas.canvas;const rect=canvasElem.getBoundingClientRect();spot.style.left=(Math.floor(rect.left+canvasPos[0])-12)+"px";spot.style.top=(Math.floor(rect.top+canvasPos[1])-12)+"px";spot.style.visibility="visible";distDirty=!1}})})();this.startPivot=function(worldPos){if(worldPos){pivotPoint.set(worldPos)}
let lookat=math.lookAtMat4v(camera.eye,camera.look,camera.worldUp);cameraOffset=math.transformPoint3(lookat,pivotPoint);cameraOffset[2]+=math.distVec3(camera.eye,pivotPoint);lookat=math.inverseMat4(lookat);const offset=math.transformVec3(lookat,cameraOffset);const diff=math.vec3();math.subVec3(camera.eye,pivotPoint,diff);math.addVec3(diff,offset);if(camera.worldUp[2]===1){const t=diff[1];diff[1]=diff[2];diff[2]=t}
radius=math.lenVec3(diff);polar=Math.acos(diff[1]/radius);azimuth=Math.atan2(diff[0],diff[2]);pivoting=!0};this.getPivoting=function(){return pivoting};this.getPivotPos=function(){return pivotPoint};this.continuePivot=function(yawInc,pitchInc){if(!pivoting){return}
if(yawInc===0&&pitchInc===0){return}
if(camera.worldUp[2]===1){dx=-dx}
var dx=-yawInc;const dy=-pitchInc;azimuth+=-dx*.01;polar+=dy*.01;polar=math.clamp(polar,.001,Math.PI-.001);const pos=[radius*Math.sin(polar)*Math.sin(azimuth),radius*Math.cos(polar),radius*Math.sin(polar)*Math.cos(azimuth)];if(camera.worldUp[2]===1){const t=pos[1];pos[1]=pos[2];pos[2]=t}
const eyeLookLen=math.lenVec3(math.subVec3(camera.look,camera.eye,math.vec3()));math.addVec3(pos,pivotPoint);let lookat=math.lookAtMat4v(pos,pivotPoint,camera.worldUp);lookat=math.inverseMat4(lookat);const offset=math.transformVec3(lookat,cameraOffset);lookat[12]-=offset[0];lookat[13]-=offset[1];lookat[14]-=offset[2];const zAxis=[lookat[8],lookat[9],lookat[10]];camera.eye=[lookat[12],lookat[13],lookat[14]];math.subVec3(camera.eye,math.mulVec3Scalar(zAxis,eyeLookLen),camera.look);camera.up=[lookat[4],lookat[5],lookat[6]];spot.style.visibility="visible"};this.endPivot=function(){spot.style.visibility="hidden";pivoting=!1}})();this._cameraFlight=new CameraFlightAnimation(this,{duration:0.5});this.firstPerson=cfg.firstPerson;this.walking=cfg.walking;this.keyboardLayout=cfg.keyboardLayout;this.doublePickFlyTo=cfg.doublePickFlyTo;this.active=cfg.active;this.pivoting=cfg.pivoting;this.panToPointer=cfg.panToPointer;this.panToPivot=cfg.panToPivot;this.inertia=cfg.inertia;this._initEvents()}
set active(value){this._active=value!==!1}
get active(){return this._active}
set pivoting(value){this._pivoting=!!value}
get pivoting(){return this._pivoting}
set panToPointer(value){this._panToPointer=!!value;if(this._panToPointer){this._panToPivot=!1}}
get panToPointer(){return this._panToPointer}
set panToPivot(value){this._panToPivot=!!value;if(this._panToPivot){this._panToPointer=!1}}
get panToPivot(){return this._panToPivot}
set firstPerson(value){this._firstPerson=!!value}
get firstPerson(){return this._firstPerson}
set walking(value){this._walking=!!value}
get walking(){return this._walking}
set doublePickFlyTo(value){this._doublePickFlyTo=value!==!1}
get doublePickFlyTo(){return this._doublePickFlyTo}
set inertia(value){this._inertia=value===undefined?0.5:value}
get inertia(){return this._inertia}
set keyboardLayout(value){this._keyboardLayout=value||"qwerty"}
get keyboardLayout(){return this._keyboardLayout}
_initEvents(){const self=this;const scene=this.scene;const input=scene.input;const camera=scene.camera;const canvas=this.scene.canvas.canvas;let over=!1;const mouseOrbitRate=0.4;const mousePanRate=0.4;const mouseZoomRate=0.8;const keyboardOrbitRate=.02;const keyboardPanRate=.02;const keyboardZoomRate=.02;const touchRotateRate=0.3;const touchPanRate=0.2;const touchZoomRate=0.05;canvas.oncontextmenu=function(e){e.preventDefault()};const getCanvasPosFromEvent=function(event,canvasPos){if(!event){event=window.event;canvasPos[0]=event.x;canvasPos[1]=event.y}else{let element=event.target;let totalOffsetLeft=0;let totalOffsetTop=0;while(element.offsetParent){totalOffsetLeft+=element.offsetLeft;totalOffsetTop+=element.offsetTop;element=element.offsetParent}
canvasPos[0]=event.pageX-totalOffsetLeft;canvasPos[1]=event.pageY-totalOffsetTop}
return canvasPos};const pickCursorPos=[0,0];let needPickMesh=!1;let needPickSurface=!1;let lastPickedMeshId;let hit;let pickedSurface=!1;function updatePick(){if(!needPickMesh&&!needPickSurface){return}
pickedSurface=!1;if(needPickSurface||self.hasSubs("hoverSurface")){hit=scene.pick({pickSurface:!0,canvasPos:pickCursorPos})}else{hit=scene.pick({canvasPos:pickCursorPos})}
if(hit){const pickedMeshId=hit.mesh.id;if(lastPickedMeshId!==pickedMeshId){if(lastPickedMeshId!==undefined){self.fire("hoverOut",{mesh:scene.meshes[lastPickedMeshId]})}
self.fire("hoverEnter",hit);lastPickedMeshId=pickedMeshId}
self.fire("hover",hit);if(hit.worldPos){pickedSurface=!0;self.fire("hoverSurface",hit)}}else{if(lastPickedMeshId!==undefined){self.fire("hoverOut",{mesh:scene.meshes[lastPickedMeshId]});lastPickedMeshId=undefined}
self.fire("hoverOff",{canvasPos:pickCursorPos})}
needPickMesh=!1;needPickSurface=!1}
scene.on("tick",updatePick);(function(){let rotateVx=0;let rotateVy=0;let panVx=0;let panVy=0;let panVz=0;let vZoom=0;const mousePos=math.vec2();let panToMouse=!1;let ctrlDown=!1;let altDown=!1;let shiftDown=!1;const keyDown={};const EPSILON=0.001;const getEyeLookDist=(function(){const vec=new Float32Array(3);return function(){return math.lenVec3(math.subVec3(camera.look,camera.eye,vec))}})();const getInverseProjectMat=(function(){let projMatDirty=!0;camera.on("projMatrix",function(){projMatDirty=!0});const inverseProjectMat=math.mat4();return function(){if(projMatDirty){math.inverseMat4(camera.projMatrix,inverseProjectMat)}
return inverseProjectMat}})();const getTransposedProjectMat=(function(){let projMatDirty=!0;camera.on("projMatrix",function(){projMatDirty=!0});const transposedProjectMat=math.mat4();return function(){if(projMatDirty){math.transposeMat4(camera.projMatrix,transposedProjectMat)}
return transposedProjectMat}})();const getInverseViewMat=(function(){let viewMatDirty=!0;camera.on("viewMatrix",function(){viewMatDirty=!0});const inverseViewMat=math.mat4();return function(){if(viewMatDirty){math.inverseMat4(camera.viewMatrix,inverseViewMat)}
return inverseViewMat}})();const getSceneDiagSize=(function(){let sceneSizeDirty=!0;let diag=1;scene.on("boundary",function(){sceneSizeDirty=!0});return function(){if(sceneSizeDirty){diag=math.getAABB3Diag(scene.aabb)}
return diag}})();const panToMousePos=(function(){const cp=math.vec4();const viewPos=math.vec4();const worldPos=math.vec4();const eyeCursorVec=math.vec3();const unproject=function(inverseProjMat,inverseViewMat,mousePos,z,viewPos,worldPos){const canvas=scene.canvas.canvas;const halfCanvasWidth=canvas.offsetWidth/2.0;const halfCanvasHeight=canvas.offsetHeight/2.0;cp[0]=(mousePos[0]-halfCanvasWidth)/halfCanvasWidth;cp[1]=(mousePos[1]-halfCanvasHeight)/halfCanvasHeight;cp[2]=z;cp[3]=1.0;math.mulMat4v4(inverseProjMat,cp,viewPos);math.mulVec3Scalar(viewPos,1.0/viewPos[3]);viewPos[3]=1.0;viewPos[1]*=-1;math.mulMat4v4(inverseViewMat,viewPos,worldPos)};return function(mousePos,factor){const lastHoverDistance=0;const inverseProjMat=getInverseProjectMat();const inverseViewMat=getInverseViewMat();const transposedProjectMat=getTransposedProjectMat();const Pt3=transposedProjectMat.subarray(8,12);const Pt4=transposedProjectMat.subarray(12);const D=[0,0,-(lastHoverDistance||getSceneDiagSize()),1];const Z=math.dotVec4(D,Pt3)/math.dotVec4(D,Pt4);unproject(inverseProjMat,inverseViewMat,mousePos,Z,viewPos,worldPos);math.subVec3(worldPos,camera.eye,eyeCursorVec);math.normalizeVec3(eyeCursorVec);const px=eyeCursorVec[0]*factor;const py=eyeCursorVec[1]*factor;const pz=eyeCursorVec[2]*factor;const eye=camera.eye;const look=camera.look;camera.eye=[eye[0]+px,eye[1]+py,eye[2]+pz];camera.look=[look[0]+px,look[1]+py,look[2]+pz]}})();const panToWorldPos=(function(){const eyeCursorVec=math.vec3();return function(worldPos,factor){math.subVec3(worldPos,camera.eye,eyeCursorVec);math.normalizeVec3(eyeCursorVec);const px=eyeCursorVec[0]*factor;const py=eyeCursorVec[1]*factor;const pz=eyeCursorVec[2]*factor;const eye=camera.eye;const look=camera.look;camera.eye=[eye[0]+px,eye[1]+py,eye[2]+pz];camera.look=[look[0]+px,look[1]+py,look[2]+pz]}})();scene.on("tick",function(){const cameraInertia=self._inertia;if(Math.abs(rotateVx)<EPSILON){rotateVx=0}
if(Math.abs(rotateVy)<EPSILON){rotateVy=0}
if(rotateVy!==0||rotateVx!==0){if(self._pivoter.getPivoting()){self._pivoter.continuePivot(rotateVy,rotateVx)}else{if(rotateVx!==0){if(self._firstPerson){camera.pitch(-rotateVx)}else{camera.orbitPitch(rotateVx)}}
if(rotateVy!==0){if(self._firstPerson){camera.yaw(rotateVy)}else{camera.orbitYaw(rotateVy)}}}
rotateVx*=cameraInertia;rotateVy*=cameraInertia}
if(Math.abs(panVx)<EPSILON){panVx=0}
if(Math.abs(panVy)<EPSILON){panVy=0}
if(Math.abs(panVz)<EPSILON){panVz=0}
if(panVx!==0||panVy!==0||panVz!==0){const f=getEyeLookDist()/80;if(self._walking){var y=camera.eye[1];camera.pan([panVx*f,panVy*f,panVz*f]);var eye=camera.eye;eye[1]=y;camera.eye=eye}else{camera.pan([panVx*f,panVy*f,panVz*f])}}
panVx*=cameraInertia;panVy*=cameraInertia;panVz*=cameraInertia;if(Math.abs(vZoom)<EPSILON){vZoom=0}
if(vZoom!==0){if(self._firstPerson){var y;if(self._walking){y=camera.eye[1]}
if(panToMouse){panToMousePos(mousePos,-vZoom*2)}else{camera.pan([0,0,vZoom])}
if(self._walking){var eye=camera.eye;eye[1]=y;camera.eye=eye}}else{if(self._panToPointer){updatePick();if(pickedSurface){panToWorldPos(hit.worldPos,-vZoom)}else{camera.zoom(vZoom)}}else if(self._panToPivot){panToWorldPos(self._pivoter.getPivotPos(),-vZoom)}else{camera.zoom(vZoom)}
camera.ortho.scale=camera.ortho.scale+vZoom}
vZoom*=cameraInertia}});function getZoomRate(){const aabb=scene.aabb;const xsize=aabb[3]-aabb[0];const ysize=aabb[4]-aabb[1];const zsize=aabb[5]-aabb[2];let max=(xsize>ysize?xsize:ysize);max=(zsize>max?zsize:max);return max/30}
document.addEventListener("keyDown",function(e){if(!self._active){return}
if(e.target.tagName!=="INPUT"&&e.target.tagName!=="TEXTAREA"){ctrlDown=e.ctrlKey||e.keyCode===17||e.metaKey;altDown=e.altKey||e.keyCode===18;shiftDown=e.keyCode===16;keyDown[e.keyCode]=!0}},!0);document.addEventListener("keyup",function(e){if(!self._active){return}
if(e.target.tagName!=="INPUT"&&e.target.tagName!=="TEXTAREA"){if(e.ctrlKey||e.keyCode===17){ctrlDown=!1}
if(e.altKey||e.keyCode===18){altDown=!1}
if(e.keyCode===16){shiftDown=!1}
keyDown[e.keyCode]=!1}});(function(){let lastX;let lastY;let xDelta=0;let yDelta=0;let down=!1;let mouseDownRight;canvas.addEventListener("mousedown",function(e){if(!self._active){return}
over=!0;switch(e.which){case 1:down=!0;xDelta=0;yDelta=0;getCanvasPosFromEvent(e,mousePos);lastX=mousePos[0];lastY=mousePos[1];break;case 2:break;case 3:mouseDownRight=!0;down=!0;xDelta=0;yDelta=0;getCanvasPosFromEvent(e,mousePos);lastX=mousePos[0];lastY=mousePos[1];break;break;default:break}});canvas.addEventListener("mouseup",function(e){if(!self._active){return}
switch(e.which){case 1:break;case 2:break;case 3:mouseDownRight=!1;break;default:break}
down=!1;xDelta=0;yDelta=0});document.addEventListener("mouseup",function(e){if(!self._active){return}
switch(e.which){case 1:break;case 2:break;case 3:mouseDownRight=!1;break;default:break}
down=!1;xDelta=0;yDelta=0});canvas.addEventListener("mouseenter",function(){if(!self._active){return}
over=!0;xDelta=0;yDelta=0});canvas.addEventListener("mouseleave",function(){if(!self._active){return}
over=!1;xDelta=0;yDelta=0});canvas.addEventListener("mousemove",function(e){if(!self._active){return}
if(!over){return}
getCanvasPosFromEvent(e,mousePos);panToMouse=!0;if(!down){return}
const x=mousePos[0];const y=mousePos[1];xDelta+=(x-lastX)*mouseOrbitRate;yDelta+=(y-lastY)*mouseOrbitRate;lastX=x;lastY=y});scene.on("tick",function(){if(!self._active){return}
if(Math.abs(xDelta)===0&&Math.abs(yDelta)===0){return}
const panning=shiftDown||mouseDownRight;if(panning){panVx=xDelta*mousePanRate;panVy=yDelta*mousePanRate}else{rotateVy=-xDelta*mouseOrbitRate;rotateVx=yDelta*mouseOrbitRate}
xDelta=0;yDelta=0});canvas.addEventListener("wheel",function(e){if(!self._active){return}
if(self._panToPointer){needPickSurface=!0}
const delta=Math.max(-1,Math.min(1,-e.deltaY*40));if(delta===0){return}
const d=delta/Math.abs(delta);vZoom=-d*getZoomRate()*mouseZoomRate;e.preventDefault()});scene.on("tick",function(e){if(!self._active){return}
if(!over){return}
const elapsed=e.deltaTime;if(!self.ctrlDown&&!self.altDown){const wkey=input.keyDown[input.KEY_ADD];const skey=input.keyDown[input.KEY_SUBTRACT];if(wkey||skey){if(skey){vZoom=elapsed*getZoomRate()*keyboardZoomRate}else if(wkey){vZoom=-elapsed*getZoomRate()*keyboardZoomRate}}}});(function(){scene.on("tick",function(e){if(!self._active){return}
if(!over){return}
const elapsed=e.deltaTime;let front,back,left,right,up,down;if(self._keyboardLayout=='azerty'){front=input.keyDown[input.KEY_Z];back=input.keyDown[input.KEY_S];left=input.keyDown[input.KEY_Q];right=input.keyDown[input.KEY_D];up=input.keyDown[input.KEY_W];down=input.keyDown[input.KEY_X]}else{front=input.keyDown[input.KEY_W];back=input.keyDown[input.KEY_S];left=input.keyDown[input.KEY_A];right=input.keyDown[input.KEY_D];up=input.keyDown[input.KEY_Z];down=input.keyDown[input.KEY_X]}
if(front||back||left||right||up||down){if(down){panVy+=elapsed*keyboardPanRate}else if(up){panVy-=-elapsed*keyboardPanRate}
if(right){panVx+=-elapsed*keyboardPanRate}else if(left){panVx=elapsed*keyboardPanRate}
if(back){panVz=elapsed*keyboardPanRate}else if(front){panVz=-elapsed*keyboardPanRate}}})})()})();(function(){const tapStartPos=new Float32Array(2);const lastTouches=[];let numTouches=0;const touch0Vec=new Float32Array(2);const touch1Vec=new Float32Array(2);const MODE_CHANGE_TIMEOUT=50;const MODE_NONE=0;const MODE_ROTATE=1;const MODE_PAN=1<<1;const MODE_ZOOM=1<<2;let currentMode=MODE_NONE;let transitionTime=Date.now();function checkMode(mode){const currentTime=Date.now();if(currentMode===MODE_NONE){currentMode=mode;return!0}
if(currentMode===mode){return currentTime-transitionTime>MODE_CHANGE_TIMEOUT}
currentMode=mode;transitionTime=currentTime;return!1}
canvas.addEventListener("touchstart",function(event){if(!self._active){return}
const touches=event.touches;const changedTouches=event.changedTouches;if(touches.length===1&&changedTouches.length===1){tapStartPos[0]=touches[0].pageX;tapStartPos[1]=touches[0].pageY}else{}
while(lastTouches.length<touches.length){lastTouches.push(new Float32Array(2))}
for(let i=0,len=touches.length;i<len;++i){lastTouches[i][0]=touches[i].pageX;lastTouches[i][1]=touches[i].pageY}
currentMode=MODE_NONE;numTouches=touches.length;event.stopPropagation()},{passive:!0});canvas.addEventListener("touchmove",function(event){if(!self._active){return}
const touches=event.touches;if(numTouches===1){var touch0=touches[0];if(checkMode(MODE_ROTATE)){const deltaX=touch0.pageX-lastTouches[0][0];const deltaY=touch0.pageY-lastTouches[0][1];const rotateX=deltaX*touchRotateRate;const rotateY=deltaY*touchRotateRate;rotateVx=rotateY;rotateVy=-rotateX}}else if(numTouches===2){var touch0=touches[0];const touch1=touches[1];math.subVec2([touch0.pageX,touch0.pageY],lastTouches[0],touch0Vec);math.subVec2([touch1.pageX,touch1.pageY],lastTouches[1],touch1Vec);const panning=math.dotVec2(touch0Vec,touch1Vec)>0;if(panning&&checkMode(MODE_PAN)){math.subVec2([touch0.pageX,touch0.pageY],lastTouches[0],touch0Vec);panVx=touch0Vec[0]*touchPanRate;panVy=touch0Vec[1]*touchPanRate}
if(!panning&&checkMode(MODE_ZOOM)){const d1=math.distVec2([touch0.pageX,touch0.pageY],[touch1.pageX,touch1.pageY]);const d2=math.distVec2(lastTouches[0],lastTouches[1]);vZoom=(d2-d1)*getZoomRate()*touchZoomRate}}
for(let i=0;i<numTouches;++i){lastTouches[i][0]=touches[i].pageX;lastTouches[i][1]=touches[i].pageY}
event.stopPropagation()},{passive:!0})})();(function(){scene.on("tick",function(e){if(!self._active){return}
if(!over){return}
const elapsed=e.deltaTime;const left=input.keyDown[input.KEY_LEFT_ARROW];const right=input.keyDown[input.KEY_RIGHT_ARROW];const up=input.keyDown[input.KEY_UP_ARROW];const down=input.keyDown[input.KEY_DOWN_ARROW];if(left||right||up||down){if(right){rotateVy+=-elapsed*keyboardOrbitRate}else if(left){rotateVy+=elapsed*keyboardOrbitRate}
if(down){rotateVx+=elapsed*keyboardOrbitRate}else if(up){rotateVx+=-elapsed*keyboardOrbitRate}}})})();(function(){scene.on("tick",function(e){if(!self._active){return}
if(!over){return}
const elapsed=e.deltaTime;let rotateLeft;let rotateRight;if(self._keyboardLayout=='azerty'){rotateLeft=input.keyDown[input.KEY_A];rotateRight=input.keyDown[input.KEY_E]}else{rotateLeft=input.keyDown[input.KEY_Q];rotateRight=input.keyDown[input.KEY_E]}
if(rotateRight||rotateLeft){if(rotateLeft){rotateVy+=elapsed*keyboardOrbitRate}else if(rotateRight){rotateVy+=-elapsed*keyboardOrbitRate}}})})()})();(function(){(function(){canvas.addEventListener("mousemove",function(e){if(!self._active){return}
getCanvasPosFromEvent(e,pickCursorPos);if(self.hasSubs("hover")||self.hasSubs("hoverOut")||self.hasSubs("hoverOff")||self.hasSubs("hoverSurface")){needPickMesh=!0}});let downX;let downY;let downCursorX;let downCursorY;canvas.addEventListener('mousedown',function(e){if(!self._active){return}
downX=e.clientX;downY=e.clientY;downCursorX=pickCursorPos[0];downCursorY=pickCursorPos[1];needPickSurface=self._pivoting;updatePick();if(self._pivoting){if(hit){self._pivoter.startPivot(hit.worldPos)}else{self._pivoter.startPivot()}}});canvas.addEventListener('mouseup',(function(e){let clicks=0;let timeout;return function(e){if(!self._active){return}
self._pivoter.endPivot();if(Math.abs(e.clientX-downX)>3||Math.abs(e.clientY-downY)>3){return}
if(!self._doublePickFlyTo&&!self.hasSubs("doublePicked")&&!self.hasSubs("doublePickedSurface")&&!self.hasSubs("doublePickedNothing")){needPickSurface=!!self.hasSubs("pickedSurface");updatePick();if(hit){self.fire("picked",hit);if(pickedSurface){self.fire("pickedSurface",hit)}}else{self.fire("pickedNothing")}
return}
clicks++;if(clicks==1){timeout=setTimeout(function(){needPickMesh=self._doublePickFlyTo;needPickSurface=needPickMesh||!!self.hasSubs("pickedSurface");pickCursorPos[0]=downCursorX;pickCursorPos[1]=downCursorY;updatePick();if(hit){self.fire("picked",hit);if(pickedSurface){self.fire("pickedSurface",hit)}}else{self.fire("pickedNothing")}
clicks=0},250)}else{clearTimeout(timeout);needPickMesh=self._doublePickFlyTo;needPickSurface=needPickMesh&&!!self.hasSubs("doublePickedSurface");updatePick();if(hit){self.fire("doublePicked",hit);if(pickedSurface){self.fire("doublePickedSurface",hit)}
if(self._doublePickFlyTo){self._flyTo(hit)}}else{self.fire("doublePickedNothing");if(self._doublePickFlyTo){self._flyTo()}}
clicks=0}}})(),!1)})();(function(){const TAP_INTERVAL=150;const DBL_TAP_INTERVAL=325;const TAP_DISTANCE_THRESHOLD=4;let touchStartTime;const activeTouches=[];const tapStartPos=new Float32Array(2);let tapStartTime=-1;let lastTapTime=-1;canvas.addEventListener("touchstart",function(event){if(!self._active){return}
const touches=event.touches;const changedTouches=event.changedTouches;touchStartTime=Date.now();if(touches.length===1&&changedTouches.length===1){tapStartTime=touchStartTime;tapStartPos[0]=touches[0].pageX;tapStartPos[1]=touches[0].pageY}else{tapStartTime=-1}
while(activeTouches.length<touches.length){activeTouches.push(new Float32Array(2))}
for(let i=0,len=touches.length;i<len;++i){activeTouches[i][0]=touches[i].pageX;activeTouches[i][1]=touches[i].pageY}
activeTouches.length=touches.length;event.stopPropagation()},{passive:!0});canvas.addEventListener("touchend",function(event){if(!self._active){return}
const currentTime=Date.now();const touches=event.touches;const changedTouches=event.changedTouches;if(touches.length===0&&changedTouches.length===1){if(tapStartTime>-1&&currentTime-tapStartTime<TAP_INTERVAL){if(lastTapTime>-1&&tapStartTime-lastTapTime<DBL_TAP_INTERVAL){pickCursorPos[0]=Math.round(changedTouches[0].clientX);pickCursorPos[1]=Math.round(changedTouches[0].clientY);needPickMesh=!0;needPickSurface=!!self.hasSubs("pickedSurface");updatePick();if(hit){self.fire("doublePicked",hit);if(pickedSurface){self.fire("doublePickedSurface",hit)}
if(self._doublePickFlyTo){self._flyTo(hit)}}else{self.fire("doublePickedNothing");if(self._doublePickFlyTo){self._flyTo()}}
lastTapTime=-1}else if(math.distVec2(activeTouches[0],tapStartPos)<TAP_DISTANCE_THRESHOLD){pickCursorPos[0]=Math.round(changedTouches[0].clientX);pickCursorPos[1]=Math.round(changedTouches[0].clientY);needPickMesh=!0;needPickSurface=!!self.hasSubs("pickedSurface");updatePick();if(hit){self.fire("picked",hit);if(pickedSurface){self.fire("pickedSurface",hit)}}else{self.fire("pickedNothing")}
lastTapTime=currentTime}
tapStartTime=-1}}
activeTouches.length=touches.length;for(let i=0,len=touches.length;i<len;++i){activeTouches[i][0]=touches[i].pageX;activeTouches[i][1]=touches[i].pageY}
event.stopPropagation()},{passive:!0})})()})();(function(){const KEY_NUM_1=49;const KEY_NUM_2=50;const KEY_NUM_3=51;const KEY_NUM_4=52;const KEY_NUM_5=53;const KEY_NUM_6=54;const center=math.vec3();const tempVec3a=math.vec3();const tempVec3b=math.vec3();const tempVec3c=math.vec3();const cameraTarget={eye:new Float32Array(3),look:new Float32Array(3),up:new Float32Array(3)};document.addEventListener("keydown",function(e){if(!self._active){return}
if(!over){return}
const keyCode=e.keyCode;if(keyCode!==KEY_NUM_1&&keyCode!==KEY_NUM_2&&keyCode!==KEY_NUM_3&&keyCode!==KEY_NUM_4&&keyCode!==KEY_NUM_5&&keyCode!==KEY_NUM_6){return}
const aabb=scene.aabb;const diag=math.getAABB3Diag(aabb);center[0]=aabb[0]+aabb[3]/2.0;center[1]=aabb[1]+aabb[4]/2.0;center[2]=aabb[2]+aabb[5]/2.0;const dist=Math.abs((diag)/Math.tan(self._cameraFlight.fitFOV/2));switch(keyCode){case KEY_NUM_1:cameraTarget.eye.set(math.mulVec3Scalar(camera.worldRight,dist,tempVec3a));cameraTarget.look.set(center);cameraTarget.up.set(camera.worldUp);break;case KEY_NUM_2:cameraTarget.eye.set(math.mulVec3Scalar(camera.worldForward,dist,tempVec3a));cameraTarget.look.set(center);cameraTarget.up.set(camera.worldUp);break;case KEY_NUM_3:cameraTarget.eye.set(math.mulVec3Scalar(camera.worldRight,-dist,tempVec3a));cameraTarget.look.set(center);cameraTarget.up.set(camera.worldUp);break;case KEY_NUM_4:cameraTarget.eye.set(math.mulVec3Scalar(camera.worldForward,-dist,tempVec3a));cameraTarget.look.set(center);cameraTarget.up.set(camera.worldUp);break;case KEY_NUM_5:cameraTarget.eye.set(math.mulVec3Scalar(camera.worldUp,dist,tempVec3a));cameraTarget.look.set(center);cameraTarget.up.set(math.normalizeVec3(math.mulVec3Scalar(camera.worldForward,1,tempVec3b),tempVec3c));break;case KEY_NUM_6:cameraTarget.eye.set(math.mulVec3Scalar(camera.worldUp,-dist,tempVec3a));cameraTarget.look.set(center);cameraTarget.up.set(math.normalizeVec3(math.mulVec3Scalar(camera.worldForward,-1,tempVec3b)));break;default:return}
if(self._cameraFlight.duration>0){self._cameraFlight.flyTo(cameraTarget)}else{self._cameraFlight.jumpTo(cameraTarget)}})})()}
_flyTo(hit){let pos;if(hit&&hit.worldPos){pos=hit.worldPos}
const aabb=hit?hit.mesh.aabb:this.scene.aabb;this._boundaryHelper.geometry.targetAABB=aabb;if(pos){const camera=this.scene.camera;const diff=math.subVec3(camera.eye,camera.look,[]);this._cameraFlight.flyTo({aabb:aabb},this._hideBoundary,this)}else{this._cameraFlight.flyTo({aabb:aabb},this._hideBoundary,this)}}
_hideBoundary(){}
destroy(){this.active=!1;super.destroy()}}
componentClasses[type$24]=CameraControl;const type$25="xeogl.TorusGeometry";class TorusGeometry extends Geometry{get type(){return type$25}
init(cfg){let radius=cfg.radius||1;if(radius<0){this.error("negative radius not allowed - will invert");radius*=-1}
radius*=0.5;let tube=cfg.tube||0.3;if(tube<0){this.error("negative tube not allowed - will invert");tube*=-1}
let radialSegments=cfg.radialSegments||32;if(radialSegments<0){this.error("negative radialSegments not allowed - will invert");radialSegments*=-1}
if(radialSegments<4){radialSegments=4}
let tubeSegments=cfg.tubeSegments||24;if(tubeSegments<0){this.error("negative tubeSegments not allowed - will invert");tubeSegments*=-1}
if(tubeSegments<4){tubeSegments=4}
let arc=cfg.arc||Math.PI*2;if(arc<0){this.warn("negative arc not allowed - will invert");arc*=-1}
if(arc>360){arc=360}
const center=cfg.center;let centerX=center?center[0]:0;let centerY=center?center[1]:0;const centerZ=center?center[2]:0;const positions=[];const normals=[];const uvs=[];const indices=[];let u;let v;let x;let y;let z;let vec;let i;let j;for(j=0;j<=tubeSegments;j++){for(i=0;i<=radialSegments;i++){u=i/radialSegments*arc;v=0.785398+(j/tubeSegments*Math.PI*2);centerX=radius*Math.cos(u);centerY=radius*Math.sin(u);x=(radius+tube*Math.cos(v))*Math.cos(u);y=(radius+tube*Math.cos(v))*Math.sin(u);z=tube*Math.sin(v);positions.push(x+centerX);positions.push(y+centerY);positions.push(z+centerZ);uvs.push(1-(i/radialSegments));uvs.push((j/tubeSegments));vec=math.normalizeVec3(math.subVec3([x,y,z],[centerX,centerY,centerZ],[]),[]);normals.push(vec[0]);normals.push(vec[1]);normals.push(vec[2])}}
let a;let b;let c;let d;for(j=1;j<=tubeSegments;j++){for(i=1;i<=radialSegments;i++){a=(radialSegments+1)*j+i-1;b=(radialSegments+1)*(j-1)+i-1;c=(radialSegments+1)*(j-1)+i;d=(radialSegments+1)*j+i;indices.push(a);indices.push(b);indices.push(c);indices.push(c);indices.push(d);indices.push(a)}}
super.init(utils.apply(cfg,{positions:positions,normals:normals,uv:uvs,indices:indices}))}}
componentClasses[type$25]=TorusGeometry;const type$26="xeogl.SphereGeometry";class SphereGeometry extends Geometry{get type(){return type$26}
init(cfg){const lod=cfg.lod||1;const centerX=cfg.center?cfg.center[0]:0;const centerY=cfg.center?cfg.center[1]:0;const centerZ=cfg.center?cfg.center[2]:0;let radius=cfg.radius||1;if(radius<0){this.warn("negative radius not allowed - will invert");radius*=-1}
let heightSegments=cfg.heightSegments||18;if(heightSegments<0){this.warn("negative heightSegments not allowed - will invert");heightSegments*=-1}
heightSegments=Math.floor(lod*heightSegments);if(heightSegments<18){heightSegments=18}
let widthSegments=cfg.widthSegments||18;if(widthSegments<0){this.warn("negative widthSegments not allowed - will invert");widthSegments*=-1}
widthSegments=Math.floor(lod*widthSegments);if(widthSegments<18){widthSegments=18}
const positions=[];const normals=[];const uvs=[];const indices=[];let i;let j;let theta;let sinTheta;let cosTheta;let phi;let sinPhi;let cosPhi;let x;let y;let z;let u;let v;let first;let second;for(i=0;i<=heightSegments;i++){theta=i*Math.PI/heightSegments;sinTheta=Math.sin(theta);cosTheta=Math.cos(theta);for(j=0;j<=widthSegments;j++){phi=j*2*Math.PI/widthSegments;sinPhi=Math.sin(phi);cosPhi=Math.cos(phi);x=cosPhi*sinTheta;y=cosTheta;z=sinPhi*sinTheta;u=1.0-j/widthSegments;v=i/heightSegments;normals.push(x);normals.push(y);normals.push(z);uvs.push(u);uvs.push(v);positions.push(centerX+radius*x);positions.push(centerY+radius*y);positions.push(centerZ+radius*z)}}
for(i=0;i<heightSegments;i++){for(j=0;j<widthSegments;j++){first=(i*(widthSegments+1))+j;second=first+widthSegments+1;indices.push(first+1);indices.push(second+1);indices.push(second);indices.push(first+1);indices.push(second);indices.push(first)}}
super.init(utils.apply(cfg,{positions:positions,normals:normals,uv:uvs,indices:indices}))}}
componentClasses[type$26]=SphereGeometry;const type$27="xeogl.OBBGeometry";class OBBGeometry extends Geometry{get type(){return type$27}
init(cfg){super.init(utils.apply(cfg,{combined:!0,quantized:!1,primitive:cfg.primitive||"lines",positions:cfg.positions||[1.0,1.0,1.0,1.0,-1.0,1.0,-1.0,-1.0,1.0,-1.0,1.0,1.0,1.0,1.0,-1.0,1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,1.0,-1.0],indices:[0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]}));if(cfg.target){this.target=cfg.target}else if(cfg.targetOBB){this.targetOBB=cfg.targetOBB}}
set target(value){let geometryDirty=!1;const self=this;this._attach({name:"target",type:"xeogl.Component",component:value,sceneDefault:!1,on:{boundary:function(){if(geometryDirty){return}
geometryDirty=!0;tasks.scheduleTask(function(){self._setPositionsFromOBB(self._attached.target.obb);geometryDirty=!1})}},onAttached:function(){self._setPositionsFromOBB(self._attached.target.obb)}})}
get target(){return this._attached.target}
set targetOBB(value){if(!value){return}
if(this._attached.target){this.target=null}
this._setPositionsFromOBB(value)}
_setPositionsFromOBB(obb){this.positions=[obb[0],obb[1],obb[2],obb[4],obb[5],obb[6],obb[8],obb[9],obb[10],obb[12],obb[13],obb[14],obb[16],obb[17],obb[18],obb[20],obb[21],obb[22],obb[24],obb[25],obb[26],obb[28],obb[29],obb[30]]}}
componentClasses[type$27]=OBBGeometry;const type$28="xeogl.CylinderGeometry";class CylinderGeometry extends Geometry{get type(){return type$28}
init(cfg){let radiusTop=cfg.radiusTop||1;if(radiusTop<0){this.error("negative radiusTop not allowed - will invert");radiusTop*=-1}
let radiusBottom=cfg.radiusBottom||1;if(radiusBottom<0){this.error("negative radiusBottom not allowed - will invert");radiusBottom*=-1}
let height=cfg.height||1;if(height<0){this.error("negative height not allowed - will invert");height*=-1}
let radialSegments=cfg.radialSegments||32;if(radialSegments<0){this.error("negative radialSegments not allowed - will invert");radialSegments*=-1}
if(radialSegments<3){radialSegments=3}
let heightSegments=cfg.heightSegments||1;if(heightSegments<0){this.error("negative heightSegments not allowed - will invert");heightSegments*=-1}
if(heightSegments<1){heightSegments=1}
const openEnded=!!cfg.openEnded;let center=cfg.center;const centerX=center?center[0]:0;const centerY=center?center[1]:0;const centerZ=center?center[2]:0;const heightHalf=height/2;const heightLength=height/heightSegments;const radialAngle=(2.0*Math.PI/radialSegments);const radialLength=1.0/radialSegments;const radiusChange=(radiusTop-radiusBottom)/heightSegments;const positions=[];const normals=[];const uvs=[];const indices=[];let h;let i;let x;let z;let currentRadius;let currentHeight;let first;let second;let startIndex;let tu;let tv;const normalY=(90.0-(Math.atan(height/(radiusBottom-radiusTop)))*180/Math.PI)/90.0;for(h=0;h<=heightSegments;h++){currentRadius=radiusTop-h*radiusChange;currentHeight=heightHalf-h*heightLength;for(i=0;i<=radialSegments;i++){x=Math.sin(i*radialAngle);z=Math.cos(i*radialAngle);normals.push(currentRadius*x);normals.push(normalY);normals.push(currentRadius*z);uvs.push((i*radialLength));uvs.push(h*1/heightSegments);positions.push((currentRadius*x)+centerX);positions.push((currentHeight)+centerY);positions.push((currentRadius*z)+centerZ)}}
for(h=0;h<heightSegments;h++){for(i=0;i<=radialSegments;i++){first=h*(radialSegments+1)+i;second=first+radialSegments;indices.push(first);indices.push(second);indices.push(second+1);indices.push(first);indices.push(second+1);indices.push(first+1)}}
if(!openEnded&&radiusTop>0){startIndex=(positions.length/3);normals.push(0.0);normals.push(1.0);normals.push(0.0);uvs.push(0.5);uvs.push(0.5);positions.push(0+centerX);positions.push(heightHalf+centerY);positions.push(0+centerZ);for(i=0;i<=radialSegments;i++){x=Math.sin(i*radialAngle);z=Math.cos(i*radialAngle);tu=(0.5*Math.sin(i*radialAngle))+0.5;tv=(0.5*Math.cos(i*radialAngle))+0.5;normals.push(radiusTop*x);normals.push(1.0);normals.push(radiusTop*z);uvs.push(tu);uvs.push(tv);positions.push((radiusTop*x)+centerX);positions.push((heightHalf)+centerY);positions.push((radiusTop*z)+centerZ)}
for(i=0;i<radialSegments;i++){center=startIndex;first=startIndex+1+i;indices.push(first);indices.push(first+1);indices.push(center)}}
if(!openEnded&&radiusBottom>0){startIndex=(positions.length/3);normals.push(0.0);normals.push(-1.0);normals.push(0.0);uvs.push(0.5);uvs.push(0.5);positions.push(0+centerX);positions.push(0-heightHalf+centerY);positions.push(0+centerZ);for(i=0;i<=radialSegments;i++){x=Math.sin(i*radialAngle);z=Math.cos(i*radialAngle);tu=(0.5*Math.sin(i*radialAngle))+0.5;tv=(0.5*Math.cos(i*radialAngle))+0.5;normals.push(radiusBottom*x);normals.push(-1.0);normals.push(radiusBottom*z);uvs.push(tu);uvs.push(tv);positions.push((radiusBottom*x)+centerX);positions.push((0-heightHalf)+centerY);positions.push((radiusBottom*z)+centerZ)}
for(i=0;i<radialSegments;i++){center=startIndex;first=startIndex+1+i;indices.push(center);indices.push(first+1);indices.push(first)}}
super.init(utils.apply(cfg,{positions:positions,normals:normals,uv:uvs,indices:indices}))}}
componentClasses[type$28]=CylinderGeometry;const type$29="xeogl.PlaneGeometry";class PlaneGeometry extends Geometry{get type(){return type$29}
init(cfg){let xSize=cfg.xSize||1;if(xSize<0){this.error("negative xSize not allowed - will invert");xSize*=-1}
let zSize=cfg.zSize||1;if(zSize<0){this.error("negative zSize not allowed - will invert");zSize*=-1}
let xSegments=cfg.xSegments||1;if(xSegments<0){this.error("negative xSegments not allowed - will invert");xSegments*=-1}
if(xSegments<1){xSegments=1}
let zSegments=cfg.xSegments||1;if(zSegments<0){this.error("negative zSegments not allowed - will invert");zSegments*=-1}
if(zSegments<1){zSegments=1}
const center=cfg.center;const centerX=center?center[0]:0;const centerY=center?center[1]:0;const centerZ=center?center[2]:0;const halfWidth=xSize/2;const halfHeight=zSize/2;const planeX=Math.floor(xSegments)||1;const planeZ=Math.floor(zSegments)||1;const planeX1=planeX+1;const planeZ1=planeZ+1;const segmentWidth=xSize/planeX;const segmentHeight=zSize/planeZ;const positions=new Float32Array(planeX1*planeZ1*3);const normals=new Float32Array(planeX1*planeZ1*3);const uvs=new Float32Array(planeX1*planeZ1*2);let offset=0;let offset2=0;let iz;let ix;let x;let a;let b;let c;let d;for(iz=0;iz<planeZ1;iz++){const z=iz*segmentHeight-halfHeight;for(ix=0;ix<planeX1;ix++){x=ix*segmentWidth-halfWidth;positions[offset]=x+centerX;positions[offset+1]=centerY;positions[offset+2]=-z+centerZ;normals[offset+2]=-1;uvs[offset2]=(planeX-ix)/planeX;uvs[offset2+1]=((planeZ-iz)/planeZ);offset+=3;offset2+=2}}
offset=0;const indices=new((positions.length/3)>65535?Uint32Array:Uint16Array)(planeX*planeZ*6);for(iz=0;iz<planeZ;iz++){for(ix=0;ix<planeX;ix++){a=ix+planeX1*iz;b=ix+planeX1*(iz+1);c=(ix+1)+planeX1*(iz+1);d=(ix+1)+planeX1*iz;indices[offset]=d;indices[offset+1]=b;indices[offset+2]=a;indices[offset+3]=d;indices[offset+4]=c;indices[offset+5]=b;offset+=6}}
super.init(utils.apply(cfg,{positions:positions,normals:normals,uv:uvs,indices:indices}))}}
componentClasses[type$29]=PlaneGeometry;const type$30="xeogl.AmbientLight";class AmbientLight extends Component{get type(){return type$30}
init(cfg){super.init(cfg);this._state={type:"ambient",color:math.vec3([0.7,0.7,0.7]),intensity:1.0};this.color=cfg.color;this.intensity=cfg.intensity;this.scene._lightCreated(this)}
set color(value){this._state.color.set(value||[0.7,0.7,0.8]);this._renderer.setImageForceDirty()}
get color(){return this._state.color}
set intensity(value){this._state.intensity=value!==undefined?value:1.0;this._renderer.setImageForceDirty()}
get intensity(){return this._state.intensity}
destroy(){super.destroy()}}
componentClasses[type$30]=AmbientLight;const type$31="xeogl.PointLight";class PointLight extends Component{get type(){return type$31}
init(cfg){super.init(cfg);const self=this;this._shadowRenderBuf=null;this._shadowViewMatrix=null;this._shadowProjMatrix=null;this._shadowViewMatrixDirty=!0;this._shadowProjMatrixDirty=!0;this._state=new State({type:"point",pos:math.vec3([1.0,1.0,1.0]),color:math.vec3([0.7,0.7,0.8]),intensity:1.0,attenuation:[0.0,0.0,0.0],space:cfg.space||"view",shadow:!1,shadowDirty:!0,getShadowViewMatrix:(function(){const look=math.vec3([0,0,0]);const up=math.vec3([0,1,0]);return function(){if(self._shadowViewMatrixDirty){if(!self._shadowViewMatrix){self._shadowViewMatrix=math.identityMat4()}
math.lookAtMat4v(self._state.pos,look,up,self._shadowViewMatrix);self._shadowViewMatrixDirty=!1}
return self._shadowViewMatrix}})(),getShadowProjMatrix:function(){if(self._shadowProjMatrixDirty){if(!self._shadowProjMatrix){self._shadowProjMatrix=math.identityMat4()}
const canvas=self.scene.canvas.canvas;math.perspectiveMat4(70*(Math.PI/180.0),canvas.clientWidth/canvas.clientHeight,0.1,500.0,self._shadowProjMatrix);self._shadowProjMatrixDirty=!1}
return self._shadowProjMatrix},getShadowRenderBuf:function(){if(!self._shadowRenderBuf){self._shadowRenderBuf=new RenderBuffer(self.scene.canvas.canvas,self.scene.canvas.gl,{size:[1024,1024]})}
return self._shadowRenderBuf}});this.pos=cfg.pos;this.color=cfg.color;this.intensity=cfg.intensity;this.constantAttenuation=cfg.constantAttenuation;this.linearAttenuation=cfg.linearAttenuation;this.quadraticAttenuation=cfg.quadraticAttenuation;this.shadow=cfg.shadow;this.scene._lightCreated(this)}
set pos(value){this._state.pos.set(value||[1.0,1.0,1.0]);this._shadowViewMatrixDirty=!0;this._renderer.imageDirty()}
get pos(){return this._state.pos}
set color(value){this._state.color.set(value||[0.7,0.7,0.8]);this._renderer.imageDirty()}
get color(){return this._state.color}
set intensity(value){value=value!==undefined?value:1.0;this._state.intensity=value;this._renderer.imageDirty()}
get intensity(){return this._state.intensity}
set constantAttenuation(value){this._state.attenuation[0]=value||0.0;this._renderer.imageDirty()}
get constantAttenuation(){return this._state.attenuation[0]}
set linearAttenuation(value){this._state.attenuation[1]=value||0.0;this._renderer.imageDirty()}
get linearAttenuation(){return this._state.attenuation[1]}
set quadraticAttenuation(value){this._state.attenuation[2]=value||0.0;this._renderer.imageDirty()}
get quadraticAttenuation(){return this._state.attenuation[2]}
set shadow(value){value=!!value;if(this._state.shadow===value){return}
this._state.shadow=value;this._shadowViewMatrixDirty=!0;this._renderer.imageDirty()}
get shadow(){return this._state.shadow}
destroy(){super.destroy();this._state.destroy();if(this._shadowRenderBuf){this._shadowRenderBuf.destroy()}
this.scene._lightDestroyed(this)}}
componentClasses[type$31]=PointLight;const type$32="xeogl.SpotLight";class SpotLight extends Component{get type(){return type$32}
init(cfg){super.init(cfg);const self=this;this._shadowRenderBuf=null;this._shadowViewMatrix=null;this._shadowProjMatrix=null;this._shadowViewMatrixDirty=!0;this._shadowProjMatrixDirty=!0;this._state=new State({type:"spot",pos:math.vec3([1.0,1.0,1.0]),dir:math.vec3([0.0,-1.0,0.0]),color:math.vec3([0.7,0.7,0.8]),intensity:1.0,attenuation:[0.0,0.0,0.0],space:cfg.space||"view",shadow:!1,shadowDirty:!0,getShadowViewMatrix:(function(){const look=math.vec3();const up=math.vec3([0,1,0]);return function(){if(self._shadowViewMatrixDirty){if(!self._shadowViewMatrix){self._shadowViewMatrix=math.identityMat4()}
math.addVec3(self._state.pos,self._state.dir,look);math.lookAtMat4v(self._state.pos,look,up,self._shadowViewMatrix);self._shadowViewMatrixDirty=!1}
return self._shadowViewMatrix}})(),getShadowProjMatrix:function(){if(self._shadowProjMatrixDirty){if(!self._shadowProjMatrix){self._shadowProjMatrix=math.identityMat4()}
const canvas=self.scene.canvas.canvas;math.perspectiveMat4(60*(Math.PI/180.0),canvas.clientWidth/canvas.clientHeight,0.1,400.0,self._shadowProjMatrix);self._shadowProjMatrixDirty=!1}
return self._shadowProjMatrix},getShadowRenderBuf:function(){if(!self._shadowRenderBuf){self._shadowRenderBuf=new RenderBuffer(self.scene.canvas.canvas,self.scene.canvas.gl)}
return self._shadowRenderBuf}});this.pos=cfg.pos;this.color=cfg.color;this.intensity=cfg.intensity;this.constantAttenuation=cfg.constantAttenuation;this.linearAttenuation=cfg.linearAttenuation;this.quadraticAttenuation=cfg.quadraticAttenuation;this.shadow=cfg.shadow;this.scene._lightCreated(this)}
set pos(value){this._state.pos.set(value||[1.0,1.0,1.0]);this._shadowViewMatrixDirty=!0;this._renderer.imageDirty()}
get pos(){return this._state.pos}
set dir(value){this._state.dir.set(value||[1.0,1.0,1.0]);this._shadowViewMatrixDirty=!0;this._renderer.imageDirty()}
get dir(){return this._state.dir}
set color(value){this._state.color.set(value||[0.7,0.7,0.8]);this._renderer.imageDirty()}
get color(){return this._state.color}
set intensity(value){value=value!==undefined?value:1.0;this._state.intensity=value;this._renderer.imageDirty()}
get intensity(){return this._state.intensity}
set constantAttenuation(value){this._state.attenuation[0]=value||0.0;this._renderer.imageDirty()}
get constantAttenuation(){return this._state.attenuation[0]}
set linearAttenuation(value){this._state.attenuation[1]=value||0.0;this._renderer.imageDirty()}
get linearAttenuation(){return this._state.attenuation[1]}
set quadraticAttenuation(value){this._state.attenuation[2]=value||0.0;this._renderer.imageDirty()}
get quadraticAttenuation(){return this._state.attenuation[2]}
set shadow(value){value=!!value;if(this._state.shadow===value){return}
this._state.shadow=value;this._shadowViewMatrixDirty=!0;this._renderer.imageDirty();this.fire("dirty",!0)}
get shadow(){return this._state.shadow}
destroy(){super.destroy();this._state.destroy();if(this._shadowRenderBuf){this._shadowRenderBuf.destroy()}
this.scene._lightDestroyed(this)}}
componentClasses[type$32]=SpotLight;const webglEnums={funcAdd:"FUNC_ADD",funcSubtract:"FUNC_SUBTRACT",funcReverseSubtract:"FUNC_REVERSE_SUBTRACT",zero:"ZERO",one:"ONE",srcColor:"SRC_COLOR",oneMinusSrcColor:"ONE_MINUS_SRC_COLOR",dstColor:"DST_COLOR",oneMinusDstColor:"ONE_MINUS_DST_COLOR",srcAlpha:"SRC_ALPHA",oneMinusSrcAlpha:"ONE_MINUS_SRC_ALPHA",dstAlpha:"DST_ALPHA",oneMinusDstAlpha:"ONE_MINUS_DST_ALPHA",contantColor:"CONSTANT_COLOR",oneMinusConstantColor:"ONE_MINUS_CONSTANT_COLOR",constantAlpha:"CONSTANT_ALPHA",oneMinusConstantAlpha:"ONE_MINUS_CONSTANT_ALPHA",srcAlphaSaturate:"SRC_ALPHA_SATURATE",front:"FRONT",back:"BACK",frontAndBack:"FRONT_AND_BACK",never:"NEVER",less:"LESS",equal:"EQUAL",lequal:"LEQUAL",greater:"GREATER",notequal:"NOTEQUAL",gequal:"GEQUAL",always:"ALWAYS",cw:"CW",ccw:"CCW",linear:"LINEAR",nearest:"NEAREST",linearMipmapNearest:"LINEAR_MIPMAP_NEAREST",nearestMipmapNearest:"NEAREST_MIPMAP_NEAREST",nearestMipmapLinear:"NEAREST_MIPMAP_LINEAR",linearMipmapLinear:"LINEAR_MIPMAP_LINEAR",repeat:"REPEAT",clampToEdge:"CLAMP_TO_EDGE",mirroredRepeat:"MIRRORED_REPEAT",alpha:"ALPHA",rgb:"RGB",rgba:"RGBA",luminance:"LUMINANCE",luminanceAlpha:"LUMINANCE_ALPHA",textureBinding2D:"TEXTURE_BINDING_2D",textureBindingCubeMap:"TEXTURE_BINDING_CUBE_MAP",compareRToTexture:"COMPARE_R_TO_TEXTURE",unsignedByte:"UNSIGNED_BYTE"};function getGLEnum(gl,name,defaultVal){if(name===undefined){return defaultVal}
const glName=webglEnums[name];if(glName===undefined){return defaultVal}
return gl[glName]}
const color=new Uint8Array([0,0,0,1]);class Texture2D{constructor(gl,target){this.gl=gl;this.target=target||gl.TEXTURE_2D;this.texture=gl.createTexture();this.setPreloadColor([0,0,0,0]);this.allocated=!0}
setPreloadColor(value){if(!value){color[0]=0;color[1]=0;color[2]=0;color[3]=255}else{color[0]=Math.floor(value[0]*255);color[1]=Math.floor(value[1]*255);color[2]=Math.floor(value[2]*255);color[3]=Math.floor((value[3]!==undefined?value[3]:1)*255)}
const gl=this.gl;gl.bindTexture(this.target,this.texture);gl.texParameteri(this.target,gl.TEXTURE_MAG_FILTER,gl.NEAREST);gl.texParameteri(this.target,gl.TEXTURE_MIN_FILTER,gl.NEAREST);if(this.target===gl.TEXTURE_CUBE_MAP){const faces=[gl.TEXTURE_CUBE_MAP_POSITIVE_X,gl.TEXTURE_CUBE_MAP_NEGATIVE_X,gl.TEXTURE_CUBE_MAP_POSITIVE_Y,gl.TEXTURE_CUBE_MAP_NEGATIVE_Y,gl.TEXTURE_CUBE_MAP_POSITIVE_Z,gl.TEXTURE_CUBE_MAP_NEGATIVE_Z];for(let i=0,len=faces.length;i<len;i++){gl.texImage2D(faces[i],0,gl.RGBA,1,1,0,gl.RGBA,gl.UNSIGNED_BYTE,color)}}else{gl.texImage2D(this.target,0,gl.RGBA,1,1,0,gl.RGBA,gl.UNSIGNED_BYTE,color)}
gl.bindTexture(this.target,null)}
setTarget(target){this.target=target||this.gl.TEXTURE_2D}
setImage(image,props){const gl=this.gl;gl.bindTexture(this.target,this.texture);gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL,props.flipY);if(this.target===gl.TEXTURE_CUBE_MAP){if(utils.isArray(image)){const images=image;const faces=[gl.TEXTURE_CUBE_MAP_POSITIVE_X,gl.TEXTURE_CUBE_MAP_NEGATIVE_X,gl.TEXTURE_CUBE_MAP_POSITIVE_Y,gl.TEXTURE_CUBE_MAP_NEGATIVE_Y,gl.TEXTURE_CUBE_MAP_POSITIVE_Z,gl.TEXTURE_CUBE_MAP_NEGATIVE_Z];for(let i=0,len=faces.length;i<len;i++){gl.texImage2D(faces[i],0,gl.RGBA,gl.RGBA,gl.UNSIGNED_BYTE,images[i])}}}else{gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,gl.RGBA,gl.UNSIGNED_BYTE,image)}
gl.bindTexture(this.target,null)}
setProps(props){const gl=this.gl;gl.bindTexture(this.target,this.texture);if(props.minFilter){const minFilter=getGLEnum(gl,props.minFilter);if(minFilter){gl.texParameteri(this.target,gl.TEXTURE_MIN_FILTER,minFilter);if(minFilter===gl.NEAREST_MIPMAP_NEAREST||minFilter===gl.LINEAR_MIPMAP_NEAREST||minFilter===gl.NEAREST_MIPMAP_LINEAR||minFilter===gl.LINEAR_MIPMAP_LINEAR){gl.generateMipmap(this.target)}}}
if(props.magFilter){const magFilter=getGLEnum(gl,props.magFilter);if(magFilter){gl.texParameteri(this.target,gl.TEXTURE_MAG_FILTER,magFilter)}}
if(props.wrapS){const wrapS=getGLEnum(gl,props.wrapS);if(wrapS){gl.texParameteri(this.target,gl.TEXTURE_WRAP_S,wrapS)}}
if(props.wrapT){const wrapT=getGLEnum(gl,props.wrapT);if(wrapT){gl.texParameteri(this.target,gl.TEXTURE_WRAP_T,wrapT)}}
gl.bindTexture(this.target,null)}
bind(unit){if(!this.allocated){return}
if(this.texture){const gl=this.gl;gl.activeTexture(gl["TEXTURE"+unit]);gl.bindTexture(this.target,this.texture);return!0}
return!1}
unbind(unit){if(!this.allocated){return}
if(this.texture){const gl=this.gl;gl.activeTexture(gl["TEXTURE"+unit]);gl.bindTexture(this.target,null)}}
destroy(){if(!this.allocated){return}
if(this.texture){this.gl.deleteTexture(this.texture);this.texture=null}}}
const type$33="xeogl.CubeTexture";function ensureImageSizePowerOfTwo$1(image){if(!isPowerOfTwo$1(image.width)||!isPowerOfTwo$1(image.height)){const canvas=document.createElement("canvas");canvas.width=nextHighestPowerOfTwo$1(image.width);canvas.height=nextHighestPowerOfTwo$1(image.height);const ctx=canvas.getContext("2d");ctx.drawImage(image,0,0,image.width,image.height,0,0,canvas.width,canvas.height);image=canvas}
return image}
function isPowerOfTwo$1(x){return(x&(x-1))===0}
function nextHighestPowerOfTwo$1(x){--x;for(let i=1;i<32;i<<=1){x=x|x>>i}
return x+1}
class CubeTexture extends Component{get type(){return type$33}
init(cfg){super.init(cfg);const gl=this.scene.canvas.gl;this._state=new State({texture:new Texture2D(gl,gl.TEXTURE_CUBE_MAP),flipY:this._checkFlipY(cfg.minFilter),encoding:this._checkEncoding(cfg.encoding),minFilter:"linearMipmapLinear",magFilter:"linear",wrapS:"clampToEdge",wrapT:"clampToEdge",mipmaps:!0});this._src=cfg.src;this._images=[];this._loadSrc(cfg.src);stats.memory.textures++}
_checkFlipY(value){return!!value}
_checkEncoding(value){value=value||"linear";if(value!=="linear"&&value!=="sRGB"&&value!=="gamma"){this.error("Unsupported value for 'encoding': '"+value+"' - supported values are 'linear', 'sRGB', 'gamma'. Defaulting to 'linear'.");value="linear"}
return value}
_webglContextRestored(){const gl=this.scene.canvas.gl;this._state.texture=null;if(this._src){this._loadSrc(this._src)}}
_loadSrc(src){const self=this;const gl=this.scene.canvas.gl;this._images=[];let loadFailed=!1;let numLoaded=0;for(let i=0;i<src.length;i++){const image=new Image();image.onload=(function(){let _image=image;const index=i;return function(){if(loadFailed){return}
_image=ensureImageSizePowerOfTwo$1(_image);self._images[index]=_image;numLoaded++;if(numLoaded===6){let texture=self._state.texture;if(!texture){texture=new Texture2D(gl,gl.TEXTURE_CUBE_MAP);self._state.texture=texture}
texture.setImage(self._images,self._state);texture.setProps(self._state);self.fire("loaded",self._src)}}})();image.onerror=function(){loadFailed=!0};image.src=src[i]}}
destroy(){super.destroy();if(this._state.texture){this._state.texture.destroy()}
stats.memory.textures--;this._state.destroy()}}
componentClasses[type$33]=CubeTexture;const type$34="xeogl.LightMap";class LightMap extends CubeTexture{get type(){return type$34}
init(cfg){super.init(cfg);this.scene._lightMapCreated(this)}
destroy(){super.destroy();this.scene._lightMapDestroyed(this)}}
componentClasses[type$34]=LightMap;const type$35="xeogl.ReflectionMap";class ReflectionMap extends CubeTexture{get type(){return type$35}
init(cfg){super.init(cfg);this.scene._lightsState.addReflectionMap(this._state);this.scene._reflectionMapCreated(this)}
destroy(){super.destroy();this.scene._reflectionMapDestroyed(this)}}
componentClasses[type$35]=ReflectionMap;const type$36="xeogl.Shadow";class Shadow extends Component{get type(){return type$36}
init(cfg){super.init(cfg);this._state={resolution:math.vec3([1000,1000]),intensity:1.0};this.resolution=cfg.resolution;this.intensity=cfg.intensity}
set resolution(value){this._state.resolution.set(value||[1000.0,1000.0]);this._renderer.imageDirty();this.fire("resolution",this._state.resolution)}
get resolution(){return this._state.resolution}
set intensity(value){value=value!==undefined?value:1.0;this._state.intensity=value;this._renderer.imageDirty();this.fire("intensity",this._state.intensity)}
get intensity(){return this._state.intensity}
destroy(){super.destroy()}}
componentClasses[type$36]=Shadow;const type$37="xeogl.Group";class Group extends xeoglObject{get type(){return type$37}
init(cfg){super.init(cfg)}}
componentClasses[type$37]=Group;const type$38="xeogl.Model";class Model extends Group{get type(){return type$38}
init(cfg){this.components={};this.numComponents=0;this.types={};this.objects={};this.guidObjects={};this.meshes={};this.entities={};this.entityTypes={};this._objectGUIDs=null;this._entityIds=null;super.init(cfg);this.scene._modelCreated(this)}
_addComponent(component){let types;if(utils.isNumeric(component)||utils.isString(component)){component=this.scene.components[component];if(!component){this.warn("Component not found: "+utils.inQuotes(component));return}}else if(utils.isObject(component)){const type=component.type||"xeogl.Component";if(!core.isComponentType(type)){this.error("Not a xeogl component type: "+type);return}
component=new window[type](this.scene,component)}
if(component.scene!==this.scene){this.error("Attempted to add component from different xeogl.Scene: "+utils.inQuotes(component.id));return}
if(this.components[component.id]){return}
if(component.model&&component.model.id!==this.id){component.model._removeComponent(component)}
this.components[component.id]=component;types=this.types[component.type];if(!types){types=this.types[component.type]={}}
types[component.id]=component;if(component.isType("xeogl.Object")){const object=component;this.objects[object.id]=object;if(object.entityType){this.entities[object.id]=object;let objectsOfType=this.entityTypes[object.entityType];if(!objectsOfType){objectsOfType={};this.entityTypes[object.entityType]=objectsOfType}
objectsOfType[object.id]=object;this._entityIds=null;this._entityTypeIds=null}
if(object.guid){this.guidObjects[object.id]=object;this._objectGUIDs=null}
if(component.isType("xeogl.Mesh")){this.meshes[component.id]=component}}
this.numComponents++;component._addedToModel(this);return component}
_removeComponent(component){const id=component.id;delete this.components[id];delete this.meshes[id];delete this.objects[id];if(component.entityType){delete this.entities[id];const objectsOfType=this.entityTypes[component.entityType];if(objectsOfType){delete objectsOfType[id]}
this._entityIds=null;this._entityTypeIds=null}
if(component.guid){delete this.guidObjects[component.guid];this._objectGUIDs=null}}
clear(){for(var id in this.meshes){if(this.meshes.hasOwnProperty(id)){this.meshes[id].destroy()}}
for(var id in this.components){if(this.components.hasOwnProperty(id)){this.components[id].destroy()}}
this.components={};this.numComponents=0;this.types={};this.objects={};this.meshes={};this.entities={}}
get objectGUIDs(){if(!this._objectGUIDs){this._objectGUIDs=Object.keys(this.guidObjects)}
return this._objectGUIDs}
get entityTypeIds(){if(!this._entityTypeIds){this._entityTypeIds=Object.keys(this.entityTypes)}
return this._entityTypeIds}
get entityIds(){if(!this._entityIds){this._entityIds=Object.keys(this.entities)}
return this._entityIds}
destroyAll(){this.clear()}
destroy(){super.destroy();this.clear();this.scene._modelDestroyed(this)}}
componentClasses[type$38]=Model;const type$39="xeogl.LambertMaterial";class LambertMaterial extends Material{get type(){return type$39}
init(cfg){super.init(cfg);this._state=new State({type:"LambertMaterial",ambient:math.vec3([1.0,1.0,1.0]),color:math.vec3([1.0,1.0,1.0]),emissive:math.vec3([0.0,0.0,0.0]),alpha:null,alphaMode:0,lineWidth:null,pointSize:null,backfaces:null,frontface:null,hash:"/lam;"});this.ambient=cfg.ambient;this.color=cfg.color;this.emissive=cfg.emissive;this.alpha=cfg.alpha;this.lineWidth=cfg.lineWidth;this.pointSize=cfg.pointSize;this.backfaces=cfg.backfaces;this.frontface=cfg.frontface}
set ambient(value){let ambient=this._state.ambient;if(!ambient){ambient=this._state.ambient=new Float32Array(3)}else if(value&&ambient[0]===value[0]&&ambient[1]===value[1]&&ambient[2]===value[2]){return}
if(value){ambient[0]=value[0];ambient[1]=value[1];ambient[2]=value[2]}else{ambient[0]=.2;ambient[1]=.2;ambient[2]=.2}
this._renderer.imageDirty()}
get ambient(){return this._state.ambient}
set color(value){let color=this._state.color;if(!color){color=this._state.color=new Float32Array(3)}else if(value&&color[0]===value[0]&&color[1]===value[1]&&color[2]===value[2]){return}
if(value){color[0]=value[0];color[1]=value[1];color[2]=value[2]}else{color[0]=1;color[1]=1;color[2]=1}
this._renderer.imageDirty()}
get color(){return this._state.color}
set emissive(value){let emissive=this._state.emissive;if(!emissive){emissive=this._state.emissive=new Float32Array(3)}else if(value&&emissive[0]===value[0]&&emissive[1]===value[1]&&emissive[2]===value[2]){return}
if(value){emissive[0]=value[0];emissive[1]=value[1];emissive[2]=value[2]}else{emissive[0]=0;emissive[1]=0;emissive[2]=0}
this._renderer.imageDirty()}
get emissive(){return this._state.emissive}
set alpha(value){value=(value!==undefined&&value!==null)?value:1.0;if(this._state.alpha===value){return}
this._state.alpha=value;this._state.alphaMode=value<1.0?2:0;this._renderer.imageDirty()}
get alpha(){return this._state.alpha}
set lineWidth(value){this._state.lineWidth=value||1.0;this._renderer.imageDirty()}
get lineWidth(){return this._state.lineWidth}
set pointSize(value){this._state.pointSize=value||1.0;this._renderer.imageDirty()}
get pointSize(){return this._state.pointSize}
set backfaces(value){value=!!value;if(this._state.backfaces===value){return}
this._state.backfaces=value;this._renderer.imageDirty()}
get backfaces(){return this._state.backfaces}
set frontface(value){value=value!=="cw";if(this._state.frontface===value){return}
this._state.frontface=value;this._renderer.imageDirty()}
get frontface(){return this._state.frontface?"ccw":"cw"}
_getState(){return this._state}
destroy(){super.destroy();this._state.destroy()}}
componentClasses[type$39]=LambertMaterial;const type$40="xeogl.SpecularMaterial";const alphaModes$1={"opaque":0,"mask":1,"blend":2};const alphaModeNames$1=["opaque","mask","blend"];class SpecularMaterial extends Material{get type(){return type$40}
init(cfg){super.init(cfg);this._state=new State({type:"SpecularMaterial",diffuse:math.vec3([1.0,1.0,1.0]),emissive:math.vec3([0.0,0.0,0.0]),specular:math.vec3([1.0,1.0,1.0]),glossiness:null,specularF0:null,alpha:null,alphaMode:null,alphaCutoff:null,lineWidth:null,pointSize:null,backfaces:null,frontface:null,hash:null});this.diffuse=cfg.diffuse;this.specular=cfg.specular;this.glossiness=cfg.glossiness;this.specularF0=cfg.specularF0;this.emissive=cfg.emissive;this.alpha=cfg.alpha;if(cfg.diffuseMap){this._diffuseMap=this._checkComponent("xeogl.Texture",cfg.diffuseMap)}
if(cfg.emissiveMap){this._emissiveMap=this._checkComponent("xeogl.Texture",cfg.emissiveMap)}
if(cfg.specularMap){this._specularMap=this._checkComponent("xeogl.Texture",cfg.specularMap)}
if(cfg.glossinessMap){this._glossinessMap=this._checkComponent("xeogl.Texture",cfg.glossinessMap)}
if(cfg.specularGlossinessMap){this._specularGlossinessMap=this._checkComponent("xeogl.Texture",cfg.specularGlossinessMap)}
if(cfg.occlusionMap){this._occlusionMap=this._checkComponent("xeogl.Texture",cfg.occlusionMap)}
if(cfg.alphaMap){this._alphaMap=this._checkComponent("xeogl.Texture",cfg.alphaMap)}
if(cfg.normalMap){this._normalMap=this._checkComponent("xeogl.Texture",cfg.normalMap)}
this.alphaMode=cfg.alphaMode;this.alphaCutoff=cfg.alphaCutoff;this.backfaces=cfg.backfaces;this.frontface=cfg.frontface;this.lineWidth=cfg.lineWidth;this.pointSize=cfg.pointSize;this._makeHash()}
_makeHash(){const state=this._state;const hash=["/spe"];if(this._diffuseMap){hash.push("/dm");if(this._diffuseMap.hasMatrix){hash.push("/mat")}
hash.push("/"+this._diffuseMap.encoding)}
if(this._emissiveMap){hash.push("/em");if(this._emissiveMap.hasMatrix){hash.push("/mat")}}
if(this._glossinessMap){hash.push("/gm");if(this._glossinessMap.hasMatrix){hash.push("/mat")}}
if(this._specularMap){hash.push("/sm");if(this._specularMap.hasMatrix){hash.push("/mat")}}
if(this._specularGlossinessMap){hash.push("/sgm");if(this._specularGlossinessMap.hasMatrix){hash.push("/mat")}}
if(this._occlusionMap){hash.push("/ocm");if(this._occlusionMap.hasMatrix){hash.push("/mat")}}
if(this._normalMap){hash.push("/nm");if(this._normalMap.hasMatrix){hash.push("/mat")}}
if(this._alphaMap){hash.push("/opm");if(this._alphaMap.hasMatrix){hash.push("/mat")}}
hash.push(";");state.hash=hash.join("")}
set diffuse(value){let diffuse=this._state.diffuse;if(!diffuse){diffuse=this._state.diffuse=new Float32Array(3)}else if(value&&diffuse[0]===value[0]&&diffuse[1]===value[1]&&diffuse[2]===value[2]){return}
if(value){diffuse[0]=value[0];diffuse[1]=value[1];diffuse[2]=value[2]}else{diffuse[0]=1;diffuse[1]=1;diffuse[2]=1}
this._renderer.imageDirty()}
get diffuse(){return this._state.diffuse}
get diffuseMap(){return this._diffuseMap}
set specular(value){let specular=this._state.specular;if(!specular){specular=this._state.specular=new Float32Array(3)}else if(value&&specular[0]===value[0]&&specular[1]===value[1]&&specular[2]===value[2]){return}
if(value){specular[0]=value[0];specular[1]=value[1];specular[2]=value[2]}else{specular[0]=1;specular[1]=1;specular[2]=1}
this._renderer.imageDirty()}
get specular(){return this._state.specular}
get specularMap(){return this._specularMap}
get specularGlossinessMap(){return this._specularGlossinessMap}
set glossiness(value){value=(value!==undefined&&value!==null)?value:1.0;if(this._state.glossiness===value){return}
this._state.glossiness=value;this._renderer.imageDirty()}
get glossiness(){return this._state.glossiness}
get glossinessMap(){return this._glossinessMap}
set specularF0(value){value=(value!==undefined&&value!==null)?value:0.0;if(this._state.specularF0===value){return}
this._state.specularF0=value;this._renderer.imageDirty()}
get specularF0(){return this._state.specularF0}
set emissive(value){let emissive=this._state.emissive;if(!emissive){emissive=this._state.emissive=new Float32Array(3)}else if(value&&emissive[0]===value[0]&&emissive[1]===value[1]&&emissive[2]===value[2]){return}
if(value){emissive[0]=value[0];emissive[1]=value[1];emissive[2]=value[2]}else{emissive[0]=0;emissive[1]=0;emissive[2]=0}
this._renderer.imageDirty()}
get emissive(){return this._state.emissive}
get emissiveMap(){return this._emissiveMap}
set alpha(value){value=(value!==undefined&&value!==null)?value:1.0;if(this._state.alpha===value){return}
this._state.alpha=value;this._renderer.imageDirty()}
get alpha(){return this._state.alpha}
get alphaMap(){return this._alphaMap}
get normalMap(){return this._normalMap}
get occlusionMap(){return this._occlusionMap}
set alphaMode(alphaMode){alphaMode=alphaMode||"opaque";let value=alphaModes$1[alphaMode];if(value===undefined){this.error("Unsupported value for 'alphaMode': "+alphaMode+" defaulting to 'opaque'");value="opaque"}
if(this._state.alphaMode===value){return}
this._state.alphaMode=value;this._renderer.imageDirty()}
get alphaMode(){return alphaModeNames$1[this._state.alphaMode]}
set alphaCutoff(alphaCutoff){if(alphaCutoff===null||alphaCutoff===undefined){alphaCutoff=0.5}
if(this._state.alphaCutoff===alphaCutoff){return}
this._state.alphaCutoff=alphaCutoff}
get alphaCutoff(){return this._state.alphaCutoff}
set backfaces(value){value=!!value;if(this._state.backfaces===value){return}
this._state.backfaces=value;this._renderer.imageDirty()}
get backfaces(){return this._state.backfaces}
set frontface(value){value=value!=="cw";if(this._state.frontface===value){return}
this._state.frontface=value;this._renderer.imageDirty()}
get frontface(){return this._state.frontface?"ccw":"cw"}
set lineWidth(value){this._state.lineWidth=value||1.0;this._renderer.imageDirty()}
get lineWidth(){return this._state.lineWidth}
set pointSize(value){this._state.pointSize=value||1;this._renderer.imageDirty()}
get pointSize(){return this._state.pointSize}
destroy(){super.destroy();this._state.destroy()}}
componentClasses[type$40]=SpecularMaterial;const modes={"opaque":0,"mask":1,"blend":2};const modeNames=["opaque","mask","blend"];const type$41="xeogl.MetallicMaterial";class MetallicMaterial extends Material{get type(){return type$41}
init(cfg){super.init(cfg);this._state=new State({type:"MetallicMaterial",baseColor:math.vec4([1.0,1.0,1.0]),emissive:math.vec4([0.0,0.0,0.0]),metallic:null,roughness:null,specularF0:null,alpha:null,alphaMode:null,alphaCutoff:null,lineWidth:null,pointSize:null,backfaces:null,frontface:null,hash:null});this.baseColor=cfg.baseColor;this.metallic=cfg.metallic;this.roughness=cfg.roughness;this.specularF0=cfg.specularF0;this.emissive=cfg.emissive;this.alpha=cfg.alpha;if(cfg.baseColorMap){this._baseColorMap=this._checkComponent("xeogl.Texture",cfg.baseColorMap)}
if(cfg.metallicMap){this._metallicMap=this._checkComponent("xeogl.Texture",cfg.metallicMap)}
if(cfg.roughnessMap){this._roughnessMap=this._checkComponent("xeogl.Texture",cfg.roughnessMap)}
if(cfg.metallicRoughnessMap){this._metallicRoughnessMap=this._checkComponent("xeogl.Texture",cfg.metallicRoughnessMap)}
if(cfg.emissiveMap){this._emissiveMap=this._checkComponent("xeogl.Texture",cfg.emissiveMap)}
if(cfg.occlusionMap){this._occlusionMap=this._checkComponent("xeogl.Texture",cfg.occlusionMap)}
if(cfg.alphaMap){this._alphaMap=this._checkComponent("xeogl.Texture",cfg.alphaMap)}
if(cfg.normalMap){this._normalMap=this._checkComponent("xeogl.Texture",cfg.normalMap)}
this.alphaMode=cfg.alphaMode;this.alphaCutoff=cfg.alphaCutoff;this.backfaces=cfg.backfaces;this.frontface=cfg.frontface;this.lineWidth=cfg.lineWidth;this.pointSize=cfg.pointSize;this._makeHash()}
_makeHash(){const state=this._state;const hash=["/met"];if(this._baseColorMap){hash.push("/bm");if(this._baseColorMap._state.hasMatrix){hash.push("/mat")}
hash.push("/"+this._baseColorMap._state.encoding)}
if(this._metallicMap){hash.push("/mm");if(this._metallicMap._state.hasMatrix){hash.push("/mat")}}
if(this._roughnessMap){hash.push("/rm");if(this._roughnessMap._state.hasMatrix){hash.push("/mat")}}
if(this._metallicRoughnessMap){hash.push("/mrm");if(this._metallicRoughnessMap._state.hasMatrix){hash.push("/mat")}}
if(this._emissiveMap){hash.push("/em");if(this._emissiveMap._state.hasMatrix){hash.push("/mat")}}
if(this._occlusionMap){hash.push("/ocm");if(this._occlusionMap._state.hasMatrix){hash.push("/mat")}}
if(this._alphaMap){hash.push("/am");if(this._alphaMap._state.hasMatrix){hash.push("/mat")}}
if(this._normalMap){hash.push("/nm");if(this._normalMap._state.hasMatrix){hash.push("/mat")}}
hash.push(";");state.hash=hash.join("")}
set baseColor(value){let baseColor=this._state.baseColor;if(!baseColor){baseColor=this._state.baseColor=new Float32Array(3)}else if(value&&baseColor[0]===value[0]&&baseColor[1]===value[1]&&baseColor[2]===value[2]){return}
if(value){baseColor[0]=value[0];baseColor[1]=value[1];baseColor[2]=value[2]}else{baseColor[0]=1;baseColor[1]=1;baseColor[2]=1}
this._renderer.imageDirty()}
get baseColor(){return this._state.baseColor}
get baseColorMap(){return this._baseColorMap}
set metallic(value){value=(value!==undefined&&value!==null)?value:1.0;if(this._state.metallic===value){return}
this._state.metallic=value;this._renderer.imageDirty()}
get metallic(){return this._state.metallic}
get metallicMap(){return this._attached.metallicMap}
set roughness(value){value=(value!==undefined&&value!==null)?value:1.0;if(this._state.roughness===value){return}
this._state.roughness=value;this._renderer.imageDirty()}
get roughness(){return this._state.roughness}
get roughnessMap(){return this._attached.roughnessMap}
get metallicRoughnessMap(){return this._attached.metallicRoughnessMap}
set specularF0(value){value=(value!==undefined&&value!==null)?value:0.0;if(this._state.specularF0===value){return}
this._state.specularF0=value;this._renderer.imageDirty()}
get specularF0(){return this._state.specularF0}
set emissive(value){let emissive=this._state.emissive;if(!emissive){emissive=this._state.emissive=new Float32Array(3)}else if(value&&emissive[0]===value[0]&&emissive[1]===value[1]&&emissive[2]===value[2]){return}
if(value){emissive[0]=value[0];emissive[1]=value[1];emissive[2]=value[2]}else{emissive[0]=0;emissive[1]=0;emissive[2]=0}
this._renderer.imageDirty()}
get emissive(){return this._state.emissive}
get emissiveMap(){return this._attached.emissiveMap}
get occlusionMap(){return this._attached.occlusionMap}
set alpha(value){value=(value!==undefined&&value!==null)?value:1.0;if(this._state.alpha===value){return}
this._state.alpha=value;this._renderer.imageDirty()}
get alpha(){return this._state.alpha}
get alphaMap(){return this._attached.alphaMap}
get normalMap(){return this._attached.normalMap}
set alphaMode(alphaMode){alphaMode=alphaMode||"opaque";let value=modes[alphaMode];if(value===undefined){this.error("Unsupported value for 'alphaMode': "+alphaMode+" defaulting to 'opaque'");value="opaque"}
if(this._state.alphaMode===value){return}
this._state.alphaMode=value;this._renderer.imageDirty()}
get alphaMode(){return modeNames[this._state.alphaMode]}
set alphaCutoff(alphaCutoff){if(alphaCutoff===null||alphaCutoff===undefined){alphaCutoff=0.5}
if(this._state.alphaCutoff===alphaCutoff){return}
this._state.alphaCutoff=alphaCutoff}
get alphaCutoff(){return this._state.alphaCutoff}
set backfaces(value){value=!!value;if(this._state.backfaces===value){return}
this._state.backfaces=value;this._renderer.imageDirty()}
get backfaces(){return this._state.backfaces}
set frontface(value){value=value!=="cw";if(this._state.frontface===value){return}
this._state.frontface=value;this._renderer.imageDirty()}
get frontface(){return this._state.frontface?"ccw":"cw"}
set lineWidth(value){this._state.lineWidth=value||1.0;this._renderer.imageDirty()}
get lineWidth(){return this._state.lineWidth}
set pointSize(value){this._state.pointSize=value||1.0;this._renderer.imageDirty()}
get pointSize(){return this._state.pointSize}
destroy(){super.destroy();this._state.destroy()}}
componentClasses[type$41]=MetallicMaterial;const type$42="xeogl.Texture";function ensureImageSizePowerOfTwo$2(image){if(!isPowerOfTwo$2(image.width)||!isPowerOfTwo$2(image.height)){const canvas=document.createElement("canvas");canvas.width=nextHighestPowerOfTwo$2(image.width);canvas.height=nextHighestPowerOfTwo$2(image.height);const ctx=canvas.getContext("2d");ctx.drawImage(image,0,0,image.width,image.height,0,0,canvas.width,canvas.height);image=canvas}
return image}
function isPowerOfTwo$2(x){return(x&(x-1))===0}
function nextHighestPowerOfTwo$2(x){--x;for(let i=1;i<32;i<<=1){x=x|x>>i}
return x+1}
class Texture extends Component{get type(){return type$42}
init(cfg){super.init(cfg);this._state=new State({texture:new Texture2D(this.scene.canvas.gl),matrix:math.identityMat4(),hasMatrix:(cfg.translate&&(cfg.translate[0]!==0||cfg.translate[1]!==0))||(!!cfg.rotate)||(cfg.scale&&(cfg.scale[0]!==0||cfg.scale[1]!==0)),minFilter:this._checkMinFilter(cfg.minFilter),magFilter:this._checkMagFilter(cfg.magFilter),wrapS:this._checkWrapS(cfg.wrapS),wrapT:this._checkWrapT(cfg.wrapT),flipY:this._checkFlipY(cfg.flipY),encoding:this._checkEncoding(cfg.encoding)});this._src=null;this._image=null;this._translate=math.vec2([0,0]);this._scale=math.vec2([1,1]);this._rotate=math.vec2([0,0]);this._matrixDirty=!1;this.translate=cfg.translate;this.scale=cfg.scale;this.rotate=cfg.rotate;if(cfg.src){this.src=cfg.src}else if(cfg.image){this.image=cfg.image}
stats.memory.textures++}
_checkMinFilter(value){value=value||"linearMipmapLinear";if(value!=="linear"&&value!=="linearMipmapNearest"&&value!=="linearMipmapLinear"&&value!=="nearestMipmapLinear"&&value!=="nearestMipmapNearest"){this.error("Unsupported value for 'minFilter': '"+value+"' - supported values are 'linear', 'linearMipmapNearest', 'nearestMipmapNearest', "+"'nearestMipmapLinear' and 'linearMipmapLinear'. Defaulting to 'linearMipmapLinear'.");value="linearMipmapLinear"}
return value}
_checkMagFilter(value){value=value||"linear";if(value!=="linear"&&value!=="nearest"){this.error("Unsupported value for 'magFilter': '"+value+"' - supported values are 'linear' and 'nearest'. Defaulting to 'linear'.");value="linear"}
return value}
_checkFilter(value){value=value||"linear";if(value!=="linear"&&value!=="nearest"){this.error("Unsupported value for 'magFilter': '"+value+"' - supported values are 'linear' and 'nearest'. Defaulting to 'linear'.");value="linear"}
return value}
_checkWrapS(value){value=value||"repeat";if(value!=="clampToEdge"&&value!=="mirroredRepeat"&&value!=="repeat"){this.error("Unsupported value for 'wrapS': '"+value+"' - supported values are 'clampToEdge', 'mirroredRepeat' and 'repeat'. Defaulting to 'repeat'.");value="repeat"}
return value}
_checkWrapT(value){value=value||"repeat";if(value!=="clampToEdge"&&value!=="mirroredRepeat"&&value!=="repeat"){this.error("Unsupported value for 'wrapT': '"+value+"' - supported values are 'clampToEdge', 'mirroredRepeat' and 'repeat'. Defaulting to 'repeat'.");value="repeat"}
return value}
_checkFlipY(value){return!!value}
_checkEncoding(value){value=value||"linear";if(value!=="linear"&&value!=="sRGB"&&value!=="gamma"){this.error("Unsupported value for 'encoding': '"+value+"' - supported values are 'linear', 'sRGB', 'gamma'. Defaulting to 'linear'.");value="linear"}
return value}
_webglContextRestored(){this._state.texture=new Texture2D(this.scene.canvas.gl);if(this._image){this.image=this._image}else if(this._src){this.src=this._src}}
_update(){const state=this._state;if(this._matrixDirty){let matrix;let t;if(this._translate[0]!==0||this._translate[1]!==0){matrix=math.translationMat4v([this._translate[0],this._translate[1],0],this._state.matrix)}
if(this._scale[0]!==1||this._scale[1]!==1){t=math.scalingMat4v([this._scale[0],this._scale[1],1]);matrix=matrix?math.mulMat4(matrix,t):t}
if(this._rotate!==0){t=math.rotationMat4v(this._rotate*0.0174532925,[0,0,1]);matrix=matrix?math.mulMat4(matrix,t):t}
if(matrix){state.matrix=matrix}
this._matrixDirty=!1}
this._renderer.imageDirty()}
set image(value){this._image=ensureImageSizePowerOfTwo$2(value);this._image.crossOrigin="Anonymous";this._state.texture.setImage(this._image,this._state);this._state.texture.setProps(this._state);this._src=null;this._renderer.imageDirty()}
get image(){return this._image}
set src(src){this.scene.loading++;this.scene.canvas.spinner.processes++;const self=this;let image=new Image();image.onload=function(){image=ensureImageSizePowerOfTwo$2(image);self._state.texture.setImage(image,self._state);self._state.texture.setProps(self._state);self.scene.loading--;self.scene.canvas.spinner.processes--;self._renderer.imageDirty()};image.src=src;this._src=src;this._image=null}
get src(){return this._src}
set translate(value){this._translate.set(value||[0,0]);this._matrixDirty=!0;this._needUpdate()}
get translate(){return this._translate}
set scale(value){this._scale.set(value||[1,1]);this._matrixDirty=!0;this._needUpdate()}
get scale(){return this._scale}
set rotate(value){value=value||0;if(this._rotate===value){return}
this._rotate=value;this._matrixDirty=!0;this._needUpdate()}
get rotate(){return this._rotate}
get minFilter(){return this._state.minFilter}
get magFilter(){return this._state.magFilter}
get wrapS(){return this._state.wrapS}
get wrapT(){return this._state.wrapT}
get flipY(){return this._state.flipY}
get encoding(){return this._state.encoding}
destroy(){super.destroy();if(this._state.texture){this._state.texture.destroy()}
this._state.destroy();stats.memory.textures--}}
componentClasses[type$42]=Texture;const type$43="xeogl.Fresnel";class Fresnel extends Component{get type(){return type$43}
init(cfg){super.init(cfg);this._state=new State({edgeColor:math.vec3([0,0,0]),centerColor:math.vec3([1,1,1]),edgeBias:0,centerBias:1,power:1});this.edgeColor=cfg.edgeColor;this.centerColor=cfg.centerColor;this.edgeBias=cfg.edgeBias;this.centerBias=cfg.centerBias;this.power=cfg.power}
set edgeColor(value){this._state.edgeColor.set(value||[0.0,0.0,0.0]);this._renderer.imageDirty()}
get edgeColor(){return this._state.edgeColor}
set centerColor(value){this._state.centerColor.set(value||[1.0,1.0,1.0]);this._renderer.imageDirty()}
get centerColor(){return this._state.centerColor}
set edgeBias(value){this._state.edgeBias=value||0;this._renderer.imageDirty()}
get edgeBias(){return this._state.edgeBias}
set centerBias(value){this._state.centerBias=(value!==undefined&&value!==null)?value:1;this._renderer.imageDirty()}
get centerBias(){return this._state.centerBias}
set power(value){this._state.power=(value!==undefined&&value!==null)?value:1;this._renderer.imageDirty()}
get power(){return this._state.power}
destroy(){super.destroy();this._state.destroy()}}
componentClasses[type$43]=Fresnel;const scenes=core.scenes;const getDefaultScene=core.getDefaultScene;const setDefaultScene=core.setDefaultScene;const scheduleTask=tasks.scheduleTask;const clear=core.clear;const _isString=utils.isString;const _apply=utils.apply;const _isNumeric=utils.isNumeric;exports.scenes=scenes;exports.getDefaultScene=getDefaultScene;exports.setDefaultScene=setDefaultScene;exports.scheduleTask=scheduleTask;exports.clear=clear;exports._isString=_isString;exports._apply=_apply;exports._isNumeric=_isNumeric;exports.WEBGL_INFO=WEBGL_INFO;exports.stats=stats;exports.math=math;exports.Component=Component;exports.CameraFlightAnimation=CameraFlightAnimation;exports.Canvas=Canvas;exports.Spinner=Spinner;exports.Clip=Clip;exports.CameraControl=CameraControl;exports.Geometry=Geometry;exports.BoxGeometry=BoxGeometry;exports.TorusGeometry=TorusGeometry;exports.SphereGeometry=SphereGeometry;exports.OBBGeometry=OBBGeometry;exports.AABBGeometry=AABBGeometry;exports.CylinderGeometry=CylinderGeometry;exports.PlaneGeometry=PlaneGeometry;exports.Input=Input;exports.AmbientLight=AmbientLight;exports.DirLight=DirLight;exports.PointLight=PointLight;exports.SpotLight=SpotLight;exports.CubeTexture=CubeTexture;exports.LightMap=LightMap;exports.ReflectionMap=ReflectionMap;exports.Shadow=Shadow;exports.Model=Model;exports.Mesh=Mesh;exports.Group=Group;exports.Object=xeoglObject;exports.Material=Material;exports.PhongMaterial=PhongMaterial;exports.LambertMaterial=LambertMaterial;exports.SpecularMaterial=SpecularMaterial;exports.MetallicMaterial=MetallicMaterial;exports.EmphasisMaterial=EmphasisMaterial;exports.EdgeMaterial=EdgeMaterial;exports.OutlineMaterial=OutlineMaterial;exports.Texture=Texture;exports.Fresnel=Fresnel;exports.Viewport=Viewport;exports.Camera=Camera;exports.Frustum=Frustum;exports.Ortho=Ortho;exports.Perspective=Perspective;exports.CustomProjection=CustomProjection;exports.Scene=Scene;Object.defineProperty(exports,'__esModule',{value:!0})})))